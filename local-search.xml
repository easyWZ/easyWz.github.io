<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2024/03/04/httpInterviewQuestion/"/>
    <url>/2024/03/04/httpInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45819386/article/details/123219420">资料一</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">http简介</a></li><li><a href="#question2">http工作原理</a></li><li><a href="#question3">http优缺点</a></li><li><a href="#question4">请求类型get和post区别</a></li><li><a href="#question5">http和https区别</a></li><li><a href="#question6">常见http状态码</a></li><li><a href="#question7">HTTP常见的字段有哪些？</a></li><li>三次握手四次挥手</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">HTTP 简介：</a><ol><li>HTTP 协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议；</li><li>HTTP 是一个基于TCP&#x2F;IP通信协议来传递数据（HTML文件、图片文件、查询结果等）；</li></ol></li><li><a id="question2">HTTP工作原理：</a><ol><li>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端发送所有请求。</li><li>web服务器有：Apache 服务器、lls服务器等；</li><li>HTTP默认端口号为80，但是也可以改为8080或者其他端口；</li></ol></li><li><a id="question3">HTTP的优点和缺点？</a><ol><li>优点<ol><li>支持客户&#x2F;服务器模式</li><li>应用广泛且跨平台</li><li>简单快速、灵活</li></ol></li><li>缺点<ol><li>无连接：</li><li>无状态：无状态可以减轻服务器负担，但进行关联操作时繁琐，Cookie正好可以解决这个问题</li><li>明文传输:调试便利的同时带来了信息易被窃取</li><li>不安全:（HTTPS通过引入SSL&#x2F;TLS层，解决了这个隐患）</li></ol></li></ol></li><li><a id="question4">请求类型Get与Post之间的区别？</a><ol><li>get重点在从服务器上获取资源，post重点在向服务器发送数据；</li><li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等； post较get安全性较高；</li><li>get传输数据是通过URL请求，以field（字段）&#x3D; value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&password=admin%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%94%A8%E6%88%B7%E6%98%AF%E5%8F%AF%E8%A7%81%E7%9A%84%EF%BC%9Bpost%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87Http%E7%9A%84post%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86%E5%AD%97%E6%AE%B5%E4%B8%8E%E5%AF%B9%E5%BA%94%E5%80%BC%E5%B0%81%E5%AD%98%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BD%93%E4%B8%AD%E5%8F%91%E9%80%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AF%B9%E7%94%A8%E6%88%B7%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的</a></li><li>Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；</li><li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。</li></ol></li><li><a id="question5">HTTP与HTTPS的区别？</a><ol><li>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>HTTP和HTTPS 使用完全不同的连接方式，所用的端口不同，前者是80 端口，后者是 443端口</li></ol></li><li><a id="question6">常见HTTP的状态码有哪些？</a><ol><li>200 – 请求成功</li><li>301 – 资源(网页等)被永久转移到其它URL</li><li>404 – 请求的资源(网页等)不存在</li><li>500 – 内部服务器错误</li></ol></li><li><a id="question7">HTTP常见的字段有哪些？</a><ol><li>URI&amp;URL：<ol><li>URI:统一资源标识符，不仅可以标识http，ftp等其他的网络资源</li><li>URL:统一资源定位符</li></ol></li><li>请求头：<ol><li>Accept可接受的响应内容类型（Content-Types）。</li><li>Accept-Charset可接受的字符集</li><li>Accept-Encoding可接受的响应内容的编码方式。</li><li>Accept-Language可接受的响应内容语言列表。</li><li>Accept-Datetime可接受的按照时间来表示的响应内容版本</li><li>Authorization用于表示HTTP协议中需要认证资源的认证信息</li></ol></li><li>请求方法：<ol><li>GET ：获取一个资源，同时参数直接跟在URL后面,url长度受限制2048字节</li><li>POST：不仅可以获取资源，还可以提交资源（譬如上传文件），参数放在请求体中，包大小4G</li><li>HEAD：只要响应头，没有响应体，通常用于测试URL是否存在</li><li>DELETE:删除一个资源</li><li>PUT：通常修改一个资源</li><li>OPTIONS：询问服务器支持的方法</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接</li></ol></li><li>响应头:<ol><li>Content-Length:响应体的长度</li><li>Server：服务器的信息</li><li>Content-Type：内容的类型，text／html，xml等</li><li>Last-Modified ：最有的修改日期，通常跟缓存相关 20151108</li><li>Location: 新的地址</li></ol></li><li>响应码:<ol><li>200 OK 访问正常</li><li>206 跟断点续传相关</li><li>3XX 重定向：Location</li><li>304 缓存有效</li><li>307 临时重定向</li><li>4XX 客户端问题</li><li>401 代表没有权限访问</li><li>404 代表访问的资源不存在</li><li>5XX 通常服务器内部处理的问题</li></ol></li></ol></li><li><a id="question8">三次握手与四次挥手</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/03/01/gitInterviewQuestion/"/>
    <url>/2024/03/01/gitInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7122755913043148813">资料一</a><br><a href="https://blog.csdn.net/nobody_1/article/details/88956315">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">常用git命令</a></li><li><a href="#question2">提交时产生冲突，如何产生如何解决</a></li><li><a href="#question3">提交误操作，怎么撤销</a></li><li><a href="#question4">如何修改提交的历史信息</a></li><li><a href="#question5">git stash</a></li><li><a href="#question6">如何查看分支提交的历史记录，查看某个文件的历史记录</a></li><li><a href="#question7">git fetch和git pull区别</a></li><li><a href="#question8">git merge和git rebase区别</a></li><li><a href="#question9">git系统中HEAD，工作树和索引区别</a></li><li><a href="#question10">之前项目中使用GitFlow工作流程吗，有什么好处</a></li><li><a href="#question11">git cherry-pick</a></li><li><a href="#question12">git和其他版本控制器有啥区别</a></li><li><a href="#question13">忽略提交</a></li><li><a href="#question14">如何把本地仓库的内容推向一个空的远程仓库</a></li><li><a href="#question15">git submodule</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><p><a id="question1">列举工作中常用的几个git命令？</a></p><ol><li>git add file || git add</li><li>git commit -m || git commit -a</li><li>git status -s</li><li>git fetch&#x2F;git merge || git pull</li><li>git feflog</li></ol></li><li><p><a id="question2">提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？</a></p></li><li><p><a id="question3">如果本次提交误操作，如何撤销？</a></p><ol><li>撤销提交到索引区的文件，可以通过git reset HEAD file</li><li>撤销提交到本地仓库的文件，可以通过git reset –soft HEAD^n恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更</li><li>通过git reset –mixed HEAD^n恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更</li><li>通过git reset –hard HEAD^n恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。</li></ol></li><li><p><a id="question4">如果我想修改提交的历史信息，应该用什么命令？</a></p><ol><li>修改最近一次提交的历史记录，就可以用git commit –amend命令；</li><li>修改之前提交的历史记录，就需要按照下面的步骤<ol><li>首先查看前三次的提交历史记录：<code>git log -3</code></li><li>执行命令git rebase –i HEAD~3，会把前3次的提交记录按照倒叙列出来；</li><li>根据提示，执行git commit –amend命令，进入vim编辑器并修改提交信息。</li><li>然后执行git rebase –continue命令</li></ol></li></ol></li><li><p><a id="question5">你使用过git stash命令吗？你一般什么情况下会使用它？</a></p><ol><li>命令git stash是把工作区修改的内容存储在栈区。<ol><li>解决冲突文件时，会先执行git stash，然后解决冲突；</li><li>遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发；</li><li>切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换；</li></ol></li></ol></li><li><p><a id="question6">如何查看分支提交的历史记录？查看某个文件的历史记录呢？</a></p><ol><li>命令git log –number：表示查看当前分支前number个详细的提交历史记录；</li><li>命令git log –number –pretty&#x3D;oneline：在上个命令的基础上进行简化，只显示sha-1码和提交信息；</li><li>命令git reflog –number: 表示查看所有分支前number个简化的提交历史记录；</li><li>命令git reflog –number –pretty&#x3D;oneline：显示简化的信息历史信息；</li><li>如果要查看某文件的提交历史记录，直接在上面命令后面加上文件名即可。</li><li>注意：如果没有number则显示全部提交次数。</li></ol></li><li><p><a id="question7">能不能说一下git fetch和git pull命令之间的区别？</a></p><ol><li>git fetch branch是把名为branch的远程分支拉取到本地；</li><li>而git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull &#x3D; fetch + merge。</li></ol></li><li><p><a id="question8">使用过git merge和git rebase吗？它们之间有什么区别？</a></p><ol><li>git merge和git rebase都是合并分支的命令。</li><li>git merge branch会把branch分支的差异内容pull到本地，然后与本地分支的内容一并形成一个committer对象提交到主分支上，合并后的分支与主分支一致；</li><li>git rebase branch会把branch分支优先合并到主分支，然后把本地分支的commit放到主分支后面，合并后的分支就好像从合并后主分支又拉了一个分支一样，本地分支本身不会保留提交历史。</li></ol></li><li><p><a id="question9">能说一下git系统中HEAD、工作树和索引之间的区别吗？</a></p><ol><li>HEAD文件包含当前分支的引用（指针）；</li><li>工作树是把当前分支检出到工作空间后形成的目录树，一般的开发工作都会基于工作树进行；</li><li>索引index文件是对工作树进行代码修改后，通过add命令更新索引文件；GIT系统通过索引index文件生成tree对象；</li></ol></li><li><p><a id="question10">之前项目中是使用的GitFlow工作流程吗？它有什么好处？</a></p><ol><li>GitFlow可以用来管理分支。GitFlow工作流中常用的分支有下面几类：<ol><li>master分支</li><li>develop分支</li><li>feature分支</li><li>release分支</li><li>hotfix分支</li></ol></li><li>GitFlow主要工作流程<ol><li>初始化项目为gitflow , 默认创建master分支 , 然后从master拉取第一个develop分支</li><li>从develop拉取feature分支进行编码开发(多个开发人员拉取多个feature同时进行并行开发 , 互不影响)</li><li>feature分支完成后 , 合并到develop(不推送 , feature功能完成还未提测 , 推送后会影响其他功能分支的开发)；合并feature到develop , 可以选择删除当前feature , 也可以不删除。但当前feature就不可更改了，必须从release分支继续编码修改</li><li>从develop拉取release分支进行提测 , 提测过程中在release分支上修改BUG</li><li>release分支上线后 , 合并release分支到develop&#x2F;master并推送；合并之后，可选删除当前release分支，若不删除，则当前release不可修改。线上有问题也必须从master拉取hotfix分支进行修改；</li><li>上线之后若发现线上BUG , 从master拉取hotfix进行BUG修改；</li><li>hotfix通过测试上线后，合并hotfix分支到develop&#x2F;master并推送；合并之后，可选删除当前hotfix ，若不删除，则当前hotfix不可修改，若补丁未修复，需要从master拉取新的hotfix继续修改；</li><li>当进行一个feature时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前feature分支；</li><li>当进行一个release分支时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前release分支 (!!! 因为当前release分支通过测试后会发布到线上 , 如果不合并最新的develop分支 , 就会发生丢代码的情况)；</li><li>GitFlow的好处:为不同的分支分配一个明确的角色，并定义分支之间如何交互以及什么时间交互；可以帮助大型项目理清分支之间的关系，简化分支的复杂度。</li></ol></li></ol></li><li><p><a id="question11">使用过git cherry-pick，有什么作用？</a></p><ol><li>命令git cherry-pick可以把branch A的commit复制到branch B上。</li><li>在branch B上进行命令操作：<ol><li>复制单个提交：git cherry-pick commitId</li><li>复制多个提交：git cherry-pick commitId1…commitId3</li><li>注意：复制多个提交的命令不包含commitId1.</li></ol></li></ol></li><li><p><a id="question12">git跟其他版本控制器有啥区别？</a></p><ol><li>GIT是分布式版本控制系统，其他类似于SVN是集中式版本控制系统。</li><li>分布式区别于集中式在于：每个节点的地位都是平等，拥有自己的版本库，在没有网络的情况下，对工作空间内代码的修改可以提交到本地仓库，此时的本地仓库相当于集中式的远程仓库，可以基于本地仓库进行提交、撤销等常规操作，从而方便日常开发。</li><li></li></ol></li><li><p><a id="question13">我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git status时都让这些文件显示出来，我们该如何操作？</a></p><ol><li>touch .gitignore<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ vim <span class="hljs-string">.gitignore</span><br>$ cat <span class="hljs-string">.gitignore</span><br><span class="hljs-string">/target/class</span><br><span class="hljs-string">.settings</span><br><span class="hljs-string">.imp</span><br>*<span class="hljs-string">.ini</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><a id="question14">如何把本地仓库的内容推向一个空的远程仓库？</a></p></li><li><p><a id="question15">git submodule</a></p><ol><li>Git 工具的 submodule 功能就是建立了当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。</li><li>当项目比较复杂，部分代码希望独立为子模块进行版本控制时，可以使用 git submodule 功能。</li><li>使用 git submodule 功能时，主项目仓库并不会包含子模块的文件，只会保留一份子模块的配置信息及版本信息，作为主项目版本管理的一部分。</li><li>一个有用的场景是：当项目依赖并跟踪一个开源的第三方库时，将第三方库设置为submodule。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2024/02/29/webpackInterviewQuestion/"/>
    <url>/2024/02/29/webpackInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7066807280557096974">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/44438844">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">简单说一下webpack的构建流程</a></li><li><a href="#question2">Loader和Plugin的区别</a></li><li><a href="#question3">webpack的热更新原理</a></li><li><a href="#question4">如何提高webpack的打包速度</a></li><li><a href="#question5">如何减少webpack打包体积</a></li><li><a href="#question6">有哪些常用的loader</a></li><li><a href="#question7">常用的plugin</a></li><li><a href="#question8">用过哪些可以提供效率的插件</a></li><li><a href="#question9">source map是什么，生产环境怎么用</a></li><li><a href="#question10">文件指纹是什么</a></li><li><a href="#question11">tree shaking原理是什么</a></li><li><a href="#question12">说一下Babel原理</a></li><li><a href="#question13">有写过loader吗 简述一下思路</a></li><li><a href="#question14">有写过plugin吗 简述一下思路</a></li><li><a href="#question15">怎么配置单页应用？怎么配置多页应用？</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">简单说一下 webpack 的构建流程</a><ol><li><strong>初始化参数</strong>：从配置文件和shell语句中读取与合并参数，得到最终的参数。</li><li><strong>开始编译</strong>：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行compiler对象的run方法开始执行编译。</li><li><strong>确定入口</strong>：根据配置中的entry找出所有的入口文件</li><li><strong>编译模块</strong>：从入口文件出发，调用所有配置的Loader对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理。</li><li><strong>完成模块编译</strong>：在经过第四步使用Loader编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系。</li><li><strong>输出资源</strong>：根据入口和模块之间的关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</li><li><strong>输出完成</strong>：在确定输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol></li><li><a id="question2">Loader 和 Plugin 的区别</a><ol><li><strong>Loader</strong>本质就是一个函数，在该函数对接收到的内容进行转换，返回转换后的结果。你可以理解为是一个“管道”，在外部接收到的内容通过这个“管道”进行转换，然后再将转换后的结果输出。因为 webpack 只认识 js，所以，你也可以将 Loader 称之为“翻译官”，对其他类型的资源进行转译的预处理工作。</li><li><strong>Plugin</strong> 直译为插件，基于事件流框架 Tapable。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。<ol><li>通过这个 Tapable 框架，你可以更深层的谈一下 webpack 底层 plugin 是如何实现的以及微内核，其实 webpack 就是微内核架构的一个例子，本质上就是一个是很小的功能，它并没有携带任何业务的功能，比如：打包多个页面，在打包页面上做相应的操作，其实它都没有，形象的来说它更像是一个底座，这底座可以插上各个地方增添的功能</li><li>扩展：<ol><li>微内核系统一般分为两部分 —核心系统和插件系统，这样就提供了很好的灵活性和可扩展性。核心系统是最小可运行的模块，它提供的是通用逻辑（比如 Tapable），而插件系统这些是具体的逻辑（比如HtmlWebpackPlugin插件），再比如系统怎么跑起来，插件之间怎么通信等模块都属于核心系统里面，让系统更加丰富多彩就是插件系统了。插件之间可以相互独立，也可以有依赖。</li><li>核心系统怎么知道哪些插件可用呢？<ol><li>这就需要注册表了，其实我们的 webpack.config.js 就起到了这样的作用，它告诉我们需要使用哪些插件。</li></ol></li><li>插件系统和核心系统怎么通信呢？<ol><li>这就需要用到 Tapable 了，里面有各种 hooks，并且在运行各个生命周期过程中会执行对应的回调。我们的核心系统有生命周期的概念，插件里面也有，因为它们的架构是类似的。我们的核心系统在运行后会先读取注册表信息，这个过程其实就是订阅事件，主车回调的过程。插件可以在运行回调的过程中再不断订阅自己需要的其他事件，注册其他回调。服务于具体逻辑的插件模块是独立于核心系统之外的，但是它可能会需要操作核心模块的系统服务来实现这些规定的功能，此时核心系统需要提供一个上下文对象（context），当然，插件模块与外部进行交互只允许通过此上下文对象完成。上下文对象提供了基础操作（调起其他插件模块、调起系统服务，获取系统信息）的 API 和事件。</li><li>这样待核心系统的生命周期顺序执行的过程，也就伴随这对应的时期的插件的生命周期交替执行，生命周期走完了，整个程序流程也就结束了。</li></ol></li></ol></li></ol></li></ol></li><li><a id="question3">说一下 webpack 的热更新原理</a><ol><li>webpack 的热更新又称为热替换（Hot Module Replacement），缩写为 HMR，这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</li><li>HMR 的核心就是客户端从服务端拉取更新后的文件，准确的说是 chunk diff（chunk需要更新的部分），实际上 webpack-dev-server 与浏览器之间维护了一个 WebSocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 ajax 请求来获取更改内容（文件列表、hash），这样客户端就可以再借助这些信息继续向 webpack-dev-server 发起 jsonp 请求获取该 chunk 的增量更新。后续的部分由 HotModulePlugin 来完成，提供了相关的 API 以供开发真针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</li><li><a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></li><li>基本实现原理大致这样的，构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。</li></ol></li><li><a id="question4">如何提高 webpack 的打包速度？</a><ol><li>多入口情况下，使用 optimization.splitChunks 来提取公共代码。</li><li>通过 externals 配置来提取常用库。</li><li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块，通过 DllPlugin 来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin 将编译编译的模块加载进来。</li><li>使用 thread-loader 实现多进程加速编译。</li><li>使用 terser-webpack-plugin 对js进行代码压缩。</li><li>优化 resolve 配置缩小范围。</li><li>使用 tree-shaking 和 Scope hoisting 来剔除多余代码。</li></ol></li><li><a id="question5">如何减少 webpack 打包体积？</a><ol><li>使用 externals 配置来提取常用库。</li><li>使用 tree-sjaking 和 scope hoisting 来剔除多余代码。</li><li>使用 optimize-css-assets-webpack-plugin 压缩css。</li><li>使用 terser-webpack-plugin 对 js 进行代码压缩。</li></ol></li><li><a id="question6">webpack 有哪些常见的 loader？你用过哪些 loader？</a><ol><li>cache-loader：可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里。</li><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件（处理图片、字体、图标）。</li><li>url-loader：与file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader，小于阈值时返回文件 base64 形式编码（处理图片）。</li><li>image-loader：加载并且压缩图片文件。</li><li>babel-loader：把 ES6 转换成 ES5。</li><li>ts-loader：将 typescript 转换成 JavaScript。</li><li>svg-inline-loader：将压缩后的SVG内容注入代码中。</li><li>raw-loader：加载文件原始内容（utf-8）。</li><li>sass-loader：将 scss&#x2F;sass 代码转换成 css。</li><li>css-loader：加载 css，支持模块化、压缩、文件导入等特性。</li><li>less-loader：将 less 代码转换成 css。</li><li>style-loader：生成 style 标签，将 js 中的样式资源插入，并添加到 header 中生效。</li><li>postcss-loader：扩展 css 语法，使用下一代 css，可以配合 autoprefixer 插件自动补齐 css3 前缀。</li><li>eslint-loader：通过 eslint 检查 JavaScript 代码。</li><li>tslint-loader：通过tslint 检查 typesc 代码。</li><li>vue-loader：加载 vue.js 单文件组件。</li><li>awesome-typescript-loader：将 typescript 转换成 JavaScript，性能优于 ts-loader。</li></ol></li><li><a id="question7">webpack 有哪些常见的 plugin？你用过哪些 plugin？</a><ol><li>ignore-plugin：忽略部分文件。</li><li>html-webpack-plugin：简化 html 文件创建。</li><li>web-webpack-plugin：可以方便地为单页应用输出 html，比 html-webpack-plugin 好用。</li><li>terser-webpack-plugin：支持压缩ES6。</li><li>optimize-css-assets-webpack-plugin：压缩css代码。</li><li>mini-css-extract-plugin：分离样式文件，css 提取为单独文件，支持按需加载。</li><li>werviceworker-webpack-plugin：为网页应用追加离线缓存功能。</li><li>clean-webpack-plugin：目录清理。</li><li>ModuleconcatenationPlugin：开启 Scope Hoisting。</li><li>ebpack-bundle-analyzer：可视化 webpack 输出文件的体积（业务组件、依赖第三方模块）。</li><li>speed-measure-webpack-plugin：可以看到每个 loader 和 plugin 执行耗时（这个打包耗时、plugin 和 loader 耗时）。</li><li>HotModuleReplacementPlugin：模块热替换。</li></ol></li><li><a id="question8">在使用 webpack 开发时，你用过哪些可以提供效率的插件？</a><ol><li>webpack-dashboard：可以更有好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码。</li><li>speed-measure-webpack-plugin：简称SMP，分析出 webpack 打包过程中 loader 和 plugin的耗时，有助于找到构建过程中的性能瓶颈。</li><li>HotModuleReplacementPlugin：模块热替换。</li><li>size-plugin：监控资源体积变化，尽早发现问题。</li></ol></li><li><a id="question9">source map 是什么？生产环境怎么用？</a><ol><li>source map 是将编译、打包、压缩后的代码映射会源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 source map。</li><li>map 文件只要不打开开发者工具，浏览器是不会加载的。</li><li>生产环境一般有三种处理方案：<ol><li>hidden-source-map：借助第三方错误监控平台 Sentry 使用。</li><li>nosource-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 source-map 高</li><li>source-map：通过 nginx 设置将.map文件指对白名单开发。 注意：在生产环境中避免使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。</li></ol></li></ol></li><li><a id="question10">文件指纹是什么？</a><ol><li>文件指纹是指打包后输出文件的名的后缀。<ol><li>hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 就会变化。</li><li>chunkhash：和webpack打包的 chunk 有关，不同的 chunk、不同的 entry 会生成不同的 chunkhash。</li><li>contenthash：根据文件内容来定义 hash，文件内容不发生变化，则contenthash就不会变化。 直接在输出文件名添加对应的 hash值即可。</li></ol></li></ol></li><li><a id="question11">tree shaking 原理是什么？</a><ol><li>webpack中，tree-shaking 的实现 一是先标记出模块导出值中哪些没有被动用过，二是 Terser 使用删除掉这些没被用到的导出语句。</li><li>标记功能需要配置 optimization.usedExports &#x3D; true 开启   <ol><li>标记过程大致可划分为三个步骤：<ol><li>Make 阶段：收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中。</li><li>Seal 阶段：遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时：若变量没有被其他模块使用则删除对应的导出语句。 Webpack 中 Tree Shaking 的实现分为如下步骤：<ol><li>在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中</li><li>在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中</li><li>在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语句</li><li>使用 DCE 工具删除 Dead Code，实现完整的树摇效果 <a href="https://juejin.cn/post/7002410645316436004">详细tree-shaking原理</a></li></ol></li></ol></li></ol></li></ol></li><li><a id="question12">说一下 Babel 原理</a><ol><li>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：<ol><li>解析：将代码转换成 AST (抽象语法树AST)<ol><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ol></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ol><li>Taro就是利用 babel 完成的小程序语法转换</li></ol></li><li>生成：以新的 AST 为基础生成代码 <a href="https://juejin.cn/post/6844903746804137991">详细参考</a></li></ol></li></ol></li><li><a id="question13">有写过 loader 吗？简单描述一下思路</a><ol><li>开发的基本思路：因为 loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 loader 只负责自己需要负责的事情</li><li>loader 拿到的是源文件的内容（content）</li><li>通过**this.getOptions() **拿到传入的参数，</li><li>可以通过返回值的方式将处理后的内容输出或者通过 <strong>this.callback()</strong> 同步方式将内容返回出去，<ol><li>也可以调用 this.async() 生成一个异步的函数， callback 来处理传入的内容，</li></ol></li><li>再通过调用 <strong>cabllback（）</strong>将处理后的内容返回出去。</li><li>开发的过程中尽量使用异步 loader。使用 schema-utils 来检验的我们的参数。然后再利用第三方提供的模块进行 loader 的开发。</li></ol></li><li><a id="question14">有写过 plugin 吗？简答描述一下思路</a><ol><li>开发的基本思路： webpack 在运行生命周期中会广播出许多事件，PLugin 可以监听这些事件，在特定的阶段写入想要添加的自定义功能。webpack 的 tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</li><li>通过 consturctor 获取传入的配置参数</li><li>apply() 方法得到 compiler，</li><li>compiler 暴露了和 webpack 整个生命周期相关的钩子</li><li>通过 conpiler.hooks.thiscompilation 初始 compilation。</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子，</li><li>再使用相关的 hooks 对资源进行添加或者修改。</li><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改（emit 事件是修改 webpack 输出资源的最后时机）。</li><li>异步的事件需要再插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住。</li></ol></li><li><a id="question15">怎么配置单页应用？怎么配置多页应用？</a><ol><li>单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可</li><li>多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：<ol><li>每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表</li><li>随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</li></ol></li><li>如何进行多页面打包配置？<ol><li>配置多个入口文件</li><li>借助HtmlwebpackPlugin插件创建对应html<ol><li>配置多个entry, 需要new多个htmlWebpackPlugin</li><li>配置template, filename, 对应的chunks</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react.js</title>
    <link href="/2024/02/28/reactInterviewQuestion/"/>
    <url>/2024/02/28/reactInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/677917087">资料一</a></p><ol><li>说说对React的理解?有哪些特性?</li><li>state和props有什么区别?</li><li>super()和super(props)有什么区别?</li><li>说说对React中类组件和函数组件的理解?有什么区别?</li><li>说说对受控组件和非受控组件的理解?应用场景?</li><li>说说React的事件机制?</li><li>React事件绑定的方式有哪些?区别?</li><li>React构建组件的方式有哪些?区别?</li><li>说说react中引入css的方式有哪几种?区别?</li><li>说说React生命周期有哪些不同阶段?每个阶段对应的方法是?</li><li>React中组件之间如何通信?</li><li>说说对高阶组件的理解?应用场景?</li><li>在react中组件间过渡动画如何实现?</li><li>说说你在React项目是如何捕获错误的?</li><li>说说对React refs的理解?应用场景?</li><li>说说React中的setState执行机制</li><li>说说React render方法的原理?在什么时候会被触发?</li><li>说说Real DOM和Virtual DOM的区别?优缺点?</li><li>说说React Jsx转换成真实DOM过程?</li><li>说说对Fiber架构的理解?解决了什么问题?</li><li>React中的key有什么作用?</li><li>说说React diff的原理是什么?</li><li>说说对React Hooks的理解?解决了什么问题?</li><li>说说你是如何提高组件的渲染效率的?在React中如何避免不必要的render?</li><li>说说React性能优化的手段有哪些?</li><li>说说你对React Router的理解?常用的Router组件有哪些?</li><li>说说React Router有几种模式?实现原理?</li><li>你在React项目中是如何使用Redux的?项目结构是如何划分的?</li><li>说说对Redux中间件的理解?常用的中间件有哪些?实现原理?</li><li>说说你对immutable的理解?如何应用在react项目中?</li><li>说说React服务端渲染怎么做?原理是什么?</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js</title>
    <link href="/2024/02/28/VueInterviewQuestion/"/>
    <url>/2024/02/28/VueInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7139921537896808479">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/677917087">资料二</a><br><a href="https://juejin.cn/post/7208005892313579576">资料三</a><br><a href="https://juejin.cn/post/7275943802934149160#heading-2">资料四</a><br><a href="https://juejin.cn/post/7227453567686033468#heading-11">资料五</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">Options Api与Composition Api的区别</a></li><li><a href="#question2">Vue3.0性能提升主要是通过哪几方面体现的</a></li><li><a href="#question3">Vue3.0里为什么要用Proxy API 替代defineProperty API</a></li><li><a href="#question4">Vue3响应式原理</a></li><li><a href="#question5">Vue3中Treeshaking特性，举例说明</a></li><li><a href="#question6">Vue3新特性</a></li><li><a href="#question7">Vue3组合式API生命周期钩子函数有变化吗</a></li><li><a href="#question8">watch和watchEffect的区别</a></li><li><a href="#question9">v-if和v-for的优先级哪个高</a></li><li><a href="#question10">script setup是干啥的</a></li><li><a href="#question11">vue2&#x2F;vue3组件通信方式</a></li><li><a href="#question12">ref与reactive的区别</a></li><li><a href="#question13">EventBus与mitt的区别</a></li><li><a href="#question14">谈谈pinia</a></li><li><a href="#question15">vue2和vuex3渲染器的diff算法区别</a></li></ol><h4 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h4><ol><li>请描述下对vue生命周期的理解</li><li>MVVM的理解？</li><li>双向数据绑定是什么</li><li>Vue2.x 响应式原理的理解</li><li>Vue2.x 中如何检测数组的变化？</li><li>Vue组件之间的通信方式都有哪些?</li><li>为什么data属性是一个函数而不是一个对象?</li><li>动态给vue的data添加一个新的属性时会发生什么?怎样解决?</li><li>v—if和v—for的优先级是什么?</li><li>v-show和v—if有什么区别?使用场景分别是什么?</li><li>你知道vue中key的原理吗?说说你对它的理解</li><li>说说你对vue的mixin的理解，有什么应用场景?</li><li>Vue常用的修饰符有哪些有什么应用场景</li><li>Vue中的$next Tick有什么作用?</li><li>Vue实例挂载的过程</li><li>你了解vue的diff算法吗?</li><li>Vue中组件和插件有什么区别?</li><li>Vue项目中你是如何解决跨域的呢?</li><li>有写过自定义指令吗?自定义指令的应用场景有哪些?</li><li>Vue中的过滤器了解吗?过滤器的应用场景有哪些?</li><li>说说你对slot的理解?slot使用场景有哪些?</li><li>什么是虚拟DOM?如何实现一个虚拟DOM?说说你的思路</li><li>Vue项目中有封装过axios吗?主要是封装哪方面的?</li><li>是怎么处理vue项目中的错误的?</li><li>你了解axios的原理吗?有看过它的源码吗?</li><li>vue要做权限管理该怎么做?</li><li>说说你对keep-alive的理解是什么?</li><li>你对SPA单页面的理解,它的优缺点分别是什么?如何实现SPA应用呢</li><li>SPA首屏加载速度慢的怎么解决?</li><li>vue项目本地开发完成后部署到服务器后报404是什么原因呢?</li><li>SSR解决了什么问题?有做过SSR吗?你是怎么做的?</li><li>说一下在 Vue2.x 中如何检测数组的变化？</li><li>如何让 CSS 值在当前的组件中起作用(scoped及其原理</li><li>scoped 是如何实现样式穿透的？</li><li>Vue 中如何进行组件的使用？Vue 如何实现全局组件的注册？</li><li>构建 vue-cli 工程都用到了哪些技术？他们的作用分别是什么？</li><li>vue-cli 工程常用的 npm 命令有哪些？</li><li>nextTick 的作用是什么？他的实现原理是什么？</li><li>说一下 Vue SSR 的实现原理</li><li>说一下 Vue 的 computed 的实现原理</li><li>说一下 Vue complier 的实现原理是什么样的？</li><li>vue 如何快速定位那个组件出现性能问题的</li><li>Vue 与 Angular 以及 React 的区别是什么？</li><li>说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？</li><li>说一下 ref 的作用是什么？</li><li>说一下你知道的 vue 修饰符都有哪些？</li><li>如何实现 vue 项目中的性能优化？</li><li>Vue.extend 和 Vue.component 的区别是什么？</li><li>vue 中的 spa 应用如何优化首屏加载速度?</li><li>移动端如何实现一个比较友好的 header 组件</li><li>既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？</li><li>Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？</li><li>你的接口请求一般放在哪个生命周期中？为什么要这样做？</li><li>说一下你对 vue 事件绑定原理的理解？</li><li>说一下 vue 模版编译的原理是什么</li><li>delete 和 Vue.delete 删除数组的区别是什么？</li><li>v-on 可以实现监听多个方法么？</li><li>vue 的数据为什么频繁变化但只会更新一次？</li><li>说一下 vue 中 computed 和 methods 的区别是什么？</li><li>在 Vue 中要获取当前时间你会放到 computed 还是 methods 里？</li><li>在给 vue 中的元素设置 key 值时可以使用 Math 的 random 方法么？</li><li>插槽与作用域插槽的区别是什么？</li><li>vue 中相同逻辑如何进行抽离？</li><li>如何监听 pushstate 和 replacestate 的变化呢？</li><li>说一说自定义指令有哪些生命周期？</li><li>vue 为什么采用异步渲染</li><li>组件中写 name 选项有哪些好处</li></ol><h4 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h4><ol><li>Vue3.0所采用的Composition Api 与Vue2.x使用的Options Api有什么不同?</li><li>vue3.0的设计目标是什么?做了哪些优化</li><li>用Vue3.0写过组件吗?如果想实现一个Modal你会怎么设计?</li><li>vue3.0性能提升主要是通过哪几方面体现的?</li><li>Vue3.0里为什么要用Proxy API替代defineProperty APl?</li><li>说说Vue 3.0中Treeshaking特性?举例说明—下?</li><li>描述Vu3生命周期</li><li>请介绍Vue3中的Teleport组件。</li><li>如何理解reactive、ref 、toRef 和 toRefs？</li><li>setup中如何获得组件实例？</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><p><a id="question1">Options Api与Composition Api的区别</a></p><ol><li><strong>Option api</strong>：选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑。用组件的选项（data,computed,methods,watch）组织逻辑在大多数情况下都有效。然而，当组件变得复杂，导致对应属性的列表也会增长，这可能导致组件难以阅读和理解。</li><li><strong>Composition api</strong>中，组件根据逻辑功能来组织，一个功能所定义的所有api会放在一起（高内聚，低耦合）</li><li>Composition api 相对 Option api的两大优点<ol><li>逻辑组织 <ol><li>option api在处理一个大型组件时，内部逻辑点容易碎片化，可能同时存在于method，computed，watch等api中，我们必须不断地跳转相关代码的选项块，这种碎片化使得理解和维护复杂组件变得困难。</li><li>Composition api将某个逻辑关注点相关的代码全都放在一个函数里，这样，当需要修改一个功能时，就不再需要在文件中跳来跳去。</li></ol></li><li>逻辑复用<ol><li>在vue2中，当混入多个mixin会存在两个非常明显的问题：命名冲突，数据来源不清晰</li><li>而composition api可以通过编写多个hooks函数就很好地解决了</li></ol></li></ol></li><li>总结：<ol><li>在逻辑组织和逻辑复用方面，Composition API是优于Option API</li><li>因为Composition API几乎是函数，会有更好的类型推断</li><li>Composition API对tree-shaking友好，代码也更容易压缩</li><li>Composition API中见不到this的使用，减少了this指向不明的情况</li><li>如果是小型组件，可以继续使用Option API</li></ol></li></ol></li><li><p><a id="question2">Vue3.0性能提升主要是通过哪几方面体现的</a></p><ol><li>编译阶段优化<ol><li>回顾vue2每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染。因此，vue3在编译阶段，做了进一步优化<ol><li>diff算法优化<ol><li>vue3在diff算法中相比于vue2增加了静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较</li></ol></li><li>静态提升<ol><li>vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。</li><li>没做静态提升之前，未参与更新的元素也在render函数内部，会重复创建阶段。做了静态提升后，未参与更新元素，被放置在render函数外，每次渲染的时候只要取出即可，同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于Diff。</li></ol></li><li>事件监听缓存<ol><li>默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用。</li></ol></li><li>SSR优化<ol><li>当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。</li></ol></li></ol></li></ol></li><li>源码体积<ol><li>相比vue2，vue3整体体积变小了，除了移出一些不常用的API，最重要的是Tree shanking。</li><li>任何一个函数，如ref，reavtived，computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。</li></ol></li><li>响应式系统<ol><li>vue2中采用defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。</li><li>vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。<ol><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组的length属性</li><li>可以监听删除属性</li></ol></li></ol></li></ol></li><li><p><a id="question3">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</a></p><ol><li>vue2中采用defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式，但是存在以下的问题：<ol><li>检测不到对象属性的添加和删除</li><li>数组api方法无法监听到</li><li>需要对每个对象进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ol></li><li>proxy：监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作。</li><li>总结：<ol><li>Object.defineProperty只能遍历对象属性进行劫持</li><li>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的。</li><li>Proxy可以直接监听数组的变化（push，shift，splice）</li><li>Proxy有多达13种拦截方法，不限于apply，ownKeys,deleteProperty,has等等，这是Object.defineProperty不具备的</li></ol></li></ol></li><li><p><a id="question4">Vue3.0响应式原理</a></p><ol><li>vue3响应式是使用ES6的proxy和Reflect相互配合实现数据响应式，解决了vue2中视图不能自动更新的问题。</li><li>proxy是深度监听，所以可以监听对象和数组内的任意元素，从而实现试图实时更新</li><li><a href="https://juejin.cn/post/6858899262596448270">详细的原理</a></li><li>总结响应式大致分为三个阶段：<ol><li>初始化阶段<ol><li>初始化阶段通过组件初始化方法形成对应的proxy对象，然后形成一个负责渲染的effect。</li></ol></li><li>get依赖收集阶段<ol><li>通过解析template，替换真实data属性，来触发get，然后通过stack方法，通过proxy对象和key形成对应的deps，将负责渲染的effect存入deps。（这个过程还有其他的effect，比如watchEffect存入deps中）</li></ol></li><li>set派发更新阶段<ol><li>当我通过this[key] &#x3D; value改变属性的时候，首先通过trigger方法，通过proxy对象和key找到对应的deps，然后给deps分类分成computedRunners和effect，然后依次执行，如果需要调度的，直接放入调度。</li></ol></li></ol></li><li>proxy只会代理对象的第一层，vue3怎么处理<ol><li>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理，这样就实现了深度观测</li></ol></li><li>监测数组时候可能会触发多次get&#x2F;set，如何防治<ol><li>可以判断key是否为当前代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一，才有可能执行trigger。</li></ol></li></ol></li><li><p><a id="question5">说说Vue 3.0中Treeshaking特性？举例说明一下？</a></p><ol><li>是什么<ol><li>tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫Dead code elimination</li><li>保持代码运行结果不变的前提下，去除无用的代码</li><li>vue2中，无论使用什么功能，最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到。</li><li>而vue3源码引入tree shaking特性，将全局API进行分块。如果不使用某些功能，就不会包含在基础包中。</li></ol></li><li>如何做<ol><li>tree shaking是基于ES6模版语法（import和exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量。</li><li>做了两件事：<ol><li>编译阶段利用ES6 Module判断哪些模块已经加载</li><li>判断哪些模块和变量未被使用或者引用，进而删除对应代码</li></ol></li></ol></li><li>作用<ol><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ol></li></ol></li><li><p><a id="question6">Vue3 新特性有哪些？</a></p><ol><li>性能提升<ol><li>Object.defineProperty改为proxy</li><li>重写了Vdom（diff算法优化，增加静态标记）</li><li>进行模版编译优化（静态提升，不参与更新的元素只被创建一次）</li><li>更加高效的组件初始化</li></ol></li><li>更好的支持TypeScript<ol><li>Vue.js 2.x 选用 Flow 做类型检查，来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好。</li><li>Vue.js 3.0 抛弃了 Flow ，使用 TypeScript 重构了整个项目</li><li>TypeScript 提供了更好的类型检查，能支持复杂的类型推断</li></ol></li><li>新增Composition API<ol><li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强。</li><li>在 Vue3 中，定义 methods、watch、computed、data数据等都放在了 setup() 函数中。</li><li>setup()函数会在created()生命周期之前执行。执行顺序为：beforeCreate &gt; setup &gt; created</li></ol></li><li>新增组件<ol><li>Fragment 不再限制 template 只有一个根节点。</li><li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li><li>Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li></ol></li><li>Tree-shaking：支持摇树优化<ol><li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快。</li></ol></li><li>Custom Renderer API： 自定义渲染器<ol><li>实现 DOM 的方式进行 WebGL 编程。</li></ol></li></ol></li><li><p><a id="question7">vue3 组合式API生命周期钩子函数有变化吗？</a></p><ol><li><img src="/img/js/17091064404677.jpg"></li></ol></li><li><p><a id="question8">watch 和 watchEffect 的区别？</a></p><ol><li>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：<ol><li><p>watch ：既要指明监视的数据源，也要指明监视的回调。</p></li><li><p>而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</p></li><li><p>watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</p></li><li><p>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。</p></li><li><p>watchEffect有点像 computed ：</p><ol><li>但 computed 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。</li><li>而 watcheffect注重的是过程（回调函数的函数体），所以不用写返回值。</li></ol></li><li><p>watch与 vue2.x中 watch 配置功能一致，但也有两个小坑</p><ol><li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，强制开启了深度监视（deep配置失效）</li><li>监视 reactive 定义的响应式数据中某个属性时，deep配置有效。</li></ol> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;你好啊&#x27;</span>)<br><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br><span class="hljs-attr">job</span>:&#123;<br><span class="hljs-attr">j1</span>:&#123;<br><span class="hljs-attr">salary</span>:<span class="hljs-number">20</span><br>&#125;<br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//情况1：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>)<br>&#125;)<br><span class="hljs-comment">//情况2：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum, msg],<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum或msg变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>)<br>&#125;)<br><span class="hljs-comment">//情况3：监视reactive定义的响应式数据</span><br><span class="hljs-comment">//若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue，且强制开启了深度监视。</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>) <span class="hljs-comment">//此处的deep配置不再生效。</span><br>&#125;)<br><span class="hljs-comment">//情况4：监视reactive所定义的一个响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.name变化了&quot;</span>, newValue, oldValue)<br>&#125;)<br><span class="hljs-comment">//情况5：监视reactive所定义的一个响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>, <span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">age</span>],<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.name或person.age变化了&quot;</span>, newValue, oldValue)<br>&#125;)<br><span class="hljs-comment">//特殊情况：</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.job变化了&quot;</span>, newValue, oldValue)<br>&#125;, &#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)       <br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><a id="question9">v-if 和 v-for 的优先级哪个高？</a></p><ol><li>vue2中v-for优先级高</li><li>vue3中v-if优先级高</li></ol></li><li><p><a id="question10">script setup 是干啥的？</a></p><ol><li>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：<ol><li>属性和方法无需返回，可以直接使用。</li><li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li><li>使用 defineProps 接收父组件传递的值。</li><li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li><li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li></ol></li></ol></li><li><p><a id="question11">Vue2&#x2F;Vue3组件通信方式？</a></p><ol><li><a href="https://juejin.cn/post/6999687348120190983">详细</a></li><li>vue3通信<ol><li>props</li><li>$emit</li><li>expose&#x2F;ref</li><li>attrs</li><li>v-model</li><li>provide&#x2F;inject</li><li>vuex&#x2F;pinia</li><li>mitt</li></ol></li><li>vue2通信<ol><li>props</li><li>.sync</li><li>v-model</li><li>ref</li><li>$emit&#x2F;v-on</li><li>$attrs&#x2F;$listeners</li><li>$children&#x2F;$parent</li><li>provide&#x2F;inject</li><li>EventBus</li><li>Vuex</li><li>$root</li><li>slot</li></ol></li></ol></li><li><p><a id="question12">ref与reactive的区别？</a></p><ol><li>ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。<ol><li>template 模板中使用的数据和方法，都需要通过 setup 函数 return 出去才可以被使用。</li><li>ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li><li>ref 函数可以接收原始数据类型与引用数据类型。</li><li>reactive 函数只能接收引用数据类型。</li><li>ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li><li>在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li></ol></li></ol></li><li><p><a id="question13">EventBus与mitt区别？</a></p><ol><li>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的 $on&#x2F;$emit&#x2F;$off 等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。</li><li>而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了， Vue3 推荐尽可能使用 props&#x2F;emits、provide&#x2F;inject、vuex 等其他方式来替代。</li><li>当然，如果 Vue3 内部的方式无法满足你，官方建议使用一些外部的辅助库，例如：mitt。其优点如下：<ol><li>非常小，压缩后仅有 200 bytes。</li><li>完整 TS 支持，源码由 TS 编码。</li><li>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</li><li>使用简单，仅有 on、emit、off 等少量实用API。</li></ol></li></ol></li><li><p><a id="question14">谈谈pinia?</a></p><ol><li>Pinia 是 Vue 官方团队成员专门开发的一个全新状态管理库，并且 Vue 的官方状态管理库已经更改为了 Pinia。在 Vuex 官方仓库中也介绍说可以把 Pinia 当成是不同名称的 Vuex 5，这也意味不会再出 5 版本了。</li><li>优点<ol><li>更加轻量级，压缩后提交只有1.6kb。</li><li>完整的 TS 的支持，Pinia 源码完全由 TS 编码完成。</li><li>移除 mutations，只剩下 state 、 actions 、 getters 。</li><li>没有了像 Vuex 那样的模块镶嵌结构，它只有 store 概念，并支持多个 store，且都是互相独立隔离的。当然，你也可以手动从一个模块中导入另一个模块，来实现模块的镶嵌结构。</li><li>无需手动添加每个 store，它的模块默认情况下创建就自动注册。</li><li>支持服务端渲染（SSR）。</li><li>支持 Vue DevTools。</li><li>更友好的代码分割机制，<a href="https://juejin.cn/post/7057439040911441957#heading-2">传送门</a>。</li></ol></li><li>Pinia 配套有个插件 pinia-plugin-persist进行数据持久化，否则一刷新就会造成数据丢失</li></ol></li><li><p><a id="question15">vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</a></p><ol><li>vue2 双端diff算法流程图<ol><li><img src="/img/js/17091115670083.jpg"></li></ol></li><li>vue3 快速diff算法流程图<ol><li><img src="/img/js/17091116068265.jpg"></li></ol></li><li>vue2、vue3 的 diff 算法实现差异<ol><li><ul><li><ol><li>主要体现在：处理完首尾节点后，对剩余节点的处理方式。</li><li>在 vue2 中是通过对旧节点列表建立一个 { key, oldVnode }的映射表，然后遍历新节点列表的剩余节点，根据newVnode.key在旧映射表中寻找可复用的节点，然后打补丁并且移动到正确的位置。</li><li>而在 vue3 中是建立一个存储新节点数组中的剩余节点在旧节点数组上的索引的映射关系数组，建立完成这个数组后也即找到了可复用的节点，然后通过这个数组计算得到最长递增子序列，这个序列中的节点保持不动，然后将新节点数组中的剩余节点移动到正确的位置。</li></ol></li></ul></li><li><ul><li><ol><li>Vue 2.x使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。</li><li>Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能</li><li>因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。</li></ol></li></ul></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文</title>
    <link href="/2024/02/19/frontInterviewQuestion/"/>
    <url>/2024/02/19/frontInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45712370/article/details/134951791">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/677919386">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">js的数据类型及他们的区别</a></li><li><a href="#question2">判断数据类型的几种方法</a></li><li><a href="#question3">作用域和作用域链</a></li><li><a href="#question4">原型和原型链</a></li><li><a href="#question5">闭包</a></li><li><a href="#question6">内存泄漏，垃圾回收机制</a></li><li><a href="#question7">js获取dom</a></li><li><a href="#question8">浅拷贝和深拷贝</a></li><li><a href="#question9">route和router的区别详解</a></li><li><a href="#question10">如何改变this指向（call，apply，bind区别）</a></li><li><a href="#question11">箭头函数与普通函数区别</a></li><li><a href="#question12">浏览器存储的区别</a></li><li><a href="#question13">继承方式</a></li><li><a href="#question14">常用的数组方法</a></li><li><a href="#question15">什么是promise</a></li><li><a href="#question16">async，await</a></li><li><a href="#question17">宏任务和微任务以及执行顺序</a></li><li><a href="#question18">var let const的区别</a></li><li><a href="#question19">ES6的新特性</a></li><li><a href="#question20">从浏览器输入url后都经历了什么</a></li><li><a href="#question21">TCP协议和HTTP协议</a></li><li><a href="#question22">http和https区别</a></li><li><a href="#question23">如何解决前端跨域问题</a></li><li><a href="#question24">websocket和webwork</a></li><li><a href="#question25">性能优化</a></li><li><a href="#question26">Webpack是什么</a></li><li><a href="#question27">Webpack的基本功能？</a></li><li><a href="#question28">标准盒模型和怪异盒模型（IE盒模型）</a></li><li><a href="#question29">让一个元素水平&#x2F;垂直居中</a></li><li><a href="#question30">flex：1代表什么</a></li><li><a href="#question31">回溯算法</a></li><li><a href="#question32">冒泡算法排序</a></li><li><a href="#question33">快速排序</a></li><li><a href="#question34">什么是MVVM，MVC模型</a></li><li><a href="#question35">写react&#x2F;vue项目中为什么要在列表组件中写key，其作用是什么</a></li><li><a href="#question36"><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code></a></li><li><a href="#question37">防抖和节流的区别和实现</a></li><li><a href="#question38">Set,Map.WeakSet和WeakMap的区别</a></li><li><a href="#question39">深度优先遍历和广度优先遍历的实现</a></li><li><a href="#question40">分别用深度优先思想和广度优先思想实现一个拷贝函数</a></li><li><a href="#question41">ES5&#x2F;ES6的继承除了写法之外还有什么区别</a></li><li><a href="#question42">setTimeout,Promise,Async&#x2F;Await的区别</a></li><li><a href="#question43">Async&#x2F;Await如何通过同步的方式实现异步</a></li><li><a href="#question44">JS异步解决方案的发展历程以及优缺点</a></li><li><a href="#question45">Promise构造函数是同步执行还是异步执行，then呢</a></li><li><a href="#question46">如何实现一个new</a></li><li><a href="#question47">简单阐述http2的多路复用</a></li><li><a href="#question48">TCP的三次握手和四次挥手</a></li><li><a href="#question49">A，B机器正常连接后，B机器突然重启，A处于TCP什么状态</a></li><li><a href="#question50">react中setState什么时候是同步的，什么时候是异步的</a></li><li><a href="#question51">npm模块安装机制，为什么输入npm install就可以自动安装对应的</a></li><li><a href="#question52">重绘和回流及如何优化</a></li><li><a href="#question53">观察者模式和订阅-发布模式区别，各自适用什么场景</a></li><li><a href="#question54">Redux和Vuex的设计思想</a></li><li><a href="#question55">浏览器和Node事件循环的区别</a></li><li><a href="#question56">介绍模块化发展历程</a></li><li><a href="#question57">全局作用域中，用const和let声明的变量不在window上，那到底在哪</a></li><li><a href="#question58">cookie和token都存放在header中，为什么不会劫持token</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">Js的数据类型有哪些他们的区别是什么</a><ol><li>基本数据类型(存储在内存中<ol><li>String</li><li>Number</li><li>Boolean</li><li>Null</li><li>undefined</li><li>Symbol</li></ol></li><li>引用数据类型（存储的是对象在内存中的地址<ol><li>Object</li><li>Array</li><li>Date</li><li>Function</li></ol></li><li>区别<ol><li>存储方式：基本数据类型直接存储数据值，而引用数据类型存储的是对象的引用</li><li>内存占用：基本数据类型占用固定的内存空间，而引用数据类型的大小取决于对象的大小。</li><li>赋值方式：基本数据类型的赋值是通过将值直接复制给变量，而引用数据类型的赋值是将对象的引用赋给变量。</li><li>传递方式：基本数据类型作为参数传递时，传递的是值的副本，而引用数据类型作为参数传递时，传递的是引用的副本。</li></ol></li></ol></li><li><a id="question2">判断数据类型有几种方法</a><ol><li><strong>typeof</strong><ol><li>其中typeof返回的类型都是字符串形式</li><li>缺点：typeof null的值为Object，无法分辨是null还是Object</li><li><code>alert(typeof &quot;helloworld&quot;)</code></li></ol></li><li><strong>instanceof</strong><ol><li>instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。</li><li><code>[1,2,3] instanceof Array </code></li></ol></li><li><strong>Object.prototype.toString.call</strong><ol><li>（适用于所有类型的判断检测,注意区分大小写. toString方法,在Object原型上返回数据格式,）</li><li><code>console.log(Object.prototype.toString.call(&quot;123&quot;))           --------&gt;[object String]</code></li></ol></li><li><strong>constructor</strong><ol><li>constructor 判断方法跟instanceof相似,但是constructor检测Object与instanceof不一样,constructor还可以处理基本数据类型的检测,不仅仅是对象类型</li><li><code>console.log(A.constructor === B)</code></li></ol></li><li><strong>jquery.type()</strong><ol><li>如果对象是null跟undefined,直接返回”null”和”undefined”,</li><li><code>console.log(jQuery.type(undefined) === &quot;undefined&quot;)           --------&gt;true</code></li></ol></li><li><strong>&#x3D;&#x3D;&#x3D;</strong><ol><li>有局限的判断:严格运算符&#x3D;&#x3D;&#x3D;</li></ol></li><li>总结<ol><li>一般变量用typeof</li><li>已知对象类型用instanceof</li><li>通用方法Object.prototype.toString.call()</li></ol></li></ol></li><li><a id="question3">作用域和作用域链</a><ol><li>作用域：规定变量和函数的可使用范围称作作用域</li><li>作用域链：每个函数都有一个作用域链，查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作作用域链</li></ol></li><li><a id="question4">原型和原型链</a><ol><li>原型：<ol><li>原型分为隐式原型和显式原型，每个对象都有一个隐式原型，它指向自己的构造函数的显式原型</li><li>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法</li></ol></li><li>原型链：<ol><li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li><li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li></ol></li><li>原型和原型链的区别<ol><li>原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法</li></ol></li></ol></li><li><a id="question5">什么是闭包</a><ol><li>JS中内层函数可以访问外层函数的变量，使内部私有变量不受外界干扰，起到保护和保存的作用，我们把这个特性称作闭包。</li><li>好处<ol><li>隔离作用域，保护私有变量；有了闭包才有局部变量，要不然都是全局变量了。</li><li>让我们可以使用回调，操作其他函数内部；</li><li>变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；</li></ol></li><li>坏处<ol><li>内层函数引用外层函数变量，内层函数占用内存。如果不释放内存，过多时，易引起内存泄露</li></ol></li><li>引用场景<ol><li>for循环中的保留i的操作 </li><li>防抖和节流</li></ol></li></ol></li><li><a id="question6">内存泄露、垃圾回收机制</a><ol><li>内存泄露：是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏，内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃。</li><li>垃圾回收机制：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清除或释放内存。（标记清除&#x2F;引用计数）</li></ol></li><li><a id="question7">Js获取dom</a><ol><li>getElementById</li><li>getElementByClassName</li><li>getElementByTagName</li><li>querySelector</li><li>querySelectorAll</li></ol></li><li><a id="question8">浅拷贝与深拷贝</a><ol><li>浅拷贝<ol><li><strong>Object.assign()</strong><ol><li><code>Object.assign(target, ...sources)</code></li></ol></li><li><strong>…</strong><ol><li><code>let objClone = &#123; ...obj &#125;;</code></li></ol></li><li>Array.prototype.<strong>concat</strong>()拷贝数组</li><li>Array.prototype.<strong>slice</strong>()拷贝数组</li><li>手动实现 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">shallowClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span> !== <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">const</span> cloneTarget = Array.isArray(<span class="hljs-keyword">target</span>) ? [] : &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (let prop in <span class="hljs-keyword">target</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span>.hasOwnProperty(prop)) &#123;<br>                cloneTarget[prop] = <span class="hljs-keyword">target</span>[prop];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneTarget;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> shallowCloneObj = shallowClone(obj)<br><br>shallowCloneObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>shallowCloneObj.arr === obj.arr  <span class="hljs-comment">// true，对于对象类型只拷贝了引用</span><br></code></pre></td></tr></table></figure></li></ol></li><li>深拷贝<ol><li><strong>JSON.parse(JSON.stringify(target));</strong></li><li><strong>递归基础版深拷贝</strong> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">deepClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span>) &#123;<br>        let cloneObj = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key in <span class="hljs-keyword">target</span>) &#123; <span class="hljs-comment">// 遍历</span><br>            <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">target</span>[key]<br>            <span class="hljs-keyword">if</span> (typeof val === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; val) &#123;<br>                cloneObj[key] = deepClone(val) <span class="hljs-comment">// 是对象就再次调用该函数递归</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cloneObj[key] = val <span class="hljs-comment">// 基本类型的话直接复制值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneObj<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 开头的测试obj存在循环引用，除去这个条件进行测试</span><br><span class="hljs-keyword">const</span> clonedObj = deepClone(obj)<br><br><span class="hljs-comment">// 测试</span><br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.arr === obj.arr  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br></code></pre></td></tr></table></figure></li><li><strong>递归完美版深拷贝</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">// WeakMap作为记录对象Hash表（用于防止循环引用）</span><br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br>    <span class="hljs-comment">// 判断是否为object类型的辅助函数，减少重复代码</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target ) || <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">data</span>) &#123;<br><br>        <span class="hljs-comment">// 基础类型直接返回值</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(data)) &#123;<br>            <span class="hljs-keyword">return</span> data<br>        &#125;<br><br>        <span class="hljs-comment">// 日期或者正则对象则直接构造一个新的对象返回</span><br>        <span class="hljs-keyword">if</span> ([<span class="hljs-title class_">Date</span>, <span class="hljs-title class_">RegExp</span>].<span class="hljs-title function_">includes</span>(data.<span class="hljs-property">constructor</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> data.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>)<br>        &#125;<br><br>        <span class="hljs-comment">// 处理函数对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + data.<span class="hljs-title function_">toString</span>())()<br>        &#125;<br><br>        <span class="hljs-comment">// 如果该对象已存在，则直接返回该对象</span><br>        <span class="hljs-keyword">const</span> exist = map.<span class="hljs-title function_">get</span>(data)<br>        <span class="hljs-keyword">if</span> (exist) &#123;<br>            <span class="hljs-keyword">return</span> exist<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Map对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：map中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Set对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：set中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">add</span>(val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 收集键名（考虑了以Symbol作为key以及不可枚举的属性）</span><br>        <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(data)<br>        <span class="hljs-comment">// 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性以及对应的属性描述</span><br>        <span class="hljs-keyword">const</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(data)<br>        <span class="hljs-comment">// 结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链， 这里得到的result是对data的浅拷贝</span><br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(data), allDesc)<br><br>        <span class="hljs-comment">// 新对象加入到map中，进行记录</span><br>        map.<span class="hljs-title function_">set</span>(data, result)<br><br>        <span class="hljs-comment">// Object.create()是浅拷贝，所以要判断并递归执行深拷贝</span><br>        keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> val = data[key]<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                <span class="hljs-comment">// 属性值为 对象类型 或 函数对象 的话也需要进行深拷贝</span><br>                result[key] = <span class="hljs-title function_">clone</span>(val)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[key] = val<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">clone</span>(target)<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> clonedObj = <span class="hljs-title function_">deepClone</span>(obj)<br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.<span class="hljs-property">arr</span> === obj.<span class="hljs-property">arr</span>  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br>clonedObj.<span class="hljs-property">func</span> === obj.<span class="hljs-property">func</span>  <span class="hljs-comment">// false，说明function也复制了一份</span><br>clonedObj.<span class="hljs-property">proto</span>  <span class="hljs-comment">// proto，可以取到原型的属性</span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><a id="question9">route和router的区别详解</a><ol><li>router是用来操作路由的</li><li>route是用来获取路由信息的。 $route.path $route.params route.query等</li></ol></li><li><a id="question10">如何改变this指向（call、apply与bind区别）</a><ol><li>call、bind、apply 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法。</li><li>传参 call、bind可以传递无数个参数，apply只有两个参数，第二个参数为数组</li><li>返回 call和apply方法是直接调用函数并改变函数上下文，而bind方法则是返回一个新函数，稍后调用时绑定指定的上下文。</li></ol></li><li><a id="question11">箭头函数和普通函数的区别</a><ol><li>箭头函数是普通函数的简写，但是它不具备很多普通函数的特性</li><li>箭头函数都是匿名函数</li><li>箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply();普通函数的this指向调用它的那个对象</li><li>没有arguments对象，不能使用arguments,取而代之用rest参数…解决</li><li>不会进行函数提升</li><li>箭头函数不能用于构造函数，不能使用new</li></ol></li><li><a id="question12">浏览器存储，他们的区别？</a><ol><li>localStorage：永久保存，以键值对保存，存储空间5M</li><li>sessionStorage：关闭页签&#x2F;浏览器时清空</li><li>cookie：随着请求发送，通过设置过期时间删除</li><li>session：保存在服务端</li><li>ocalStorage&#x2F;sessionStorage是window的属性，cookie是document的方法</li></ol></li><li><a id="question13">继承方式有哪些</a><ol><li><strong>原型链继承</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>());<br></code></pre></td></tr></table></figure></li><li>因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</li></ol></li><li><strong>构造函数继承（借助 call）</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title class_">Parent1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child1&#x27;</span><br>&#125;<br>         <br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child);  <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure></li><li>它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</li></ol></li><li><strong>组合继承（前两种组合）</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span> () &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>         <br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第二次调用 Parent3()</span><br>  <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span>;<br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>);  <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><strong>原型式继承</strong><ol><li>ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let parent4 = &#123;<br>  <span class="hljs-type">name</span>: &quot;parent4&quot;,<br>  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],<br>  getName: <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">return</span> this.name;<br>  &#125;<br>&#125;;<br>         <br>let person4 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person4.name = &quot;tom&quot;;<br>person4.friends.push(&quot;jerry&quot;);<br>let person5 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person5.friends.push(&quot;lucy&quot;);<br>         <br>console.log(person4.name);<br>console.log(person4.name === person4.getName());<br>console.log(person5.name);<br>console.log(person4.friends);<br>console.log(person5.friends);<br></code></pre></td></tr></table></figure></li><li>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能</li></ol></li><li><strong>寄生式继承</strong><ol><li>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> parent5 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent5&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original);<br>  clone.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person5 = <span class="hljs-title function_">clone</span>(parent5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li></ol></li><li><strong>寄生组合式继承</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (parent, child) &#123;<br>  <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br> <span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>);<br>         <br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li><li>结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式</li></ol></li><li>ES6 的 extends 关键字实现逻辑<ol><li>code <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>  &#125;<br>  <span class="hljs-comment">// 原型方法</span><br>  <span class="hljs-comment">// 即 Person.prototype.getName = function() &#123; &#125;</span><br>  <span class="hljs-comment">// 下面可以简写为 getName() &#123;...&#125;</span><br>  getName = function () &#123;<br>    console.log(&#x27;<span class="hljs-type">Person</span>:&#x27;, <span class="hljs-keyword">this</span>.name)<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gamer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name, age) &#123;<br>    <span class="hljs-comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-keyword">super</span>(name)<br>    <span class="hljs-keyword">this</span>.age = age<br>  &#125;<br>&#125;<br> <br>const asuna = <span class="hljs-keyword">new</span> <span class="hljs-type">Gamer</span>(&#x27;<span class="hljs-type">Asuna</span>&#x27;, <span class="hljs-number">20</span>)<br>asuna.getName() <span class="hljs-comment">// 成功访问到父类的方法</span><br></code></pre></td></tr></table></figure></li><li>通过编译解码可以发现，extends内步也是采用的寄生组合继承方式。</li></ol></li></ol></li><li><a id="question14">常用的数组方法有哪些？</a><ol><li>改变原数组<ol><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>sort</li><li>splice</li><li>reverse</li></ol></li><li>不改变原数组<ol><li>concat</li><li>join</li><li>map</li><li>forEach</li><li>filter</li><li>slice</li></ol></li></ol></li><li><a id="question15">什么是Promise</a><ol><li>Promise异步编程的一种解决方案。Promise是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br><span class="hljs-comment">//做一些异步操作</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行完成Promise&#x27;</span>);<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>Promise对象有三种状态，他们分别是 pending（等待中） resolved（已完成）rejected（拒绝）</li><li>Promise.all哪怕一个请求失败了也能得到其余正确的请求结果的解决方案</li><li>promise 的then会返回一个新的 promise 对象，能保证 then 方 可以进行链式调用</li></ol></li><li><a id="question16">async、await</a><ol><li>Async 和 await 是一种同步的写法，但还是异步的操作，两个必须配合一起使用</li><li>函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西，如果是promise则会等待promaise 返回结果，接普通函数直接进行链式调用</li><li>如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错，await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行</li><li>async&#x2F;await 的优势在于处理 then 链;单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</li></ol></li><li><a id="question17">宏任务和微任务有哪些？执行顺序</a><ol><li>宏任务<ol><li>script</li><li>setTimeout</li><li>setInterval</li></ol></li><li>微任务<ol><li>Promise</li><li>process.nextTick</li></ol></li><li>微任务会优先于宏任务执行。这意味着在当前任务执行结束后，所有微任务都会被立即执行，而宏任务只有在所有微任务执行完毕后才会执行。</li></ol></li><li><a id="question18">var  let  const的区别</a><ol><li>var声明的变量存在变量提升，即变量可以在声明之前调用，var允许重复声明变量var不存在块级作用域</li><li>let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</li><li>let和const存在块级作用域</li><li>let和const在同一作用域不允许重复声明变量</li><li>const声明的是常量，常量不可以修改</li><li>const变量不能修改指针，但是可以修改值，比如我们定义一个对象，我们就可以修改对象里的属性值，但是不可以重写整个对象。</li></ol></li><li><a id="question19">ES6新特性</a><ol><li>模版字符串</li><li>箭头函数</li><li>拓展运算符</li><li>map和set</li><li>promise和proxy</li><li>数组方法from,map,filter,forEach,some,every</li><li>等等</li></ol></li><li><a id="question20">从浏览器输入url后都经历了什么</a><ol><li>浏览器输入域名</li><li>浏览器查找域名的ip地址<ol><li>查找浏览器缓存</li><li>查找系统缓存</li><li>查找路由缓存</li><li>递归查询</li><li>迭代查询</li></ol></li><li>浏览器与目标服务器建立tcp连接<ol><li>三次握手</li></ol></li><li>浏览器通过http协议发送请求</li><li>某些服务器会做永久重定向响应</li><li>浏览器跟踪重定向地址</li><li>服务器处理请求</li><li>服务器发出一个HTML响应</li><li>释放tcp连接<ol><li>四次挥手</li></ol></li><li>浏览器显示页面</li><li>浏览器发送获取嵌入在html中的其他内容</li></ol></li><li><a id="question21">TCP协议和HTTP 协议</a><ol><li>TCP协议在建立过程中会进行三次握手四次挥手，三次握手确保双方同步并避免无效连接，四次挥手则正常终止连接或异常终止连接。</li><li>HTTP协议是超文本传输协议（Hyper Text Transfer Protocol），是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的。</li></ol></li><li><a id="question22">HTTP与HTTPS有什么区别</a><ol><li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</li></ol></li><li><a id="question23">如何解决前端跨域问题</a><ol><li>jsonp</li><li>CORS</li><li>postMessage</li><li>document.domain</li><li>window.name</li><li>location.hash</li><li>http-proxy</li><li>nginx代理</li><li>nodejs中间件代理</li><li>WebSocket协议跨域<ol><li>webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信。</li></ol></li></ol></li><li><a id="question24">WebSocket和webwork</a><ol><li>WebSocket作用是即使通信双向通信，webwork是多进程的</li><li><a href="https://blog.csdn.net/zxc123401/article/details/131491466">资料详解</a></li></ol></li><li><a id="question25">性能优化</a><ol><li>异步组件：对于较大的组件，可以使用异步组件进行延迟加载，提高页面加载速度。</li><li>列表性能优化：对于大数据列表，使用虚拟滚动或分页加载来减少渲染的数据量。</li><li>图片优化：使用适当的图片压缩和懒加载，并提供多种分辨率的图片，以避免不必要的网络负载。</li><li>组件懒加载：将页面按需加载，只加载当前视图所需的组件，减少首次加载的体积和渲染时间。</li><li>减少重绘和回流：合理使用CSS样式，避免频繁的DOM操作，以减少页面的重绘和回流。</li><li>接口过慢：后端优化接口，分段式请求接口，对加载过慢的接口做过度动画提升用户体验。</li><li>使用浏览器缓存：在合适的情况下，使用浏览器缓存可以显著减少请求时间，提高页面加载速度。</li></ol></li><li><a id="question26">Webpack是什么</a><ol><li>Webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。</li><li>它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。</li><li>对于不同类型的依赖，Webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</li></ol></li><li><a id="question27">Webpack的基本功能？</a><ol><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li><li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li><li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ol></li><li><a id="question28">盒模型和怪异盒模型</a><ol><li>标准盒模型总宽度&#x3D;**width+margin(左右)+padding(左右)border(左右)**。box-sizing:<strong>centent-box</strong></li><li>怪异盒模型的总宽度&#x3D;width+margin(左右)( width已经包含了padding和border值)。box-sizing:<strong>border-box</strong></li></ol></li><li><a id="question29">让一个元素水平&#x2F;垂直居中</a><ol><li>父、子元素宽高未知时<ol><li><strong>table-cell</strong>（使用表格样式）</li><li><strong>flex</strong> 布局（父级 justify-content: center 和 align-items: center 即可）</li><li><strong>absolute + transform</strong>（定位的上、左为 50%，translate 上、左负 50%）</li><li><strong>absolute + margin: auto</strong>（定位的上下左右为 0）</li><li><strong>Grid</strong> 网格布局</li><li>直接使用 <strong>table</strong>（改变结构实现，和第一条类似）</li></ol></li><li>子元素固定宽高已知时（假设子元素宽高为 200px）<ol><li><strong>absolute + calc</strong>（定位上、左负50%时减去子元素宽、高）</li><li><strong>absolute + 负margin</strong>（定位的上、左为 50%，margin 的上、左负子元素的一半）</li></ol></li><li>父元素高度已知（假设为 400px），子元素宽高未知<ol><li><strong>text-align + vertical-align</strong></li></ol></li></ol></li><li><a id="question30">flex:1 到底代表什么 </a><ol><li>是一个简写方式，相当于同时设置了 <code>flex-grow: 1</code>、<code>flex-shrink: 1</code>、<code>flex-basis: 0</code> 这三个属性。满足项目的自适应需求。</li></ol></li><li><a id="question31">回溯算法</a><ol><li>数组arr[1,2,3] 输出结果[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]</li><li>定义一个空数组res，用于存储所有的排列结果。</li><li>定义一个空数组path，用于存储当前的排列结果。</li><li>编写回溯函数backtrack，函数参数为当前的排列结果path和可选的数字列表nums。</li><li>如果nums为空，说明已经选完了所有的数字，将path加入到res中。</li><li>遍历nums中的每个数字，将其加入到path中，然后从nums中删除该数字，递归调用backtrack函数。</li><li>递归结束后，将path中的最后一个数字删除，将该数字加入到nums中，回溯到上一层。</li><li>调用backtrack函数，开始全排列。</li><li>code<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">def permute(nums):<br>    <span class="hljs-keyword">res</span> = []<br>    path = []<br>    def backtrack(path, nums):<br>        <span class="hljs-keyword">if</span> not nums:<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            path.<span class="hljs-keyword">append</span>(nums[i])<br>            backtrack(path, nums[:i]+nums[i+<span class="hljs-number">1</span>:])<br>            path.<span class="hljs-keyword">pop</span>()<br>    backtrack(path, nums)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br> <br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">res</span> = permute(arr)<br><span class="hljs-keyword">for</span> r in <span class="hljs-keyword">res</span>:<br>    <span class="hljs-keyword">print</span>(r)<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question32">冒泡算法排序</a><ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-comment">/* 1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。</span><br><span class="hljs-comment">    　　　2.第一轮的时候最后一个元素应该是最大的一个。</span><br><span class="hljs-comment">    　　　3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> temp = arr[j]<br>        arr[j] = arr[j + <span class="hljs-number">1</span>]<br>        arr[j + <span class="hljs-number">1</span>] = temp<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>     <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br>bubbleSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question33">快速排序</a><ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/*</span><br><span class="hljs-comment">快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。</span><br><span class="hljs-comment">然后递归调用，在两边都实行快速排序。  </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr<br>  &#125;<br>  <span class="hljs-keyword">var</span> middle = Math.<span class="hljs-built_in">floor</span>(arr.<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">var</span> middleData = arr.<span class="hljs-built_in">splice</span>(middle, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br> <br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">left</span> = []<br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">right</span> = []<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; middleData) &#123;<br>      <span class="hljs-built_in">left</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">right</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> quickSort(<span class="hljs-built_in">left</span>).concat([middleData], quickSort(<span class="hljs-built_in">right</span>))<br>&#125;<br> <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br><span class="hljs-keyword">var</span> newArr = quickSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question34">什么是MVVM，MVC模型</a><ol><li>M V C:Model View Controller<ol><li>Controller负责将Model的数据用View显示出来。</li></ol></li><li>M V VM 视图模型双向绑定<ol><li>Model，View，ViewModel</li><li>Model 和 View 并无直接关联，而是通过 ViewModel 来进行交互的（即双向数据绑定），</li><li>View的变化可以引起Model的变化，Model的变化也可以引起View变化（类似于浅拷贝）。ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</li><li>使用：react vue</li></ol></li></ol></li><li><a id="question35">写React &#x2F; Vue项目时为什么要在列表组件中写key，其作用是什么?</a><ol><li>key是给每一个vnode的唯一id,可以依靠key,更准确,更快的拿到oldVnode中对应的vnode节点</li></ol></li><li><a id="question36">[‘1’, ‘2’, ‘3’].map(parseInt)</a><ol><li><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map((value, index) =&gt; &#123;  parseInt(value, index);&#125;);</code></li><li>相当于执行<ol><li>parseInt(‘1’, 0) &#x2F;&#x2F; radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。返回1</li><li>parseInt(‘2’, 1) &#x2F;&#x2F; 基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li><li>parseInt(‘3’, 2) &#x2F;&#x2F; 基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</li></ol></li><li>结果：<code>[1, NaN, NaN]</code></li></ol></li><li><a id="question37">什么是防抖和节流?有什么区别?如何实现?</a><ol><li>防抖<ol><li>所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</li></ol></li><li>节流<ol><li>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。</li></ol></li><li><strong>防抖就是回城，节流就是放技能</strong></li></ol></li><li><a id="question38">介绍下Set、 Map. WeakSet 和WeakMap的区别?</a><a href="https://juejin.cn/post/6981747653323276319">详解</a><ol><li>Set<ol><li>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</li><li>Set 本身是一种构造函数，用来生成 Set 数据结构。</li><li>Set 实例属性<ol><li>constructor： 构造函数</li><li>size：元素数量</li></ol></li><li>Set 实例方法<ol><li>操作方法<ol><li>add(value)：新增，相当于 array里的push</li><li>delete(value)：存在即删除集合中value</li><li>has(value)：判断集合中是否存在 value</li><li>clear()：清空集合</li></ol></li><li>遍历方法（遍历顺序为插入顺序）<ol><li>keys()：返回一个包含集合中所有键的迭代器</li><li>values()：返回一个包含集合中所有值得迭代器</li><li>entries()：返回一个包含Set对象中所有元素得键值对迭代器</li><li>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值</li><li>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致</li></ol></li></ol></li><li>Array.from 方法可以将 Set 结构转为数组</li></ol></li><li>WeakSet<ol><li>WeakSet 结构与 Set 类似，也是不重复的值的集合。 WeakSet 对象允许你将弱引用对象储存在一个集合中。</li><li>WeakSet 与 Set 的区别<ol><li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li><li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li><li>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数。</li></ol></li><li>WeakSet方法<ol><li>add(value)：在WeakSet 对象中添加一个元素value</li><li>has(value)：判断 WeakSet 对象中是否包含value</li><li>delete(value)：删除元素 value</li><li>clear()：注意该方法已废弃, WeakSet没这个方法</li></ol></li></ol></li><li>Map<ol><li>Map诞生原因:<ol><li>为了解决对象只能用字符串当作键的问题。</li><li>ES6 提供了 Map 数据结构，类似于对象，也是键值对的集合，但是 “键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</li></ol></li><li>Map的属性和方法<ol><li>size属性返回 Map 结构的成员总数。</li><li>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<ol><li>set方法返回的是当前的Map对象，因此可以采用链式写法。</li><li><code>let map = new Map().set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;);</code></li><li>如果对同一个键多次赋值，后面的值将覆盖前面的值:</li></ol></li><li>get方法读取key对应的键值，如果找不到key，返回undefined。</li><li>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li>delete方法删除某个键，返回true。如果删除失败，返回false。</li><li>clear方法清除所有成员，没有返回值。</li></ol></li><li>注意<ol><li>数组做参数<ol><li>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</li></ol></li><li>Map 的键实际上是跟内存地址绑定的<ol><li>如果读取一个未知的键，则返回undefined</li><li>只有对同一个对象的引用，Map 结构才将其视为同一个键</li></ol></li></ol></li><li>Map遍历方法<ol><li>Map.prototype.keys()：返回键名的遍历器。</li><li>Map.prototype.values()：返回键值的遍历器。</li><li>Map.prototype.entries()：返回所有成员的遍历器。</li><li>Map.prototype.forEach()：遍历 Map 的所有成员。</li></ol></li><li>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）</li></ol></li><li>WeakMap<ol><li>WeakMap结构与Map结构类似，也是用于生成键值对的集合</li><li>WeakMap与Map的区别<ol><li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li></ol></li><li>WeakMap 的语法<ol><li>没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性</li><li>无法清空，即不支持clear方法</li><li>WeakMap只有四个方法可用：get()、set()、has()、delete()。</li></ol></li><li>WeakMap 的用途<ol><li>WeakMap 应用的典型场合就是 DOM 节点作为键名。</li></ol></li></ol></li></ol></li><li><a id="question39">介绍下深度优先遍历和广度优先遍历，如何实现?</a><ol><li>深度优先遍历：是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止。</li><li>广度优先遍历：是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。</li></ol></li><li><a id="question40">请分别用深度优先思想和广度优先思想实现一个拷贝函数?</a><ol><li><a href="https://blog.csdn.net/qq_46299172/article/details/108545861">address</a></li><li>深度优先的深拷贝 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">DFSdeepClone</span> = (<span class="hljs-params">obj, visitedArr = []</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> _obj = &#123;&#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) || <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;object&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">let</span> index = visitedArr.<span class="hljs-title function_">indexOf</span>(obj)<br>    _obj = <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) ? [] : &#123;&#125;<br>    <span class="hljs-keyword">if</span> (~index) &#123; <span class="hljs-comment">// 判断环状数据 ~-1 == 0 一个骚操作而已</span><br>      _obj = visitedArr[index]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      visitedArr.<span class="hljs-title function_">push</span>(obj)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>        _obj[item] = <span class="hljs-title class_">DFSdeepClone</span>(obj[item], visitedArr)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    _obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#x27;</span> + obj.<span class="hljs-title function_">toString</span>() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _obj = obj<br>  &#125;<br>  <span class="hljs-keyword">return</span> _obj<br>&#125;<br></code></pre></td></tr></table></figure></li><li>广度优先的拷贝 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> BFSdeepClone = (obj) =&gt; &#123;<br><span class="hljs-built_in">let</span> <span class="hljs-built_in">origin</span> = [obj],<br>  copyObj = &#123;&#125;,<br>  <span class="hljs-built_in">copy</span> = [copyObj]<br>  // 去除环状数据<br><span class="hljs-built_in">let</span> visitedQueue = [],<br>  visitedCopyQueue = []<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">origin</span>.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">let</span> items = <span class="hljs-built_in">origin</span>.shift(),<br>    _obj = <span class="hljs-built_in">copy</span>.shift()<br>  visitedQueue.<span class="hljs-built_in">push</span>(items)<br>  <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;object&#x27;) || isTypeOf(items, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item <span class="hljs-keyword">in</span> items) &#123;<br>      <span class="hljs-built_in">let</span> val = items[item]<br>      <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;object&#x27;)) &#123;<br>        <span class="hljs-built_in">let</span> index = visitedQueue.indexOf(val)<br>        <span class="hljs-keyword">if</span> (!~index) &#123;<br>          _obj[item] = &#123;&#125;<br>            //下次<span class="hljs-keyword">while</span>循环使用给空对象提供数据<br>          <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>            // 推入引用对象<br>          <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          _obj[item] = visitedCopyQueue[index]<br>          visitedQueue.<span class="hljs-built_in">push</span>(_obj)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>        // 数组类型在这里创建了一个空数组<br>        _obj[item] = []<br>        <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>        <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;function&#x27;)) &#123;<br>        _obj[item] = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + val.toString() + &#x27;)&#x27;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        _obj[item] = val<br>      &#125;<br>    &#125;<br>    // 将已经处理过的对象数据推入数组 给环状数据使用<br>    visitedCopyQueue.<span class="hljs-built_in">push</span>(_obj)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;function&#x27;)) &#123;<br>    copyObj = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + items.toString() + &#x27;)&#x27;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    copyObj = obj<br>  &#125;<br>&#125;<br>  <span class="hljs-built_in">return</span> copyObj<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question41">ES5&#x2F;ES6的继承除了写法以外还有什么区别?</a><ol><li>ES5的继承：<ol><li>先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）；</li><li>通过原型或构造函数机制来实现；</li></ol></li><li>ES6的继承：<ol><li>先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</li><li>通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承<ol><li>子类必须在constructor方法中调用super方法，否则新建实例报错。因 为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。</li><li>注意 super 关键字指代父类的实例，即父类的 this 对象</li><li>注意 在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错</li></ol></li></ol></li></ol></li><li><a id="question42">setTimeout、Promise、 Async&#x2F;Await的区别</a><ol><li>setTimeout属性宏任务，Promise里面的then方法属于微任务，Async&#x2F;Await中await语法后面紧跟的表达式是同步的，但接下来的代码是异步的，属于微任务。</li><li>setTimeout<ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br>   setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>   &#125;, <span class="hljs-number">0</span>);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>输出script start -&gt; script end -&gt; set</li></ol></li><li>Promise：<ol><li>Promise本身是同步的，但在执行resolve或者rejects时是异步的，即then方法是异步的。</li><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br> let promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>     resolve();<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1 end&quot;</span>);<br> &#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br> &#125;)<br>        <br> setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br> &#125;, <span class="hljs-number">0</span>)<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>输出顺序： script start -&gt; promise1 -&gt; promise1 end -&gt; script end -&gt; promise2 -&gt;setTimeout</li></ol></li><li>async&#x2F;await<ol><li>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</li><li>await后面跟一个表达式，async方法执行时，遇到await后会立即执行表达式，然后把表达式后边的代码放到微任务队列中，让出执行栈让同步代码先执行；</li><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>await async2();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>输出顺序：script start -&gt; async1 start -&gt; async2 -&gt; script end -&gt; async1 end</li></ol></li></ol></li><li><a id="question43">Async&#x2F;Await如何通过同步的方式实现异步</a><ol><li>Async 和 Await 都是异步编程的关键字。</li><li>在 Async 函数内部使用 await 关键字来等待异步操作完成。await 表示等待异步操作返回结果后再继续执行后续的代码。</li><li>Async&#x2F;Await 是如何通过同步的方式实现异步的呢？答案就是 Generator 函数和 Promise。</li><li>Generator 函数是一种特殊的函数，它可以被暂停和恢复执行。在 Generator 函数中，我们可以使用 yield 关键字将控制权交给调用方，并在下次调用时从上次暂停的位置继续执行。这种特性可以用来实现异步操作。</li><li>Promise 是 ES6 引入的另一种异步编程技术。Promise 对象表示一个尚未完成或失败的操作，它可以被异步执行，并返回一个代表操作结果的值。</li><li>Async 函数实际上是一种特殊的 Generator 函数，它使用 yield 关键字暂停执行，并在异步操作完成后，通过调用 next 方法恢复执行。这个过程中，Async 函数内部创建了一个 Promise 对象，并将该 Promise 对象返回给调用方。</li><li>使用 Async&#x2F;Await 可以避免回调地狱和 Promise 层层嵌套的问题。</li></ol></li><li><a id="question44">JS异步解决方案的发展历程以及优缺点</a><ol><li>回调函数（callback）</li><li>Promise</li><li>Generator</li><li>Async&#x2F;await</li></ol></li><li><a id="question45">Promise构造函数是同步执行还是异步执行，那么then方法呢?</a><ol><li>promise构造函数是同步执行的，then方法是异步执行的</li></ol></li><li><a id="question46">如何实现一个new</a><ol><li>创建一个空的简单 JavaScript 对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；（ 通俗理解就是新对象隐式原型__proto__链接到构造函数显式原型prototype上。）</li><li>将步骤 1 新创建的对象作为 this 的上下文；（ 实际是执行了构造函数 并将构造函数作用域指向新对象 ）</li><li>如果该函数没有返回对象，则返回 this。（ 实际是返回一个空对象， new Object()就是返回一个空对象{} ）</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">constructor, ...arg</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 对应于上面的步骤 1</span><br>  obj.<span class="hljs-property">__proto__</span> = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 对应于上面的步骤 2</span><br><br>  <span class="hljs-keyword">var</span> res = constructor.<span class="hljs-title function_">apply</span>(obj, arg); <span class="hljs-comment">// 对应于上面的步骤 3</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(res) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ? res : obj; <span class="hljs-comment">// 对应于上面的步骤 4</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Fun</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">_new</span>(<span class="hljs-title class_">Fun</span>, <span class="hljs-string">&#x27;小明&#x27;</span>));<br><br><span class="hljs-comment">// Fun &#123;name: &quot;小明&quot;&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question47">简单讲解一下http2的多路复用</a><ol><li>在 HTTP&#x2F;2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</li><li>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。</li><li>多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</li></ol></li><li><a id="question48">谈谈你对TCP三次握手和四次挥手</a><ol><li>TCP协议？<ol><li>TCP( Transmission control protocol )即传输控制协议，是一种面向连接、可靠的数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。<ol><li>面向连接：数据传输之前客户端和服务器端必须建立连接</li><li>可靠的：数据传输是有序的 要对数据进行校验</li></ol></li></ol></li><li>TCP三次握手<ol><li>为了保证客户端和服务器端的可靠连接，TCP建立连接时必须要进行三次会话，也叫TCP三次握手，进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。<ol><li>我打给你 问你能听到吗</li><li>你说你能听到 问我能听到吗</li><li>我说我能听到 开始交流吧</li></ol></li></ol></li><li>TCP四次挥手（我客户端 你服务端）<ol><li>我告诉你 我要关闭了</li><li>你说 好吧 你关闭吧</li><li>你再说 那我也关闭了？</li><li>我说 行你也关吧</li></ol></li></ol></li><li><a id="question49">A、B机器正常连接后，B机器突然重启，问A此时处于TCP什么状态</a><ol><li>等待 超时 抛出异常</li></ol></li><li><a id="question50">React中setState什么时候是同步的，什么时候是异步的?</a><ol><li><ul><li><ol><li>由 React 控制的事件处理程序，以及生命周期函数调用 setState 不会同步更新 state 。</li><li>React 控制之外的事件中调用 setState 是同步更新的。比如原生 js 绑定的事件，setTimeout&#x2F;setInterval 等。</li></ol></li></ul></li><li>在合成事件 和 生命周期钩子(除componentDidUpdate) 中，setState是”异步”的；</li><li>在 原生事件 和setTimeout 中，setState是同步的，可以马上获取更新后的值；</li><li>批量更新：多个顺序的setState不是同步地一个一个执行，会一个一个加入队列，然后最后一起执行。在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新。</li><li>函数式： setState第一个参数为函数形式时，在这个函数中可以回调拿到最新的state对象，然后函数return出的对象将被设置成newState。<code>this.setState((state, props) =&gt; newState)</code></li></ol></li><li><a id="question51">介绍下npm模块安装机制，为什么输入npm install就可以自动安装对应的</a><ol><li>npm 模块安装机制：<ol><li>发出npm install命令</li><li>查询node_modules目录之中是否已经存在指定模块<ol><li>若存在，不再重新安装</li><li>若不存在<ol><li>npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的.npm目录里</li><li>解压压缩包到当前项目的node_modules目录</li></ol></li></ol></li></ol></li><li>npm 实现原理<ol><li>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）<ol><li>执行工程自身 preinstall</li><li>确定首层依赖模块</li><li>获取模块<ol><li>获取模块是一个递归的过程，分为以下几步<ol><li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li><li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li><li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li></ol></li></ol></li><li>模块扁平化（dedupe）</li><li>安装模块<ol><li>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</li></ol></li><li>执行工程自身生命周期<ol><li>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</li></ol></li><li>生成或更新版本描述文件，npm install 过程完成。</li></ol></li></ol></li></ol></li><li><a id="question52">重绘和回流(Repaint &amp; Reflow)，以及如何进行优化</a><ol><li>重绘<ol><li>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</li></ol></li><li>回流<ol><li>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</li></ol></li><li>回流必定会发生重绘，重绘不一定会引发回流。</li><li>下列属性都会强制渲染刷新队列<ol><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ol></li><li><a href="https://www.cnblogs.com/zjknb/p/13974879.html">减少重绘与回流</a></li></ol></li><li><a id="question53">介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</a><ol><li>观察者模式里，只有两个角色 —— 观察者(Observer) + 被观察者(Subject || Observable)</li><li>发布订阅模式里，却不仅仅只有发布者(Publisher)和订阅者(Subscriber)两个角色，还有一个经常被我们忽略的 —— 经纪人Broker<br> 1. </li><li>使用：<ol><li>观察者模式，多用于单个应用内部</li><li>发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件</li></ol></li></ol></li><li><a id="question54">聊聊 Redux 和Vuex的设计思想</a><ol><li>不管是 Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。</li><li>Redux 和 Vuex 的设计思想都是为了让应用程序的状态变得更加可控、可预测和易于维护。通过使用单一数据源、状态只读、组件解耦、动态更新和中心化管理等技术手段，这两个库可以实现复杂应用程序的状态管理，并提高代码的可重用性和可扩展性。</li></ol></li><li><a id="question55">说说浏览器和Node事件循环的区别</a><ol><li>执行环境不同：浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，而Node.js中的事件循环是运行在单独的的线程中。因此，在浏览器中，事件循环跟渲染进程共享同一个线程，可能会出现线程阻塞。</li><li>宏任务和微任务的实现方式不同<ol><li>在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。 常见的宏任务包括：setTimeout, setInterval, DOM事件等，常见的微任务包括：Promise.then, MutationObserve等。</li><li>在Node.js中，宏任务和微任务的实现方式有所不同。Node.js使用libuv库提供的事件循环机制来管理宏任务，而使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。当当前阶段的所有任务执行完毕后，才会执行process.nextTick()的为任务队列。</li></ol></li><li>在处理 I&#x2F;O 操作和定时器方面有些许不同<ol><li>Node.js 中采用异步 I&#x2F;O 和非阻塞 I&#x2F;O，可以提供更高效的事件循环机制。而浏览器中，大多数的 I&#x2F;O 操作都是通过 Web APIs 实现的，这些 API 通常是基于异步回调函数实现的。在处理定时器方面，Node.js 提供了 setImmediate() 方法来代替 setTimeout() 函数，在性能上有所提升。</li></ol></li></ol></li><li><a id="question56">介绍模块化发展历程</a><ol><li>文件划分方式</li><li>命名空间方式</li><li>立即执行函数 IIFE 方式<ol><li>具体做法，就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象（window）上的方式实现。</li></ol></li><li>利用自执行函数参数作为依赖声明使用<ol><li>具体做法就是在第3阶段的基础上，利用立即执行函数的参数传递模块依赖项。这样就使得每个模块之间的关系变得更加明显了。</li></ol></li><li>模块化规范的出现 <ol><li>CommonJS 规范<ol><li>一个文件就是一个模块</li><li>每个模块都有单独的作用域</li><li>通过 module.exports 导出成员</li><li>通过 require 函数载入模块</li></ol></li><li>AMD 规范与 Require.js</li><li>CMD 规范与 Sea.js</li></ol></li><li>模块化标准规范</li><li>总的来说，前端模块化，目前算是统一成了 CommonJS 和 ES Modules 这两个规范</li></ol></li><li><a id="question57">全局作用域中，用const 和let声明的变量不在window 上，那到底在哪</a><ol><li>在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中。那要怎么获取呢？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象Window，那就不加 window（global），直接访问即可。</li></ol></li><li><a id="question58">cookie和 token 都存放在header中，为什么不会劫持token?</a><ol><li>因为传统的cookie保存的session id，服务器会根据这个session id，确保服务器与客户端对话；这是的cookie是有状态的，意味着验证记录或者会话需要一直在服务端和客户端保持。而token是无状态的，服务器不记录哪些用户登录了或者哪些 JWT 被发布了，只判断token是否有效，通常我们都会给token设置有效时间，来确保不被劫持。所有劫持cookie比劫持token，更有效，毕竟cookie在某种情况下可以一直使用下去，而token不行。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React-个人学习归纳</title>
    <link href="/2024/01/23/reactStart/"/>
    <url>/2024/01/23/reactStart/</url>
    
    <content type="html"><![CDATA[<ol><li><h4 id="项目创建及目录结构"><a href="#项目创建及目录结构" class="headerlink" title="项目创建及目录结构"></a>项目创建及目录结构</h4><ol><li>使用官方的脚手架<ol><li>通过npx create-react-app <projectname>能创建一个最基本的react项目)</li><li><strong>只做了react基本的搭建和构建，没有配上任何路由和状态管理。项目使用webpack构建</strong></li><li>上面安装如果失败，尝试下方方法：<ol><li>全局安装create-react-app <code>npm install -g create-react-app</code></li><li>创建一个名为 my-react的项目<code>create-react-app my-react</code></li><li><a href="https://blog.csdn.net/m0_47670683/article/details/124413133">create-react-app报错的解决方法</a></li></ol></li></ol></li><li>使用市场上集成脚手架<ol><li>官方脚手架提供的项目模板非常简单，因此也有很多集成的脚手架</li><li>典型的比如umi。这一类脚手架创建出来的项目会集成好很多功能，比如路由，mock</li></ol></li><li>两个核心库<ol><li>react react核心库，提供react的各个功能</li><li>React-dom 提供一些dom操作方法 用于把react创建出来的react对象挂载到真正的htmldom中，或者从htmldom中卸载。核心作用类似于vue中的mount。</li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><br><span class="hljs-comment">// React.StrictMode 开启严格模式</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">// 卸载(2s后页面清除)</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  root.<span class="hljs-title function_">unmount</span>();<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="组件中的jsx"><a href="#组件中的jsx" class="headerlink" title="组件中的jsx"></a>组件中的jsx</h4><ol><li>组件<ol><li>组件化开发，定义一个基本组件的必要条件：<ol><li><strong>组件html模板</strong></li><li><strong>数据和方法</strong></li></ol></li><li>react实现(函数组件及class组件)；由此思考为什么可以在js中直接如此返回？由此引申出jsx。<strong>组件首字母一定要大写</strong>，这是因为当React解析JSX代码时，如果遇到以小写字母开头的标签，它将被视为HTML标签或React内置组件。而如果遇到以大写字母开头的标签，React将其视为自定义组件。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数组件-新版本写法 </span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">FnHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>  <span class="hljs-comment">// class组件-老版本写法</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>helloClass<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloClass</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HelloClass</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li>jsx的特点<ol><li>直接js中混用（js文件后缀直接修改为jsx也是可以的）<ol><li>react项目利用babel做了对js的编译，所以是可以在js里写jsx的</li></ol></li><li>写法接近js，jsx几乎和js一样，不同点在于，可以更方便的写html在js里，写在js里的html最后会被编译成一个js对象，也可以用react自带createElement创建这个对象</li><li><strong>jsx和react是相互独立的。react可以用自带createElement创建这个对象，和jsx创建的dom是一模一样的</strong>。 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fnreactdom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>,[],<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-comment">// 元素，属性，内容</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>jsx里面渲染不同内容的区别<table><thead><tr><th>内容</th><th>渲染</th></tr></thead><tbody><tr><td>字符串、数字</td><td>直接渲染</td></tr><tr><td>方法</td><td>无法渲染</td></tr><tr><td>对象</td><td>只能渲染element对象</td></tr><tr><td>布尔值</td><td>不渲染任何内容</td></tr><tr><td>数组</td><td>把数组里的每一项单独渲染</td></tr><tr><td>Undefine、null</td><td>不渲染任何内容</td></tr><tr><td>表达式</td><td>运行表达式</td></tr></tbody></table> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FnHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">FnHello</span>();<br><span class="hljs-keyword">let</span> com1 = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span>;<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;obj&#125;</span><br><span class="language-xml">    &#123;com1&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HelloClass</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HelloClass</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ol><li>规则模式<ol><li>类似于原生 on+方法名（首字母大写）</li><li>一定要赋值给事件一个方法 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(1);</span><br><span class="language-xml">      &#125;&#125;&gt;匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1&#125;</span>&gt;</span>dianji<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>特别注意问题：<ol><li>不做处理的情况下，this会指向undefined<ol><li>改变this指向：<ol><li>bind</li><li>匿名箭头函数</li><li>方法本身写成箭头函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 正常：为undefined；bind修改this指向：指向App对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;<br>  fn2=<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//App对象</span><br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(1);</span><br><span class="language-xml">      &#125;&#125;&gt;匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1&#125;</span>&gt;</span>正常<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1.bind(this)&#125;</span>&gt;</span>bind修改this指向<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;</span><br><span class="language-xml">        console.log(this);//App对象</span><br><span class="language-xml">      &#125;&#125;&gt;匿名指向<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn2&#125;</span>&gt;</span>方法写成匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>给到事件绑定的一定得是一个方法，不要直接调用方法，调用方法只会在页面初次渲染指向方法。</li><li>事件绑定其他操作<ol><li>传递参数</li><li>获取事件对象<ol><li>并不是原生事件对象，而是合成的事件对象</li></ol></li><li>阻止默认行为，冒泡等</li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  fn3=<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b);<br>  &#125;<br>  fn4=<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//事件对象</span><br>  &#125;<br>  fn5=<span class="hljs-function">(<span class="hljs-params">a,b,c</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">//事件对象</span><br>    <span class="hljs-comment">// 阻止冒泡,和原生js是一致的</span><br>    c.<span class="hljs-title function_">stopPropagation</span>();<br>    c.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 传递参数 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn3.bind(this,1,2)&#125;</span>&gt;</span>传递参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 获取事件对象;不传参数默认接收的第一个，传参数则为最后一个 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn4&#125;</span>&gt;</span>不传参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn5.bind(this,1,2)&#125;</span>&gt;</span>传参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="组件的响应式数据"><a href="#组件的响应式数据" class="headerlink" title="组件的响应式数据"></a>组件的响应式数据</h4><ol><li>类组件响应式数据的定义<ol><li>响应式数据定义在类的state属性中 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// constructor(props)&#123;</span><br>  <span class="hljs-comment">//   super(props)</span><br>  <span class="hljs-comment">//   this.state = &#123;</span><br>      <br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">//</span><br>  state = &#123;<br>    a:<span class="hljs-number">0</span><br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;div className=&#x27;<span class="hljs-type">App</span>&#x27;&gt;<br>      &#123;<span class="hljs-keyword">this</span>.state.a&#125;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>react响应式体系的原理<ol><li>react不能像vue一样直接修改触发更新</li><li>react修改能改值，但无法触发更新，因为react没有像vue一样监听get和set，而是在调用setState的时候调用react的更新操作 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pf">class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    a:<span class="hljs-number">0</span><br>  &#125;<br>  addA=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      a:++this.<span class="hljs-keyword">state</span>.a<br>    &#125;)<br>  &#125;<br>  addB=()=&gt;&#123;<br>    this.<span class="hljs-keyword">state</span>.a+=<span class="hljs-number">1</span>;<br>    this.<span class="hljs-built_in">set</span>State(&#123;&#125;)<br>  &#125;<br>  addC=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State((<span class="hljs-keyword">state</span>)=&gt;&#123;<br>      return &#123;<br>        a: ++<span class="hljs-keyword">state</span>.a<br>      &#125;<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return <span class="hljs-variable">&lt;div className=&#x27;App&#x27;&gt;</span><br>      &#123;this.<span class="hljs-keyword">state</span>.a&#125;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addA&#125;&gt;</span>a加一第一种写法&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addB&#125;&gt;</span>a加一第二种写法&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addC&#125;&gt;</span>a加一第三种写法&lt;/button&gt;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>setState流程<ol><li>调用setState</li><li>给入一个对象</li><li>给入的对象和state对象进行浅合并</li><li>合并后调用更新方法进行更新</li><li>关键点：<ol><li><strong>通过浅合并来修改数据object.assign(),由此修改对象数据要注意展开原state,否则原对象属性会丢失</strong> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pf">class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    a:<span class="hljs-number">0</span>,<br>    c:&#123;<br>      c1:<span class="hljs-number">1</span>,<br>      c2:<span class="hljs-number">2</span>,<br>      c9:<span class="hljs-number">9</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">set</span>C=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      a:<span class="hljs-number">1</span>,<br>      c:&#123;<br>        ...this.<span class="hljs-keyword">state</span>.c,<br>        c1:<span class="hljs-number">2</span><br>      &#125;<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return <span class="hljs-variable">&lt;div className=&#x27;App&#x27;&gt;</span><br>      <span class="hljs-variable">&lt;div&gt;</span><br>        &#123;this.<span class="hljs-keyword">state</span>.a&#125; <br>        <span class="hljs-variable">&lt;br/&gt;</span><br>        &#123;this.<span class="hljs-keyword">state</span>.c.c1&#125; <br>        <span class="hljs-variable">&lt;button onClick=&#123;this.setC&#125;&gt;</span><span class="hljs-built_in">set</span>C&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>调用setState方法会触发更新，修改state并不会触发更新</li></ol></li></ol></li><li>setState方法的修改是异步的<ol><li>所以如果我们要获取修改后的值，需要在setState的第二个参数里获取 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">state</span> = &#123;<br>  a:<span class="hljs-number">0</span>,<br>  c:&#123;<br>    c1:<span class="hljs-number">1</span>,<br>    c2:<span class="hljs-number">2</span>,<br>    c9:<span class="hljs-number">9</span><br>  &#125;<br>&#125;<br><span class="hljs-built_in">set</span>C=()=&gt;&#123;<br>  this.<span class="hljs-built_in">set</span>State(&#123;<br>    a:<span class="hljs-number">1</span>,<br>    c:&#123;<br>      ...this.<span class="hljs-keyword">state</span>.c,<br>      c1:<span class="hljs-number">2</span><br>    &#125;<br>  &#125;,()=&gt;&#123;<br>    // 在这里才能获取到更新后的值<br>    console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.a);//<span class="hljs-number">1</span><br>  &#125;)<br>  console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.a);//<span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>setState的一些特性<ol><li>setState方法多次修改，会合并为一次，统一更新</li><li>setState返回会触发更新，不管你是否有修改，这造成一个问题：重复修改为相同的值也会让组件更新<ol><li>解决方法：<ol><li><code>class App extends React.PureComponent </code>,PureComponent是优化后的Component，解决了一些性能问题，其中包括上述问题的优化</li><li>PureComponent会根据state是否改变来决定是否更新，而对于对象数组这样的引用类型判断他是否改变的原理是看他的内存地址，而不是内容，所以在PureComponent下修改对象和数组，需要赋予一个新对象，一般先拷贝一份在进行操作  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">let _arr = [...this.<span class="hljs-keyword">state</span>.arr];<br>_arr.push(<span class="hljs-number">4</span>);<br>this.<span class="hljs-built_in">set</span>State(&#123;<br>    arr: _arr<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>一定不要在render里直接setState，会造成死循环。</li></ol></li></ol></li></ol></li><li><h4 id="条件渲染和列表循环"><a href="#条件渲染和列表循环" class="headerlink" title="条件渲染和列表循环"></a>条件渲染和列表循环</h4><ol><li>react没有vue一样的指令，一切操作本质都是通过运算生成不同的内容，渲染得到不同的页面</li><li>条件渲染的本质：react渲染undefined，null，空字符串，false不会渲染成任何内容 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pf">    class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    show: true,<br>  &#125;;<br>  f1() &#123;<br>    if (this.<span class="hljs-keyword">state</span>.show) &#123;<br>      return <span class="hljs-variable">&lt;div&gt;</span><span class="hljs-number">1</span>&lt;/div&gt;;<br>    &#125; else &#123;<br>      return <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div className=&quot;App&quot;&gt;</span><br>        <span class="hljs-variable">&lt;div&gt;</span>条件渲染&lt;/div&gt;<br>        &#123;this.<span class="hljs-keyword">state</span>.show ? <span class="hljs-variable">&lt;div&gt;</span><span class="hljs-number">123</span>&lt;/div&gt; : <span class="hljs-string">&quot;&quot;</span>&#125;<br>        &#123;this.f1()&#125;<br>        <span class="hljs-variable">&lt;button</span><br><span class="hljs-variable">          onClick=&#123;() =&gt;</span> &#123;<br>            this.<span class="hljs-built_in">set</span>State(&#123;<br>              show: !this.<span class="hljs-keyword">state</span>.show,<br>            &#125;);<br>          &#125;&#125;<br>        &gt;<br>          切换显隐<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>列表循环的本质<ol><li>渲染一个数组会把数组里的每一项单独取出渲染</li><li>那么编写一个里面存放的都是html结构的数组，就会渲染成列表</li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>      <span class="hljs-attr">originArr</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    &#125;;<br>  <br>    <span class="hljs-title function_">getArr</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> newAry = [];<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">originArr</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        newAry.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br>      &#125;);<br>      <span class="hljs-keyword">return</span> newAry;<br>    &#125;<br>  <br>    addData = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> newArr = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">originArr</span>];<br>      newArr.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">originArr</span>: newArr,<br>      &#125;);<br>    &#125;;<br>  <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;/* [1,2,3]转化为[<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>] */&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>列表渲染<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          &#123;this.state.originArr&#125;</span><br><span class="language-xml">          &#123;/* &#123;this.getArr()&#125; */&#125;</span><br><span class="language-xml">          &#123;/* map会直接返回数组 */&#125;</span><br><span class="language-xml">          &#123;this.state.originArr.map((item) =&gt; &#123;</span><br><span class="language-xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addData&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      );<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h4><ol><li>react表单操作和原生js操作一致<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> &#123;<br>  state = &#123;<br>    inputValue: <span class="hljs-string">&quot;&quot;</span>,<br>    checkedArr: [<span class="hljs-string">&quot;c1&quot;</span>],<br>  &#125;;<br><br>  checkChangeOption = (e) =&gt; &#123;<br>    let _arr = [...<span class="hljs-keyword">this</span>.state.checkedArr];<br>    <span class="hljs-keyword">if</span> (e.target.checked) &#123;<br>      _arr.push(e.target.value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      _arr.splice(_arr.indexOf(e.target.value), <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.setState(<br>      &#123;<br>        checkedArr: _arr,<br>      &#125;,<br>      () =&gt; &#123;<br>        console.log(<span class="hljs-keyword">this</span>.state.checkedArr, <span class="hljs-string">&quot;this.state.checkedArr&quot;</span>);<br>      &#125;<br>    );<br>  &#125;;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>        &lt;div&gt;&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;&lt;/div&gt;<br>        &#123;<span class="hljs-comment">/* input输入框 */</span>&#125;<br>        &lt;input<br>          value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;<br>          onInput=&#123;(e) =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.setState(&#123;<br>              inputValue: e.target.value,<br>            &#125;);<br>            console.log(e.target.value);<br>          &#125;&#125;<br>        /&gt;<br>        &lt;br /&gt;<br>        &#123;<span class="hljs-comment">/* checkbox 设置value获取check状态 */</span>&#125;<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c1&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c1&quot;</span><br>        /&gt;<br>        选项一<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c2&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c2&quot;</span><br>        /&gt;<br>        选项二<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c3&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c3&quot;</span><br>        /&gt;<br>        选项三<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h4 id="Props和组件间传值，插槽"><a href="#Props和组件间传值，插槽" class="headerlink" title="Props和组件间传值，插槽"></a>Props和组件间传值，插槽</h4><ol><li>props是react中的核心</li><li>在react中，一切写在组件上的属性和子节点都被规划为了props。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一、跨域</title>
    <link href="/2024/01/02/kuayu/"/>
    <url>/2024/01/02/kuayu/</url>
    
    <content type="html"><![CDATA[<!-- [借鉴文章](https://juejin.cn/post/7285576848237412387) --><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol><li>什么是跨域<ol><li>导致<strong>跨域</strong>问题产生的根本原因是来自浏览器的<strong>同源策略</strong></li><li>同源策略是浏览器的重要安全策略，用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互，其中origin指Web文档的来源，Web内容的来源取决于访问的URL的<strong>方案（协议），主机（域名）和端口定义</strong></li><li>在浏览器同源策略限制下，向不同源（不同协议、不同域名或者不同端口）发送XHR请求时，浏览器认为该请求不受信任，可能存在安全隐患，禁止该请求，并作出不正常的响应。</li></ol></li><li>跨域解决方案<ol><li><h4 id="一、关闭浏览器的同源策略"><a href="#一、关闭浏览器的同源策略" class="headerlink" title="一、关闭浏览器的同源策略"></a>一、关闭浏览器的同源策略</h4><ol><li>IE浏览器：进入ie的网际网路选项设置，然后选择安全性，再选择自订等级，然后下拉，找到「存取跨网络的资料来源」，选择启用即可</li><li>chrome浏览器：首先需要关闭所有打开的浏览器窗口，在命令行窗口输入chrome –disable-web-security</li><li>FireFox浏览器：在地址栏输入about:config，然后下拉找到security.fileuri.strict_origin_policy，然后设置为false即可</li><li>这样的做法确实从根本上解决了跨域问题，但禁用同源策略会导致安全风险，所有并不推荐这样做</li></ol></li><li><h4 id="二、JSONP"><a href="#二、JSONP" class="headerlink" title="二、JSONP"></a>二、JSONP</h4><ol><li>在项目开发中常常会引入外链的图片、样式文件、插件等资源，但这些请求没有跨域，因为这些属于http请求并不是会引发跨域问题的Xhr请求</li><li><strong>script标签没有跨域限制，src改成需要跨域请求的url，就能实现跨域获取资源，且不触发浏览器的同源策略，这就是JSONP的原理</strong>。</li><li>问题：<ol><li><strong>CSRF攻击</strong> 当前端发起一个伪造的恶意JSONP请求时，服务端的敏感信息，如用户的个人信息，密码等存在泄露的风险，需要通过验证JSONP的调用来源（Referer），服务端判断 Referer 是否是白名单，或者部署随机 Token 来防御攻击</li><li><strong>XSS漏洞</strong> <ol><li>不严谨的content-type类型会导致的 XSS 漏洞，如果没有严格定义好 Content-Type，例如 Content-Type: application&#x2F;json，或者对请求url的query参数没有进行过滤，导致请求参数是一段恶意JavaScript代码，并被服务端接收执行并返回，那么前端就会执行这段恶意代码 </li><li>通过严格定义 Content-Type: application&#x2F;json，然后严格过滤 callback 后的参数并且限制长度（进行字符转义，例如&lt;换成&amp;lt，&gt;换成&amp;gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行</li></ol></li><li><strong>仅支持GET请求方式</strong> JSOP 仅支持GET方式的请求，对于POST等其他请求方式并不能使用JSONP</li></ol></li></ol></li><li><h4 id="三、CORS"><a href="#三、CORS" class="headerlink" title="三、CORS"></a>三、CORS</h4><ol><li>Cross-Origin Resource sharing（跨域资源共享），是一种基于HTTP头的机制，该机制允许服务器标示除了它自己以外其他origin（域名，协议和端口），既浏览器在跨域的情景下仍然能从目标服务器请求并获取资源可以说CORS才是跨域问题的正统解决方案</li><li>前端任何对服务端发起的可能产生副作用的XHR类型的请求方法都会都会触发CORS中的预检机制，CORS因此将请求划分为了预检请求和简单请求两种类型<ol><li>简单请求<ol><li>CORS简单请求的策略是在请求时在请求头增加一个Origin字段，服务器收到请求后，根据该字段判断是否允许该请求访问，如果允许，在响应头信息中添加Access-Contro-Allow&#x3D;Origin字段</li><li>简单请求需要满足以下规定:<ol><li>请求方法必须是 GET POST HEAD 中的一种</li><li>头部字段必须满足CORS的安全规范</li><li>请求头的Content-Type字段值为以下三种之一<ol><li>text&#x2F;plain</li><li>application&#x2F;x-www-form-urlencoded </li><li>multipart&#x2F;form-data</li></ol></li></ol></li></ol></li><li>预检请求<ol><li>对于预检请求CORS中通过预检机制(preflight request) 检查服务器是否允许浏览器发送真实请求，浏览器会先发送一个预检请求(option请求)，请求中会携带真实请求的请求信息：<ol><li>origin：请求的来源</li><li>Access-Control-Request-Method： 通知服务器在真正的请求中会采用哪种HTTP方法（GET,POST,DELETE…）</li><li>Access-Control-Request-Headers：通知服务器在真正的请求中会采用哪些请求头</li></ol></li><li>服务端在收到预检请求后，会根据以上的请求信息，判断是否预检通过，这体现在服务端对预检请求返回的响应头里</li></ol></li></ol></li></ol></li></ol></li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">//允许全部域名跨域，可以指定特点域名，逗号分隔</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//允许携带cookie</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;X-Requested-With&quot;</span>); <span class="hljs-comment">//允许传输的请求头</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>); <span class="hljs-comment">//允许发送的xhr模式</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>,t); <span class="hljs-comment">//预检结果的缓存时间，即t时间内的该请求都按照本次的响应结果执行              </span><br></code></pre></td></tr></table></figure><p>当浏览器从预检请求的响应头中查找到以上的内容时，就会跳过同源策略，并允许真正的请求发送到服务端</p><ol><li><h4 id="四、服务器代理（ProxyServer）"><a href="#四、服务器代理（ProxyServer）" class="headerlink" title="四、服务器代理（ProxyServer）"></a>四、服务器代理（ProxyServer）</h4><ol><li>同源策略主要是限制浏览器和服务器之间的请求，服务器与服务器之间并不存在跨域问题</li><li>前端将请求发送给同源或者设置好跨域的代理服务器，代理服务器收到代理请求后，将真正的请求转发到目标服务器，并接受其响应结果，再把接收到的结果响应给前端</li></ol></li></ol><p><img src="/img/js/17043461858819.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript-基础类型</title>
    <link href="/2023/12/01/typeScriptBaseType/"/>
    <url>/2023/12/01/typeScriptBaseType/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.tslang.cn/docs/home.html">TypeScript官方中文文档地址</a></p><h4 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h4><ol><li><code>npm install -g typescript</code></li><li>使用.ts扩展名创建TypeScript文件 例<code>greeter.ts</code></li><li>编译代码 <code>tsc greeter.ts</code> 输出结果为一个 <code>greeter.js</code>文件</li></ol><!--### 基础类型--><h4 id="1、布尔值（boolean）"><a href="#1、布尔值（boolean）" class="headerlink" title="1、布尔值（boolean）"></a>1、布尔值（boolean）</h4><ol><li><code>let isBoolean: boolean = false;</code></li></ol><h4 id="2、数字（number）"><a href="#2、数字（number）" class="headerlink" title="2、数字（number）"></a>2、数字（number）</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> decLiteral: number = <span class="hljs-number">6</span>;<br><span class="hljs-built_in">let</span> hexLiteral: number = <span class="hljs-number">0xf00d</span>;<br><span class="hljs-built_in">let</span> binaryLiteral: number = <span class="hljs-number">0b1010</span>;<br><span class="hljs-built_in">let</span> octalLiteral: number = <span class="hljs-number">0o744</span>;<br></code></pre></td></tr></table></figure><h4 id="3、字符串（string）"><a href="#3、字符串（string）" class="headerlink" title="3、字符串（string）"></a>3、字符串（string）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 双引号（ &quot;）或单引号（&#x27;）表示字符串</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;bob&quot;</span>;<br>name = <span class="hljs-string">&quot;smith&quot;</span>;<br><br><span class="hljs-comment">//使用模版字符串，它可以定义多行文本和内嵌表达式。 </span><br><span class="hljs-comment">//这种字符串是被反引号包围（ `），并且以$&#123; expr &#125;这种形式嵌入表达式</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Gene`</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">37</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>.I&#x27;ll be <span class="hljs-subst">$&#123;age + <span class="hljs-number">1</span>&#125;</span> years old next month.`</span>;<br><br><span class="hljs-comment">//这与下面定义sentence的方式效果相同：</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> =<br>  <span class="hljs-string">&quot;Hello, my name is &quot;</span> +<br>  name +<br>  <span class="hljs-string">&quot;.\n\n&quot;</span> +<br>  <span class="hljs-string">&quot;I&#x27;ll be &quot;</span> +<br>  (age + <span class="hljs-number">1</span>) +<br>  <span class="hljs-string">&quot; years old next month.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="4、数组（-）"><a href="#4、数组（-）" class="headerlink" title="4、数组（[]）"></a>4、数组（[]）</h4><p>有两种方式可以定义数组</p><ol><li>在元素类型后面接上 []:<code>let list: number[] = [1, 2, 3];</code></li><li>使用数组泛型，Array&lt;元素类型&gt;:<code>let list: Array&lt;number&gt; = [1, 2, 3];</code></li></ol><h4 id="5、元组（-string-number-）"><a href="#5、元组（-string-number-）" class="headerlink" title="5、元组（[string, number]）"></a>5、元组（[string, number]）</h4><ol><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// Declare a tuple type</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-comment">// Initialize it</span><br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// Initialize it incorrectly</span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>当访问一个已知索引的元素，会得到正确的类型：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">1</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span><br></code></pre></td></tr></table></figure>当访问一个越界的元素，会使用联合类型替代：<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">x[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;world&#x27;</span>; // OK, 字符串可以赋值给<span class="hljs-built_in">(string</span> |<span class="hljs-built_in"> number</span>)类型<br><br>console.log(x[<span class="hljs-number">5</span>].toString()); // OK, <span class="hljs-string">&#x27;string&#x27;</span> 和 <span class="hljs-string">&#x27;number&#x27;</span> 都有 toString<br><br>x[<span class="hljs-number">6</span>] =<span class="hljs-built_in"> true</span>; // Error, 布尔不是<span class="hljs-built_in">(string</span> |<span class="hljs-built_in"> number</span>)类型<br></code></pre></td></tr></table></figure></li></ol><h4 id="6、枚举（enum）"><a href="#6、枚举（enum）" class="headerlink" title="6、枚举（enum）"></a>6、枚举（enum）</h4><p>enum类型是对JavaScript标准数据类型的一个补充<br>默认情况下，从0开始为元素编号.</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">enum</span> <span class="hljs-keyword">colorEnum</span> &#123;<br>  red <span class="hljs-operator">=</span> <span class="hljs-number">3</span>,<br>  yellow <span class="hljs-operator">=</span> <span class="hljs-number">6</span>,<br>  blue <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><span class="hljs-keyword">let</span> color<span class="hljs-operator">:</span> colorEnum <span class="hljs-operator">=</span> colorEnum.blue;<br><span class="hljs-keyword">let</span> color2<span class="hljs-operator">:</span> <span class="hljs-type">string</span> <span class="hljs-operator">=</span> colorEnum[<span class="hljs-number">6</span>]; <br>console.log(color,color2,colorEnum);<span class="hljs-comment">// 9 yellow</span><br></code></pre></td></tr></table></figure><h4 id="7、any（any）"><a href="#7、any（any）" class="headerlink" title="7、any（any）"></a>7、any（any）</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> list: <span class="hljs-type">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;free&quot;</span>];<br><span class="hljs-keyword">let</span> notSure: <span class="hljs-type">any</span> = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h4 id="8、void（void）"><a href="#8、void（void）" class="headerlink" title="8、void（void）"></a>8、void（void）</h4><ol><li>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-title function_">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：<code>let unusable: void = undefined;</code></li></ol><h4 id="9、undefined和null"><a href="#9、undefined和null" class="headerlink" title="9、undefined和null"></a>9、undefined和null</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Not much else we can assign to these variables!</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p><h4 id="10、never"><a href="#10、never" class="headerlink" title="10、never"></a>10、never</h4><ol><li>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</li><li>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span><span class="hljs-params">(message: string)</span>: never &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> error(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span>: never &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="11、Object"><a href="#11、Object" class="headerlink" title="11、Object"></a>11、Object</h4><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">o: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span>;<br><br><span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-number">0</span> &#125;); <span class="hljs-comment">// OK</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// OK</span><br><br><span class="hljs-title function_">create</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p><a href="https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-declare.md">declare关键字详解</a></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>另一个为as语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>typeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typeScript</tag>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑配置</title>
    <link href="/2023/11/28/ComputerConfiguration/"/>
    <url>/2023/11/28/ComputerConfiguration/</url>
    
    <content type="html"><![CDATA[<ol><li>主要部件：<ol><li>CPU</li><li>主板</li><li>内存</li><li>显卡</li><li>固态</li><li>机械</li><li>散热</li><li>电源</li><li>机箱</li></ol></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ol><li>cpu是电脑的大脑，负责几乎所有的数据处理和运算</li><li>主要品牌商<ol><li>AMD</li><li>intel</li></ol></li></ol><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><ol><li>主板是电脑的工作平台，连通并安装着各个硬件，集成了许多的设备，并为许多安装在主板上的设备提供最基础的供电</li><li>AMD的CPU需要搭配AMD的主板才能使用</li><li>intel的CPU需要搭配intel的主板才能使用</li></ol><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ol><li>电脑的草稿纸，负责临时存放当前运行和计算的数据</li></ol><h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><ol><li>电脑的图形处理中心，负责渲染并输出给显示器</li></ol><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ol><li>存放着各种文件 系统和游戏等数据</li><li>主流硬盘：<ol><li>机械硬盘 <ol><li>3.5寸和2.5寸两种规格</li><li>速度极慢但是较为廉价</li></ol></li><li>2.5寸固态硬盘<ol><li>速度较快</li></ol></li><li>PCIe固态硬盘<ol><li>速度最快</li></ol></li><li>M.2固态硬盘<ol><li>速度同PCIe</li></ol></li></ol></li></ol><h3 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h3><ol><li>负责处理芯片产生的热量</li><li>CPU与显卡在工作之余会发热，大部分显卡会自带风冷散热器，CPU需额外准备散热器</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React官方文档初解</title>
    <link href="/2023/11/23/React/"/>
    <url>/2023/11/23/React/</url>
    
    <content type="html"><![CDATA[<p><a href="https://react.docschina.org/">官方中文文档</a></p><h3 id="1、不安装体验"><a href="#1、不安装体验" class="headerlink" title="1、不安装体验"></a>1、不安装体验</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- This setup is not suitable for production. --&gt;</span><br><span class="hljs-comment">&lt;!-- Only use it in development! --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ga.jspm.io/npm:es-module-shims@1.7.0/dist/es-module-shims.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">  <span class="hljs-string">&quot;imports&quot;</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;react&quot;</span>: <span class="hljs-string">&quot;https://esm.sh/react?dev&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-string">&quot;react-dom/client&quot;</span>: <span class="hljs-string">&quot;https://esm.sh/react-dom/client?dev&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">StrictMode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Greeting</span>(<span class="hljs-params">&#123; name &#125;</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;world&quot;</span> /&gt;</span></span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));</span><br><span class="language-javascript">root.<span class="hljs-title function_">render</span>(</span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span></span></span><br><span class="language-javascript">);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">font-family</span>: sans-serif;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、编辑器设置"><a href="#2、编辑器设置" class="headerlink" title="2、编辑器设置"></a>2、编辑器设置</h3><ol><li>主流编辑器<ol><li><strong>VS Code</strong>(下面配置基于此编辑器)<ol><li>现如今最流行的编辑器之一。它拥有庞大的扩展市场，同时可以与 GitHub 等流行服务完美集成。</li></ol></li><li>WebStorm<ol><li>专为 JavaScript 设计的集成开发环境。</li></ol></li><li>Sublime Text<ol><li>支持 JSX 和 TypeScript，内置语法高亮和代码自动补全功能。</li></ol></li><li>Vim<ol><li>高度可配置的文本编辑器，可以非常高效地创建和更改任何类型的文本。它作为 “vi” 包含在大多数 UNIX 系统和 Apple OS X 中。</li></ol></li></ol></li><li><h4 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h4><ol><li><h5 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h5></li><li>官方文档中建议：<strong>请确保你已经为你的项目启用了 <code>eslint-plugin-react-hooks</code> 规则</strong>。这在 React 项目中是必备的，同时能帮助你及早的捕获较为严重的 bug。我们推荐的 <code>eslint-config-react-app</code> preset 中已经集成了该规则。</li></ol></li><li><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><ol><li><h5 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h5><ol><li>安装步骤<ol><li>启动vscode</li><li>使用快速打开（使用快捷键 Ctrl&#x2F;Cmd + P）</li><li>粘贴 <code>ext install esbenp.prettier-vscode</code></li><li>按回车键</li></ol></li></ol></li><li><h5 id="保存并自动格式化"><a href="#保存并自动格式化" class="headerlink" title="保存并自动格式化"></a>保存并自动格式化</h5><ol><li>在 VS Code, 按快捷键 <code>Ctrl/Cmd + Shift + P</code>.</li><li>输入 “settings”</li><li>按回车键</li><li>在搜索栏, 输入 “format on save”</li><li>确保勾选 “format on save” 选项！</li></ol></li></ol></li></ol><h3 id="3、react开发者工具"><a href="#3、react开发者工具" class="headerlink" title="3、react开发者工具"></a>3、react开发者工具</h3><ol><li>浏览器扩展<ol><li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">chrome扩展</a></li><li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/react-devtools/">firefox</a></li><li><a href="https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil">edge</a></li><li>现在，如果你访问一个用 React 构建 的网站，你将看到 Components 和 Profiler 面板。<ol><li><img src="/img/article/17007932745871.jpg"></li></ol></li></ol></li></ol><h3 id="4、初始组件体验"><a href="#4、初始组件体验" class="headerlink" title="4、初始组件体验"></a>4、<a id="useZJ">初始组件体验</a></h3><ol><li>React 应用是由被称为 组件 的独立 UI 片段构建而成。React 组件本质上是可以任意添加标签的 JavaScript 函数。组件可以小到一个按钮，也可以大到是整个页面。这是一个 Gallery 组件，用于渲染三个 Profile 组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">StrictMode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Amazing scientists<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li><li><h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4><ol><li>React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="第一步：导出组件"><a href="#第一步：导出组件" class="headerlink" title="第一步：导出组件"></a>第一步：导出组件</h5><ol><li>export default 前缀是一种 JavaScript 标准语法（非 React 的特性）。它允许你标签一个文件中的主要函数以便你以后可以从其他文件引入它。</li></ol></li><li><h5 id="第二步：定义函数"><a href="#第二步：定义函数" class="headerlink" title="第二步：定义函数"></a>第二步：定义函数</h5><ol><li>使用 function Profile() { } 定义名为 Profile 的 JavaScript 函数。</li><li>React 组件是常规的 JavaScript 函数，但 <strong>组件的名称必须以大写字母开头</strong>，否则它们将无法运行！</li></ol></li><li><h5 id="第三步：添加标签"><a href="#第三步：添加标签" class="headerlink" title="第三步：添加标签"></a>第三步：添加标签</h5><ol><li>这个组件返回一个带有 src 和 alt 属性的 <img /> 标签。<img /> 写得像 HTML，但实际上是 JavaScript！这种语法被称为 <strong>JSX</strong>，它允许你在 JavaScript 中嵌入使用标签。</li><li>返回语句可以全写在一行上，如下面组件中所示：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">return &lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span> alt<span class="hljs-operator">=</span><span class="hljs-string">&quot;Katherine Johnson&quot;</span> /&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>但是，如果你的标签和 return 关键字不在同一行，则<strong>必须把它包裹在一对括号中</strong>，如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br></code></pre></td></tr></table></figure><ol><li><strong>没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！</strong></li></ol></li></ol></li><li><h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><ol><li>定义了 Profile 组件，你可以在其他组件中使用它。例如，你可以导出一个内部使用了多个 Profile 组件的 Gallery 组件：<a href="#useZJ">LINK</a> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>了不起的科学家<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意：<ol><li><section> 是小写的，所以 React 知道我们指的是 HTML 标签。</li><li><Profile /> 以大写 P 开头，所以 React 知道我们想要使用名为 Profile 的组件。</li></ol></li><li>嵌套和组织组件 <ol><li><p>组件是常规的 JavaScript 函数，所以你可以将多个组件保存在同一份文件中。当组件相对较小或彼此紧密相关时，这是一种省事的处理方式。如果这个文件变得臃肿，你也可以随时将 Profile 移动到单独的文件中</p></li><li><p>因为 Profile 组件在 Gallery 组件中渲染——甚至好几次！——我们可以认为 Gallery 是一个 父组件，将每个 Profile 渲染为一个“孩子”。这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。</p></li><li><p><strong>组件可以渲染其他组件，但是 请不要嵌套他们的定义</strong>：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 🔴 永远不要在组件中定义组件</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 上面这段代码 非常慢，并且会导致 bug 产生。因此，你应该在顶层定义每个组件：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 在顶层声明组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 当子组件需要使用父组件的数据时，你需要 通过 props 的形式进行传递，而不是嵌套定义。</p></li></ol></li></ol></li></ol></li></ol><h3 id="5、组件的导入与导出"><a href="#5、组件的导入与导出" class="headerlink" title="5、组件的导入与导出"></a>5、组件的导入与导出</h3><ol><li><h4 id="根组件文件"><a href="#根组件文件" class="headerlink" title="根组件文件"></a>根组件文件</h4></li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">app.js<br> <span class="hljs-keyword">function</span> <span class="hljs-title">···</span><br></code></pre></td></tr></table></figure><p>在此示例中，所有组件目前都定义在 根组件 App.js 文件中。具体还需根据项目配置决定，有些根组件可能会声明在其他文件中。如果你使用的框架基于文件进行路由，如 Next.js，那你每个页面的根组件都会不一样</p><ol><li><h4 id="导出和导入一个组件"><a href="#导出和导入一个组件" class="headerlink" title="导出和导入一个组件"></a>导出和导入一个组件</h4><ol><li>创建 一个新的 JS 文件来存放该组件。</li><li>导出 该文件中的函数组件（可以使用 默认导出 或 具名导出） <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[filename]<span class="hljs-title class_">Gallery</span>.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/QIrZWGIs.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Alan L. Hart&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>了不起的科学家们<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在需要使用该组件的文件中 导入（可以根据相应的导出方式使用 默认导入 或 具名导入）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[filename]<span class="hljs-title class_">App</span>.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Gallery</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Gallery.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Gallery</span> /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="默认-具名-导出导入"><a href="#默认-具名-导出导入" class="headerlink" title="默认&#x2F;具名 导出导入"></a>默认&#x2F;具名 导出导入</h5></li></ol><table><thead><tr><th>语法</th><th>导出语句</th><th>导入语句</th></tr></thead><tbody><tr><td>默认</td><td><code>export default function Button() &#123;&#125;</code></td><td><code>import Button from &#39;./Button.js&#39;;</code></td></tr><tr><td>具名</td><td><code>export function Button() &#123;&#125;</code></td><td><code>import &#123; Button &#125; from &#39;./Button.js&#39;;</code></td></tr></tbody></table></li></ol><h3 id="6、JSX"><a href="#6、JSX" class="headerlink" title="6、JSX"></a>6、JSX</h3><ol><li>JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。</li><li>JSX规则<ol><li><h5 id="只能返回一个根元素"><a href="#只能返回一个根元素" class="headerlink" title="只能返回一个根元素"></a>只能返回一个根元素</h5></li><li><h5 id="标签必须闭合"><a href="#标签必须闭合" class="headerlink" title="标签必须闭合"></a>标签必须闭合</h5><ol><li><img> 这样的自闭合标签必须书写成 <img /> </li><li><li>oranges 这样只有开始标签的元素必须带有闭合标签，需要改为 <li>oranges</li>。</li></ol></li><li><h5 id="驼峰式命名法"><a href="#驼峰式命名法" class="headerlink" title="驼峰式命名法"></a>驼峰式命名法</h5><ol><li>变量名称不能包含 - 符号或者像 class 这样的保留字。</li><li>使用名称className而不是class作为属性名，是因为”class” 在 JavaScript 中是个保留字。</li><li>由于历史原因，aria-* 和 data-* 属性是以带 - 符号的 HTML 格式书写的。</li></ol></li><li>高级提示：使用 JSX 转化器 </li><li><h5 id="大括号使用"><a href="#大括号使用" class="headerlink" title="大括号使用"></a>大括号使用</h5><ol><li>JSX 允许你在 JavaScript 中编写类似 HTML 的标签，从而使渲染的逻辑和内容可以写在一起。有时候，你可能想要在标签中添加一些 JavaScript 逻辑或者引用动态的属性。这种情况下，你可以在 JSX 的大括号内来编写 JavaScript。</li><li>用 { 和 } 替代 “ 和 “ 以使用 JavaScript 变量 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> avatar = <span class="hljs-string">&#x27;https://i.imgur.com/7vQD0fPs.jpg&#x27;</span>;<br>  <span class="hljs-keyword">const</span> description = <span class="hljs-string">&#x27;Gregorio Y. Zara&#x27;</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;avatar&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;description&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用大括号<ol><li><h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Gregorio Y. Zara&#x27;</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;&#x27;s To Do List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">person=</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name:</span> <span class="hljs-string">&quot;Hedy Lamarr&quot;</span>, inventions: <span class="hljs-number">5</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure></li><li><h6 id="css"><a href="#css" class="headerlink" title="css"></a>css</h6> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">  <span class="hljs-name">backgroundColor:</span> <span class="hljs-string">&#x27;black&#x27;</span>,</span><br><span class="hljs-template-variable">  color: <span class="hljs-string">&#x27;pink&#x27;</span></span><br><span class="hljs-template-variable">&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&gt;</span></span><br></code></pre></td></tr></table></figure> 1.<strong>内联 style 属性 使用驼峰命名法编写</strong>。例如，HTML <code>&lt;ul style=&quot;background-color: black&quot;&gt;</code> 在你的组件里应该写成 <code>&lt;ul style=&#123;&#123; backgroundColor: 'black' &#125;&#125;&gt;</code>。</li><li><h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">DateTimeFormat</span>(<br>    <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br>    &#123; <span class="hljs-attr">weekday</span>: <span class="hljs-string">&#x27;long&#x27;</span> &#125;<br>  ).<span class="hljs-title function_">format</span>(date);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>To Do List for &#123;formatDate(today)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><h3 id="7、将-Props-传递给组件"><a href="#7、将-Props-传递给组件" class="headerlink" title="7、将 Props 传递给组件"></a>7、将 Props 传递给组件</h3><ol><li>React 组件使用 props 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它。Props 可能会让你想起 HTML 属性，但你可以通过它们传递任何 JavaScript 值，包括对象、数组和函数。</li><li>向组件传递 props<ol><li><h4 id="将-props-传递给子组件"><a href="#将-props-传递给子组件" class="headerlink" title="将 props 传递给子组件"></a>将 props 传递给子组件</h4></li></ol> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">export default function Profile() &#123;</span><br><span class="language-xml">  return (</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">person</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name:</span> <span class="hljs-string">&#x27;Lin Lanying&#x27;</span>, imageId: <span class="hljs-string">&#x27;1bX5QH6&#x27;</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;100&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br><span class="language-xml">  );</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="在子组件中读取-props"><a href="#在子组件中读取-props" class="headerlink" title="在子组件中读取 props"></a>在子组件中读取 props</h4><ol><li>在声明 props 时， 不要忘记 ( 和 ) 之间的一对花括号 { 和 } ; 这种语法被称为 “解构”，等价于于从函数参数中读取属性： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">&#123; person, size &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>等价于<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> person = props.<span class="hljs-property">person</span>;<br>  <span class="hljs-keyword">let</span> size = props.<span class="hljs-property">size</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h4 id="给-prop-指定一个默认值"><a href="#给-prop-指定一个默认值" class="headerlink" title="给 prop 指定一个默认值"></a>给 prop 指定一个默认值</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">&#123; person, size = <span class="hljs-number">100</span> &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="使用-JSX-展开语法传递-props"><a href="#使用-JSX-展开语法传递-props" class="headerlink" title="使用 JSX 展开语法传递 props"></a>使用 JSX 展开语法传递 props</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params">&#123; person, size, isSepia, thickBorder &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;person&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;size&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isSepia</span>=<span class="hljs-string">&#123;isSepia&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">thickBorder</span>=<span class="hljs-string">&#123;thickBorder&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br>简化：<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="将-JSX-作为子组件传递"><a href="#将-JSX-作为子组件传递" class="headerlink" title="将 JSX 作为子组件传递"></a>将 JSX 作为子组件传递</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Avatar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Avatar.js&#x27;</span>;<br>    <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Card</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;100&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;&#123;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name:</span> &#x27;<span class="hljs-attr">Katsuko</span> <span class="hljs-attr">Saruhashi</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">imageId:</span> &#x27;<span class="hljs-attr">YfeOqp2</span>&#x27;</span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><h4 id="Props-如何随时间变化"><a href="#Props-如何随时间变化" class="headerlink" title="Props 如何随时间变化"></a>Props 如何随时间变化</h4><ol><li><a href="">State: 一个组件的内存;hook</a></li></ol></li></ol></li></ol><h3 id="8、条件渲染"><a href="#8、条件渲染" class="headerlink" title="8、条件渲染"></a>8、条件渲染</h3><ol><li>在 React 中，你可以通过使用 JavaScript 的 if 语句、&amp;&amp; 和 ? : 运算符来选择性地渲染 JSX。</li><li><h4 id="if-条件返回-JSX"><a href="#if-条件返回-JSX" class="headerlink" title="(if)条件返回 JSX"></a>(if)条件返回 JSX</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">&#123; name, isPacked &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125; ✔<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PackingList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Sally Ride 的行李清单<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;true&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;宇航服&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;true&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;带金箔的头盔&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;false&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Tam 的照片&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">&#123; name, isPacked &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三目运算符（-）"><a href="#三目运算符（-）" class="headerlink" title="三目运算符（? :）"></a>三目运算符（? :）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;isPacked ? (</span><br><span class="language-xquery">        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-xquery">          </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> + <span class="hljs-string">&#x27; ✔&#x27;</span>&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span></span><br>      ) : (<br>       <span class="hljs-built_in"> name</span><br>      )&#125;<br>    &lt;/li&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="与运算符（-）"><a href="#与运算符（-）" class="headerlink" title="与运算符（&amp;&amp;）"></a>与运算符（&amp;&amp;）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml"> </span><span class="language-xquery">&#123;isPacked &amp;&amp; <span class="hljs-string">&#x27;✔&#x27;</span>&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>切勿将数字放在 &amp;&amp; 左侧</strong><ol><li>JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，<strong>如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染</strong>。</li><li>例如，一个常见的错误是 <code>messageCount &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。其原本是想当 messageCount 为 0 的时候不进行渲染，但实际上却渲染了 0。</li><li>为了更正，可以将左侧的值改成布尔类型：<code>messageCount &gt; 0 &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。</li></ol></li></ol><h4 id="选择性地将-JSX-赋值给变量"><a href="#选择性地将-JSX-赋值给变量" class="headerlink" title="选择性地将 JSX 赋值给变量"></a>选择性地将 JSX 赋值给变量</h4><ol><li>当这些快捷方式妨碍写普通代码时，可以考虑使用 if 语句和变量。因为你可以使用 let 进行重复赋值，所以一开始你可以将你想展示的（这里指的是物品的名字）作为默认值赋予给该变量。<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">let</span> itemContent =<span class="hljs-built_in"> name</span>;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    itemContent =<span class="hljs-built_in"> name</span> + <span class="hljs-string">&quot; ✔&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;itemContent&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">let</span> itemContent =<span class="hljs-built_in"> name</span>;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    itemContent = (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> + <span class="hljs-string">&quot; ✔&quot;</span>&#125;</span><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span></span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;itemContent&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="9、渲染列表"><a href="#9、渲染列表" class="headerlink" title="9、渲染列表"></a>9、渲染列表</h3><ol><li>React 中使用 <strong>filter()</strong> 筛选需要渲染的组件和使用 <strong>map()</strong> 把数组转换成组件数组。</li><li>demo<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; people &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getImageUrl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> listItems = people.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;person.id&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;getImageUrl(person)&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;person.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;person.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">          &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;</span><br><span class="language-xml">          因&#123;person.accomplishment&#125;而闻名世界</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><ol><li>直接放在 map() 方法里的 JSX 元素一般都需要指定 key 值！</li><li>如何设定 key 值 <ol><li>来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。</li><li>本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。</li></ol></li><li>key 需要满足的条件<ol><li>key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。</li><li>key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。</li></ol></li><li>React 中为什么需要 key？<ol><li>设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……</li><li>React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。</li></ol></li></ol></li></ol><h3 id="10、保持组件纯粹-纯函数）"><a href="#10、保持组件纯粹-纯函数）" class="headerlink" title="10、保持组件纯粹(纯函数）"></a>10、保持组件纯粹(纯函数）</h3><ol><li><h4 id="纯函数：组件作为公式"><a href="#纯函数：组件作为公式" class="headerlink" title="纯函数：组件作为公式"></a>纯函数：组件作为公式</h4></li><li><p>纯函数特征</p><ol><li>只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。</li><li>输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">举个你非常熟悉的纯函数示例：数学中的公式。<br><br>考虑如下数学公式：y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-keyword">x</span>。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> 则 y <span class="hljs-operator">=</span> <span class="hljs-number">4</span>。永远如此。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> 则 y <span class="hljs-operator">=</span> <span class="hljs-number">6</span>。永远如此。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>，那么 y 并不会因为时间或股市的影响，而有时等于 <span class="hljs-number">9</span> 、 –<span class="hljs-number">1</span> 或 <span class="hljs-number">2.5</span>。<br><br>若 y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-keyword">x</span> 且 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> 那么 y 永远 等于 <span class="hljs-number">6</span>.<br><br>我们使用 JavaScript 的函数实现，看起来将会是这样：<br><br>function <span class="hljs-keyword">double</span>(number) &#123;<br>  return <span class="hljs-number">2</span> * number<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>React 便围绕着这个概念进行设计。<strong>React 假设你编写的所有组件都是纯函数</strong>。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。</li></ol></li><li><h4 id="副作用-不符合-预期的后果"><a href="#副作用-不符合-预期的后果" class="headerlink" title="副作用:(不符合)预期的后果"></a>副作用:(不符合)预期的后果</h4><ol><li>React 的渲染过程必须自始至终是纯粹的。组件应该只 返回 它们的 JSX，而不 改变 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！</li><li>错误示例:该组件正在读写其外部声明的 guest 变量。这意味着 <strong>多次调用这个组件会产生不同的 JSX</strong>！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> guest = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Bad: changing a preexisting variable!</span><br>  guest = guest + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaSet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br>修复：<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params">&#123; guest &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaSet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;1&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;2&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;3&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="局部mutation：组件的小秘密"><a href="#局部mutation：组件的小秘密" class="headerlink" title="局部mutation：组件的小秘密"></a>局部mutation：组件的小秘密</h4><ol><li>上述示例的问题出在渲染过程中，组件改变了 预先存在的 变量的值。为了让它听起来更可怕一点，我们将这种现象称为 <strong>突变（mutation）</strong> 。纯函数不会改变函数作用域外的变量、或在函数调用前创建的对象——这会使函数变得不纯粹！</li><li>但是，<strong>你完全可以在渲染时更改你 刚刚 创建的变量和对象</strong>。在本示例中，你创建一个 [] 数组，将其分配给一个 cups 变量，然后 push 一打 cup 进去：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params">&#123; guest &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaGathering</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> cups = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>    cups.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;i&#125;</span> /&gt;</span></span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> cups;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>解析：<ol><li>如果 cups 变量或 [] 数组是在 TeaGathering 函数之外创建的，这将是一个很大的问题！因为如果那样的话，当你调用数组的 push 方法时，就会更改 <strong>预先存在的</strong> 对象。</li><li>但是，这里不会有影响，因为每次渲染时，你都是在 TeaGathering 函数内部创建的它们。TeaGathering 之外的代码并不会知道发生了什么。这就被称为 <strong>“局部 mutation”</strong> — 如同藏在组件里的小秘密。</li></ol></li></ol><h4 id="哪些地方可能引发副作用"><a href="#哪些地方可能引发副作用" class="headerlink" title="哪些地方可能引发副作用"></a>哪些地方可能引发副作用</h4><p>函数式编程在很大程度上依赖于纯函数，但 某些事物 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。</p><p>在 React 中，<strong>副作用通常属于 事件处理程序</strong>。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。</p><p>如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 <strong><code>useEffect</code></strong> 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，<strong>这种方法应该是你最后的手段</strong>。</p><h3 id="11、将-UI-视为树"><a href="#11、将-UI-视为树" class="headerlink" title="11、将 UI 视为树"></a>11、将 UI 视为树</h3><ol><li>树是表示实体之间关系的常见方式，它们经常用于建模 UI。</li><li>渲染树表示单次渲染中 React 组件之间的嵌套关系。</li><li>使用条件渲染，渲染树可能会在不同的渲染过程中发生变化。使用不同的属性值，组件可能会渲染不同的子组件。</li><li>渲染树有助于识别顶级组件和叶子组件。顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染。识别它们有助于理解和调试渲染性能问题。</li><li>依赖树表示 React 应用程序中的模块依赖关系。</li><li>构建工具使用依赖树来捆绑必要的代码以部署应用程序。</li><li>依赖树有助于调试大型捆绑包带来的渲染速度过慢的问题，以及发现哪些捆绑代码可以被优化。</li></ol><h3 id="12、响应事件"><a href="#12、响应事件" class="headerlink" title="12、响应事件"></a>12、响应事件</h3><ol><li>React 允许你向 JSX 中添加事件处理程序。事件处理程序是你自己的函数，它将在用户交互时被触发，如点击、悬停、焦点在表单输入框上等等。</li><li><code>&lt;button&gt;</code> 等内置组件只支持内置浏览器事件，如 <code>onClick</code>。但是，你也可以创建你自己的组件，并给它们的事件处理程序 <code>props</code> 指定你喜欢的任何特定于应用的名称。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onPlayMovie</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> alert(&#x27;Playing!&#x27;)&#125;</span><br><span class="language-xml">      onUploadImage=&#123;() =&gt; alert(&#x27;Uploading!&#x27;)&#125;</span><br><span class="language-xml">    /&gt;</span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toolbar</span>(<span class="hljs-params">&#123; onPlayMovie, onUploadImage &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onPlayMovie&#125;</span>&gt;</span></span><br><span class="language-xml">        Play Movie</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onUploadImage&#125;</span>&gt;</span></span><br><span class="language-xml">        Upload Image</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">&#123; onClick, children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="13、State-组件的记忆"><a href="#13、State-组件的记忆" class="headerlink" title="13、State: 组件的记忆"></a>13、State: 组件的记忆</h3><p>组件通常需要根据交互改变屏幕上的内容。在表单中键入更新输入栏，在轮播图上点击“下一个”改变显示的图片，点击“购买”将产品放入购物车。组件需要“记住”一些东西：当前的输入值、当前的图片、购物车。在 React 中，这种特定于组件的记忆被称为状态。</p><p>你可以用 useState Hook 为组件添加状态。Hook 是能让你的组件使用 React 功能的特殊函数（状态是这些功能之一）。useState Hook 让你声明一个状态变量。它接收初始状态并返回一对值：当前状态，以及一个让你更新状态的设置函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; sculptureList &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [index, setIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [showMore, setShowMore] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> hasNext = index &lt; sculptureList.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNextClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (hasNext) &#123;<br>      <span class="hljs-title function_">setIndex</span>(index + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setIndex</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMoreClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setShowMore</span>(!showMore);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> sculpture = sculptureList[index];<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleNextClick&#125;</span>&gt;</span></span><br><span class="language-xml">        Next</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>&#123;sculpture.name&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">        by &#123;sculpture.artist&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        (&#123;index + 1&#125; of &#123;sculptureList.length&#125;)</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleMoreClick&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;showMore ? &#x27;Hide&#x27; : &#x27;Show&#x27;&#125; details</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;showMore &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;sculpture.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;sculpture.url&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;sculpture.alt&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14、渲染和提交"><a href="#14、渲染和提交" class="headerlink" title="14、渲染和提交"></a>14、渲染和提交</h3><p>在你的组件显示在屏幕上之前，它们必须由 React 进行渲染。理解这个过程中的步骤有助于你思考你的代码如何执行并解释其行为。</p><ol><li><strong>触发</strong>渲染（将食客的订单送到厨房）</li><li><strong>渲染</strong>组件（在厨房准备订单）</li><li><strong>提交</strong>到 DOM（将订单送到桌前）</li></ol><h3 id="15、作为快照的状态"><a href="#15、作为快照的状态" class="headerlink" title="15、作为快照的状态"></a>15、作为快照的状态</h3><p>与普通 JavaScript 变量不同，React 状态的行为更像一个快照。设置它并不改变你已有的状态变量，而是触发一次重新渲染。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);  <span class="hljs-comment">// 0</span><br>setCount(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 请求用 1 重新渲染</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);  <span class="hljs-comment">// 仍然是 0！</span><br></code></pre></td></tr></table></figure><h3 id="16、把一系列-state-更新加入队列"><a href="#16、把一系列-state-更新加入队列" class="headerlink" title="16、把一系列 state 更新加入队列"></a>16、把一系列 state 更新加入队列</h3><ol><li>如下有问题的组件，点击“+3”只能增加一次分数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [score, setScore] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setScore</span>(score + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> increment()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">      &#125;&#125;&gt;+3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Score: &#123;score&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>作为快照的状态 解释了为什么会出现这种情况。设置状态会请求一个新的重新渲染，但不会在已运行的代码中更改它。所以在你调用 setScore(score + 1) 后，score 仍然是 0。<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>你可以通过在设置状态时传递一个 更新器函数 来解决这个问题。注意用 setScore(s &#x3D;&gt; s + 1) 替换 setScore(score + 1) 是如何修复“+3”按钮的。如果你需要排队进行多次状态更新，那么这非常方便。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [score, setScore] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setScore</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> increment()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">      &#125;&#125;&gt;+3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Score: &#123;score&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="17、更新状态中的对象"><a href="#17、更新状态中的对象" class="headerlink" title="17、更新状态中的对象"></a>17、更新状态中的对象</h3><p>状态可以持有任何类型的 JavaScript 值，包括对象。但你不应该直接改变你在 React 状态中持有的对象和数组。相反，当你想更新一个对象和数组时，你需要创建一个新的对象（或复制现有的对象），然后用这个副本来更新状态。</p><p>通常情况下，你会使用 … 展开语法来复制你想改变的对象和数组。例如，更新一个嵌套对象可以是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [person, setPerson] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Niki de Saint Phalle&#x27;</span>,<br>    <span class="hljs-attr">artwork</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Blue Nana&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Hamburg&#x27;</span>,<br>      <span class="hljs-attr">image</span>: <span class="hljs-string">&#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;</span>,<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">name</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTitleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">title</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCityChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">city</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleImageChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">image</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Name:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Title:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.title&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleTitleChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        City:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.city&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleCityChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Image:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.image&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleImageChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>&#123;person.artwork.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">        &#123;&#x27; by &#x27;&#125;</span><br><span class="language-xml">        &#123;person.name&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        (located in &#123;person.artwork.city&#125;)</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;person.artwork.image&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;person.artwork.title&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在代码中复制对象感觉乏味，可以使用 Immer 之类的库来减少重复代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;immer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.7.3&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;use-immer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.5.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts start&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts test --env=jsdom&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="18、更新状态中的数组"><a href="#18、更新状态中的数组" class="headerlink" title="18、更新状态中的数组"></a>18、更新状态中的数组</h3><p>数组是另一种可以存在状态中的可变 JavaScript 对象，应将其视为只读。就像对象一样，当你想更新存在状态中的数组时，你需要创建一个新数组（或者复制现有数组），然后用新数组来更新状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">let</span> nextId = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> initialList = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Big Bellies&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Lunar Landscape&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Terracotta Army&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span> &#125;,<br>];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BucketList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>(<br>    initialList<br>  );<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleToggle</span>(<span class="hljs-params">artworkId, nextSeen</span>) &#123;<br>    <span class="hljs-title function_">setList</span>(list.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">artwork</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (artwork.<span class="hljs-property">id</span> === artworkId) &#123;<br>        <span class="hljs-keyword">return</span> &#123; ...artwork, <span class="hljs-attr">seen</span>: nextSeen &#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> artwork;<br>      &#125;<br>    &#125;));<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Art Bucket List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>My list of art to see:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ItemList</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">artworks</span>=<span class="hljs-string">&#123;list&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onToggle</span>=<span class="hljs-string">&#123;handleToggle&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ItemList</span>(<span class="hljs-params">&#123; artworks, onToggle &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;artworks.map(artwork =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;artwork.id&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;artwork.seen&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">                onToggle(</span><br><span class="language-xml">                  artwork.id,</span><br><span class="language-xml">                  e.target.checked</span><br><span class="language-xml">                );</span><br><span class="language-xml">              &#125;&#125;</span><br><span class="language-xml">            /&gt;</span><br><span class="language-xml">            &#123;artwork.title&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19、使用状态响应输入"><a href="#19、使用状态响应输入" class="headerlink" title="19、使用状态响应输入"></a>19、使用状态响应输入</h3><p>使用 React，你不用直接从代码层面修改 UI。例如，不用编写诸如“禁用按钮”、“启用按钮”、“显示成功消息”等命令。相反，你只需要描述组件在不同状态（“初始状态”、“输入状态”、“成功状态”）下希望展现的 UI，然后根据用户输入触发状态更改。这和设计师对 UI 的理解很相似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [answer, setAnswer] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [status, setStatus] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;typing&#x27;</span>);<br><br>  <span class="hljs-keyword">if</span> (status === <span class="hljs-string">&#x27;success&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>答对了！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;submitting&#x27;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">submitForm</span>(answer);<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;typing&#x27;</span>);<br>      <span class="hljs-title function_">setError</span>(err);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTextareaChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setAnswer</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>城市测验<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        哪个城市有把空气变成饮用水的广告牌？</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;answer&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleTextareaChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;status</span> === <span class="hljs-string">&#x27;submitting&#x27;</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">answer.length</span> === <span class="hljs-string">0</span> ||</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">status</span> === <span class="hljs-string">&#x27;submitting&#x27;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&gt;</span></span><br><span class="language-xml">          提交</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        &#123;error !== null &amp;&amp;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Error&quot;</span>&gt;</span></span><br><span class="language-xml">            &#123;error.message&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">submitForm</span>(<span class="hljs-params">answer</span>) &#123;<br>  <span class="hljs-comment">// 模拟接口请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> shouldError = answer.<span class="hljs-title function_">toLowerCase</span>() !== <span class="hljs-string">&#x27;lima&#x27;</span><br>      <span class="hljs-keyword">if</span> (shouldError) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;猜的不错，但答案不对。再试试看吧！&#x27;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>();<br>      &#125;<br>    &#125;, <span class="hljs-number">1500</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20、选择状态结构"><a href="#20、选择状态结构" class="headerlink" title="20、选择状态结构"></a>20、选择状态结构</h3><p>状态不应包含冗余或重复的信息。如果包含一些多余的状态，我们会很容易忘记去更新它，从而导致问题产生！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> fullName = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFirstNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setFirstName</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleLastNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setLastName</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>让我们帮你登记<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        名：&#123;&#x27; &#x27;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;firstName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleFirstNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        姓：&#123;&#x27; &#x27;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;lastName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleLastNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        你的票将发给：<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;fullName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21、在组件间共享状态"><a href="#21、在组件间共享状态" class="headerlink" title="21、在组件间共享状态"></a>21、在组件间共享状态</h3><ol><li>有时候你希望两个组件的状态始终同步更改。要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过 props 将状态传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Accordion</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [activeIndex, setActiveIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Almaty, Kazakhstan<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Panel</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;关于&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;activeIndex</span> === <span class="hljs-string">0&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onShow</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setActiveIndex(0)&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        阿拉木图人口约200万，是哈萨克斯坦最大的城市。在1929年至1997年之间，它是该国首都。</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Panel</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Panel</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;词源&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;activeIndex</span> === <span class="hljs-string">1&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onShow</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setActiveIndex(1)&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        这个名字源于哈萨克语 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;kk-KZ&quot;</span>&gt;</span>алма<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>，是“苹果”的意思，通常被翻译成“满是苹果”。事实上，阿拉木图周围的地区被认为是苹果的祖籍，<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;la&quot;</span>&gt;</span>Malus sieversii<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 被认为是目前本土苹果的祖先。</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Panel</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Panel</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  title,</span><br><span class="hljs-params">  children,</span><br><span class="hljs-params">  isActive,</span><br><span class="hljs-params">  onShow</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;panel&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      &#123;isActive ? (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onShow&#125;</span>&gt;</span></span><br><span class="language-xml">          显示</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="22、保留和重置状态"><a href="#22、保留和重置状态" class="headerlink" title="22、保留和重置状态"></a>22、保留和重置状态</h3><ol><li>你重新渲染一个组件时， React 需要决定组件树中的哪些部分要保留和更新，以及丢弃或重新创建。在大多数情况下， React 的自动处理机制已经做得足够好了。默认情况下，React 会保留树中与先前渲染的组件树“匹配”的部分。</li><li>React 允许你覆盖默认行为，可通过向组件传递一个唯一 key（如 <Chat key={email}/> 来 强制 重置其状态。这会告诉 React ，如果收件人不同，应将其作为一个 不同的 Chat 组件，需要使用新数据和 UI（比如输入框）来重新创建它。现在，在接收者之间切换时就会重置输入框——即使渲染的是同一个组件。</li></ol><h3 id="23、提取状态逻辑到-reducer-中"><a href="#23、提取状态逻辑到-reducer-中" class="headerlink" title="23、提取状态逻辑到 reducer 中"></a>23、提取状态逻辑到 reducer 中</h3><ol><li>对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。在文件的底部，reducer 函数指定状态应该如何更新以响应每个 action！<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AddTask</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AddTask.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">TaskList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./TaskList.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TaskApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [tasks, dispatch] = <span class="hljs-title function_">useReducer</span>(<br>    tasksReducer,<br>    initialTasks<br>  );<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAddTask</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;added&#x27;</span>,<br>      <span class="hljs-attr">id</span>: nextId++,<br>      <span class="hljs-attr">text</span>: text,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChangeTask</span>(<span class="hljs-params">task</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;changed&#x27;</span>,<br>      <span class="hljs-attr">task</span>: task<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDeleteTask</span>(<span class="hljs-params">taskId</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;deleted&#x27;</span>,<br>      <span class="hljs-attr">id</span>: taskId<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>布拉格行程<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AddTask</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onAddTask</span>=<span class="hljs-string">&#123;handleAddTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TaskList</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">tasks</span>=<span class="hljs-string">&#123;tasks&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChangeTask</span>=<span class="hljs-string">&#123;handleChangeTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onDeleteTask</span>=<span class="hljs-string">&#123;handleDeleteTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tasksReducer</span>(<span class="hljs-params">tasks, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;added&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> [...tasks, &#123;<br>        <span class="hljs-attr">id</span>: action.<span class="hljs-property">id</span>,<br>        <span class="hljs-attr">text</span>: action.<span class="hljs-property">text</span>,<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>      &#125;];<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;changed&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> tasks.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-property">id</span> === action.<span class="hljs-property">task</span>.<span class="hljs-property">id</span>) &#123;<br>          <span class="hljs-keyword">return</span> action.<span class="hljs-property">task</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> t;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;deleted&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> !== action.<span class="hljs-property">id</span>);<br>    &#125;<br>    <span class="hljs-attr">default</span>: &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;未知操作：&#x27;</span> + action.<span class="hljs-property">type</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> nextId = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> initialTasks = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;参观卡夫卡博物馆&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;看木偶戏&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;列侬墙图片&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>];<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="24、使用-Context-进行深层数据传递"><a href="#24、使用-Context-进行深层数据传递" class="headerlink" title="24、使用 Context 进行深层数据传递"></a>24、使用 Context 进行深层数据传递</h3><ol><li>通常，你会通过 props 将信息从父组件传递给子组件。但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。<!--2. 这里的 Heading 组件通过“询问”最近的 Section 来确定其标题级别。每个 Section 的级别是通过给父 Section 添加的级别来确定的。每个 Section 都向它下层的所有组件提供信息，不需要逐层传递 props，而是通过 Context 来实现。--></li></ol><h3 id="25、使用-Reducer-和-Context-进行状态扩展"><a href="#25、使用-Reducer-和-Context-进行状态扩展" class="headerlink" title="25、使用 Reducer 和 Context 进行状态扩展"></a>25、使用 Reducer 和 Context 进行状态扩展</h3><ol><li>Reducer 帮助你合并组件的状态更新逻辑。Context 帮助你将信息深入传递给其他组件。你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。</li><li>基于这种想法，使用 reducer 来管理一个具有复杂状态的父组件。组件树中任何深度的其他组件都可以通过 context 读取其状态。还可以 dispatch 一些 action 来更新状态。</li></ol><h3 id="26、使用-ref-引用值"><a href="#26、使用-ref-引用值" class="headerlink" title="26、使用 ref 引用值"></a>26、使用 ref 引用值</h3><ol><li>当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref：<code>const ref = useRef(0);</code></li><li>与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 <code>ref.current</code> 属性访问该 ref 的当前值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    ref.<span class="hljs-property">current</span> = ref.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你点击了 &#x27;</span> + ref.<span class="hljs-property">current</span> + <span class="hljs-string">&#x27; 次!&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      点我！</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>ref 就像组件的一个不被 React 追踪的秘密口袋。例如，可以使用 ref 来存储 timeout ID、DOM 元素 和其他不影响组件渲染输出的对象。</li></ol><h3 id="27、使用-ref-操作-DOM"><a href="#27、使用-ref-操作-DOM" class="headerlink" title="27、使用 ref 操作 DOM"></a>27、使用 ref 操作 DOM</h3><ol><li>由于 React 会自动更新 DOM 以匹配渲染输出，因此组件通常不需要操作 DOM。但是，有时可能需要访问由 React 管理的 DOM 元素——例如聚焦节点、滚动到此节点，以及测量它的尺寸和位置。React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现。例如，点击按钮将使用 ref 聚焦输入框：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        聚焦输入框</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="28、使用-Effect-实现同步"><a href="#28、使用-Effect-实现同步" class="headerlink" title="28、使用 Effect 实现同步"></a>28、使用 Effect 实现同步</h3><ol><li>有些组件需要与外部系统同步。例如，可能需要根据 React 状态控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。与处理特定事件的事件处理程序不同，Effect 在渲染后运行一些代码。使用它将组件与 React 之外的系统同步。</li><li>多按几次播放&#x2F;暂停，观察视频播放器如何与 isPlaying 属性值保持同步：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState, useRef, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params">&#123; src, isPlaying &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPlaying) &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>    &#125;<br>  &#125;, [isPlaying]);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">playsInline</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isPlaying, setIsPlaying] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setIsPlaying(!isPlaying)&#125;&gt;</span><br><span class="language-xml">        &#123;isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">VideoPlayer</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isPlaying</span>=<span class="hljs-string">&#123;isPlaying&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><!--许多 Effect 也会自行“清理”。例如，与聊天服务器建立连接的 Effect 应该返回一个 cleanup 函数，告诉 React 如何断开组件与该服务器的连接：--></li></ol><h3 id="29、你可能不需要-Effect"><a href="#29、你可能不需要-Effect" class="headerlink" title="29、你可能不需要 Effect"></a>29、你可能不需要 Effect</h3><ol><li>Effect 是 React 范式中的一个逃脱方案。它们可以“逃出” React 并使组件和一些外部系统同步。如果没有涉及到外部系统（例如，需要根据一些 props 或 state 的变化来更新一个组件的 state），不应该使用 Effect。移除不必要的 Effect 可以让代码更容易理解，运行得更快，并且更少出错。</li><li>有两种常见的不必使用 Effect 的情况：<ol><li>不必为了渲染而使用 Effect 来转换数据。</li><li>不必使用 Effect 来处理用户事件。</li></ol></li><li>例如，不需要 Effect 来根据其他状态调整某些状态：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;泰勒&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;斯威夫特&#x27;</span>);<br><br>  <span class="hljs-comment">// 🔴 避免：多余的 state 和不必要的 Effect</span><br>  <span class="hljs-keyword">const</span> [fullName, setFullName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setFullName</span>(firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName);<br>  &#125;, [firstName, lastName]);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>相反，在渲染时进行尽可能多地计算：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = useState(<span class="hljs-string">&#x27;泰勒&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = useState(<span class="hljs-string">&#x27;斯威夫特&#x27;</span>);<br>  <span class="hljs-comment">// ✅ 非常好：在渲染期间进行计算</span><br>  <span class="hljs-keyword">const</span> fullName = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="30、响应式-Effect-的生命周期"><a href="#30、响应式-Effect-的生命周期" class="headerlink" title="30、响应式 Effect 的生命周期"></a>30、响应式 Effect 的生命周期</h3><ol><li>Effect 的生命周期不同于组件。组件可以挂载、更新或卸载。Effect 只能做两件事：开始同步某些东西，然后停止同步它。如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。</li></ol><h3 id="使用自定义-Hook-复用逻辑"><a href="#使用自定义-Hook-复用逻辑" class="headerlink" title="使用自定义 Hook 复用逻辑"></a>使用自定义 Hook 复用逻辑</h3><ol><li>React 有一些内置 Hook，例如 useState，useContext 和 useEffect。有时需要用途更特殊的 Hook：例如获取数据，记录用户是否在线或者连接聊天室。为了实现效果，可以根据应用需求创建自己的 Hook。</li><li>你可以创建自定义 Hooks，将它们组合在一起，在它们之间传递数据，并在组件之间重用它们。随着应用不断变大，你将减少手动编写的 Effect，因为你将能够重用已经编写的自定义 Hooks。React 社区也维护了许多优秀的自定义 Hooks。</li></ol>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac常用命令</title>
    <link href="/2023/11/22/macCommandUsed/"/>
    <url>/2023/11/22/macCommandUsed/</url>
    
    <content type="html"><![CDATA[<h3 id="1、修改文件权限"><a href="#1、修改文件权限" class="headerlink" title="1、修改文件权限"></a>1、修改文件权限</h3><p><code>sudo chmod -R 777 文件名称</code></p><h3 id="2、修改hosts"><a href="#2、修改hosts" class="headerlink" title="2、修改hosts"></a>2、修改hosts</h3><p><code>sudo vim /private/etc/hosts</code><br><code>sudo vi /etc/hosts</code></p><ol><li>sudo vi &#x2F;etc&#x2F;hosts</li><li>提示输入个人电脑密码</li><li>此时输入E，点击enter</li><li>看到hosts，此时输入i，看到命令行下面显示insert，输入自己需要修改的host</li><li>点击esc退出编辑</li><li>按住shift 和 :，输入wq保存退出</li></ol><h3 id="3、显示“隐藏文件”"><a href="#3、显示“隐藏文件”" class="headerlink" title="3、显示“隐藏文件”"></a>3、显示“隐藏文件”</h3><ol><li>局部：<br>操作快捷键 <code>command+shift+.</code></li><li>全局：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br> Mac关闭“显示隐藏文件”命令：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></li></ol><h3 id="4、查看8080端口占用情况"><a href="#4、查看8080端口占用情况" class="headerlink" title="4、查看8080端口占用情况"></a>4、查看8080端口占用情况</h3><p><code>sudo lsof -i tcp:8080 </code></p><h3 id="5、80端口转向8080"><a href="#5、80端口转向8080" class="headerlink" title="5、80端口转向8080"></a>5、80端口转向8080</h3><p><strong>（以下34配置在mac重启后需重新加载）</strong></p><ol><li><code>sudo vim /etc/pf.conf</code></li><li>在<code>rdr-anchor “com.apple/* </code>后面加上如下这一行（代表将发到80端口的数据转发到8080上,8080可以更改成自己的端口）<br><code>rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</code></li><li>重新加载配置<br><code>sudo pfctl -f /etc/pf.conf</code></li><li>启动<br><code>sudo pfctl -e</code></li></ol><h3 id="6、查看nginx运行状态"><a href="#6、查看nginx运行状态" class="headerlink" title="6、查看nginx运行状态"></a>6、查看nginx运行状态</h3><p><code>ps -ef | grep nginx</code></p><h3 id="7、查看java占用-清理占用"><a href="#7、查看java占用-清理占用" class="headerlink" title="7、查看java占用-清理占用"></a>7、查看java占用-清理占用</h3><p><code>ps -ef|grep java</code><br><code>kill -9 1234</code></p><h3 id="8、打开强制退出程序窗口"><a href="#8、打开强制退出程序窗口" class="headerlink" title="8、打开强制退出程序窗口"></a>8、打开强制退出程序窗口</h3><p><code>Command+Option+Esc</code></p>]]></content>
    
    
    <categories>
      
      <category>mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsArray</title>
    <link href="/2023/11/20/jsArray/"/>
    <url>/2023/11/20/jsArray/</url>
    
    <content type="html"><![CDATA[<h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><table><thead><tr><th>函数</th><th>锚点</th></tr></thead><tbody><tr><td><code>var arr = new Array()</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = new Array(10)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array(7)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array.of(7)</code></td><td><a href="#create">LINK</a></td></tr></tbody></table><h2 id="2、增加"><a href="#2、增加" class="headerlink" title="2、增加"></a>2、增加</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>concat()</code></td><td>合并</td><td><a href="#concat">LINK</a></td></tr><tr><td><code>unshift()</code></td><td>向开头添加</td><td><a href="#unshift">LINK</a></td></tr><tr><td><code>push()</code></td><td>向末尾添加</td><td><a href="#push">LINK</a></td></tr><tr><td><code>splice()</code></td><td>可选参数用于添加</td><td><a href="#splice">LINK</a></td></tr></tbody></table><h2 id="3、分割"><a href="#3、分割" class="headerlink" title="3、分割"></a>3、分割</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>slice()</code></td><td>切割</td><td><a href="#slice">LINK</a></td></tr></tbody></table><h2 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>splice()</code></td><td></td><td><a href="#splice">LINK</a></td></tr><tr><td><code>pop()</code></td><td></td><td><a href="#pop">LINK</a></td></tr><tr><td><code>shift()</code></td><td></td><td><a href="#shift">LINK</a></td></tr></tbody></table><h2 id="5、修改"><a href="#5、修改" class="headerlink" title="5、修改"></a>5、修改</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>constructor</code></td><td></td><td><a href="#constructor">LINK</a></td></tr><tr><td><code>prototype</code></td><td></td><td><a href="#prototype">LINK</a></td></tr><tr><td><code>length</code></td><td></td><td><a href="#length">LINK</a></td></tr><tr><td><code>valueOf()</code></td><td></td><td><a href="#valueOf">LINK</a></td></tr><tr><td><code>toString()</code></td><td></td><td><a href="#toString">LINK</a></td></tr></tbody></table><h2 id="6、查询"><a href="#6、查询" class="headerlink" title="6、查询"></a>6、查询</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>indexOf()</code></td><td></td><td><a href="#indexOf">LINK</a></td></tr><tr><td><code>lastIndexOf()</code></td><td></td><td><a href="#lastIndexOf">LINK</a></td></tr></tbody></table><h2 id="7、循环"><a href="#7、循环" class="headerlink" title="7、循环"></a>7、循环</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>forEach()</code></td><td></td><td><a href="#forEach">LINK</a></td></tr><tr><td><code>map()</code></td><td></td><td><a href="#map">LINK</a></td></tr><tr><td><code>filter()</code></td><td></td><td><a href="#filter">LINK</a></td></tr><tr><td><code>every()</code></td><td></td><td><a href="#every">LINK</a></td></tr><tr><td><code>some()</code></td><td></td><td><a href="#some">LINK</a></td></tr><tr><td><code>reduce()</code></td><td></td><td><a href="#reduce">LINK</a></td></tr><tr><td><code>reduceRight()</code></td><td></td><td><a href="#reduceRight">LINK</a></td></tr></tbody></table><h2 id="8、排序"><a href="#8、排序" class="headerlink" title="8、排序"></a>8、排序</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>sort()</code></td><td></td><td><a href="#sort">LINK</a></td></tr></tbody></table><ol><li><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a><a id="create">创建数组</a></h3><ol><li><h4 id="var-arr-new-Array"><a href="#var-arr-new-Array" class="headerlink" title="var arr &#x3D; new Array()"></a>var arr &#x3D; new Array()</h4><ol><li>创建一个空数组</li></ol></li><li><h4 id="var-arr-new-Array-10"><a href="#var-arr-new-Array-10" class="headerlink" title="var arr &#x3D; new Array(10)"></a>var arr &#x3D; new Array(10)</h4><ol><li>创建一个包含10项的数组</li></ol></li><li><h4 id="var-arr-Array-7"><a href="#var-arr-Array-7" class="headerlink" title="var arr &#x3D; Array(7)"></a>var arr &#x3D; Array(7)</h4><ol><li>创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）</li></ol></li><li><h4 id="var-arr-Array-of-7"><a href="#var-arr-Array-of-7" class="headerlink" title="var arr &#x3D; Array.of(7)"></a>var arr &#x3D; Array.of(7)</h4><ol><li>创建一个包含1个字符串7的数组</li></ol></li></ol></li><li><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ol><li>语法： <code>array.length</code></li><li>作用： 设置或返回数组中元素的数目</li></ol></li><li><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><ol><li><ol><li>向对象添加属性和方法</li></ol></li></ol></li><li><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><ol><li>返回对创建此对象的数组函数的引用</li></ol></li><li><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><ol><li>语法：<code>array.valueOf()</code></li><li>解析：返回 Array 对象的原始值。该原始值由 Array 对象派生的所有对象继承。valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。</li><li>是否改变原数组：N</li></ol></li><li><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ol><li>语法：<code>arrayObject.concat(arrayX,arrayX,......,arrayX)</code></li><li>解析：连接两个或多个数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ol><li>语法：<code>arrayObject.join(separator) /*separator-分隔符*/</code></li><li>解析：把数组中的所有元素放入一个字符串</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ol><li>语法：<code>arrayObject.reverse()</code></li><li>解析：颠倒数组中元素的顺序</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ol><li><p>语法：<code>arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。</code></p></li><li><p>解析：sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。</p></li><li><p>是否改变原数组: Y</p></li><li><p>不传参数，将不会按照数值大小排序，按照字符编码的顺序进行排序；</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;General&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-string">&#x27;John&#x27;</span>,<span class="hljs-string">&#x27;Army&#x27;</span>];<br><span class="hljs-keyword">var</span> resArr = arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr);<span class="hljs-comment">//输出   [&quot;Army&quot;, &quot;Bob&quot;, &quot;General&quot;, &quot;John&quot;,&quot;Tom&quot;]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br><span class="hljs-keyword">var</span> resArr2 = arr2.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr2);<span class="hljs-comment">//输出   [10, 111, 1899, 30, 35, 45, 50]</span><br></code></pre></td></tr></table></figure></li><li><p>传入参数，实现升序，降序；</p> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">  <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr3.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr3);<span class="hljs-comment">//输出  [10, 30, 35, 45, 50, 111, 1899]</span><br><br><span class="hljs-keyword">var</span> arr4 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr4.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> b - a;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr4);<span class="hljs-comment">//输出 [1899, 111, 50, 45, 35, 30, 10]</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的某个属性值排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml">  <span class="hljs-keyword">var</span> arr5 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10&#125;,&#123;id</span>:<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6&#125;,&#123;id</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2&#125;,&#123;id</span>:<span class="hljs-number">3</span>&#125;];<br>arr5.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr5);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2&#125;</span><br><span class="hljs-comment">//&#123;id: 3&#125;</span><br><span class="hljs-comment">//&#123;id: 5&#125;</span><br><span class="hljs-comment">//&#123;id: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的多个属性值排序，多条件排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs qml">      <span class="hljs-keyword">var</span> arr6 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">5,age</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6,age</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">9,age</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2,age</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">9</span>&#125;];<br>arr6.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.id === b.id)&#123;<span class="hljs-comment">//如果id相同，按照age的降序</span><br><span class="hljs-keyword">return</span> b.age - a.age<br>&#125;<span class="hljs-title">else</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr6);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2, age: 8&#125;</span><br><span class="hljs-comment">//&#123;id: 5, age: 4&#125;</span><br><span class="hljs-comment">//&#123;id: 6, age: 10&#125;</span><br><span class="hljs-comment">//&#123;id: 9, age: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 2&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ol><li>语法：<code>arrayObject.pop()</code></li><li>解析：删除并返回数组的最后一个元素。删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ol><li>语法：<code>arrayObject.shift()</code></li><li>解析：把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ol><li>语法：<code>arrayObject.unshift(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的开头添加一个或更多元素，并返回新的长度</li><li>返回值：arrayObject 的新长度。</li><li>是否改变原数组:</li></ol></li><li><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ol><li>语法：<code>arrayObject.push(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的末尾添加一个或多个元素，并返回新的长度。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ol><li>语法：<code>arrayObject.slice(start,end)   /*-1 指最后一个元素*/</code></li><li>解析：从已有的数组中返回选定的元素。返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</li><li>是否改变原数组: N</li></ol></li><li><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ol><li>语法：<code>arrayObject.splice(index,howmany,item1,.....,itemX)/* ary.splice(下标，删除数量，可选参数用于添加新项目)</code></li><li>解析：向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ol><li>语法：<code>array.indexOf(item,start)/* indexOf(查找的元素，可选参数规定开始检索得位置取值范围 [0-stringObject.length -1 ] )</code></li><li>解析：返回数组中某个指定的元素位置 从头到尾地检索数组</li><li>返回值：元素在数组中的位置，如果没有搜索到则返回-1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ol><li>语法：<code>stringObject.lastIndexOf(searchvalue,fromindex)</code></li><li>解析：返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索</li><li>返回值：如果要检索的字符串值没有出现，则该方法返回 -1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ol><li>语法：<code>array.toString()</code></li><li>解析：直接转为字符串，并返回</li><li>是否改变原数组:</li></ol></li><li><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ol><li>语法：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(currentValue, <span class="hljs-keyword">index</span>, arr), thisValue)<br>currentValue 当前元素<br><span class="hljs-keyword">index</span> 当前元素的索引值<br>arr 当前元素所属的数组对象<br>thisValue 可选。传递给函数的值一般用 &quot;this&quot; 值。<br>如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值<br></code></pre></td></tr></table></figure></li><li>解析：调用数组的每个元素，并将元素传递给回调函数。对于空数组是不会执行回调函数的。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ol><li>语法：<code>array.map(function(currentValue,index,arr), thisValue)同上</code></li><li>解析：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。按照原始数组元素顺序依次处理元素。不会对空数组进行检测。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ol><li>语法：<code>array.filter(function(currentValue,index,arr), thisValue)</code></li><li>解析：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。不会对空数组进行检测</li><li>返回值：没有符合条件的元素则返回空数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ol><li>语法：<code>array.every(function(currentValue,index,arr), thisValue)</code></li><li>解析：用于检测数组所有元素是否都符合指定条件。如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ol><li>语法：<code>array.some(function(currentValue,index,arr),thisValue)</code></li><li>解析：用于检测数组中的元素是否满足指定条件；会依次执行数组的每个元素；如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回false；不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ol><li>语法：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue) /initialValue 可选，传递给函数的初始值</code></li><li>解析：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。可以作为一个高阶函数，用于函数的 compose。对于空数组是不会执行回调函数。</li><li>是否改变原数组:</li></ol></li><li><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ol><li>语法：<code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>解析：功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加</li><li>是否改变原数组:</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用CSS</title>
    <link href="/2023/11/20/CSSofCommonlyUsed/"/>
    <url>/2023/11/20/CSSofCommonlyUsed/</url>
    
    <content type="html"><![CDATA[<h3 id="文字超出隐藏并显示省略号"><a href="#文字超出隐藏并显示省略号" class="headerlink" title="文字超出隐藏并显示省略号"></a>文字超出隐藏并显示省略号</h3><ol><li>单行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br><span class="hljs-attribute">white-space</span>: nowrap;      <span class="hljs-comment">/*超出的空白区域不换行*/</span><br><span class="hljs-attribute">overflow</span>: hidden;         <span class="hljs-comment">/*超出隐藏*/</span><br><span class="hljs-attribute">text-overflow</span>: ellipsis;  <span class="hljs-comment">/*文本超出显示省略号*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>两行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">display</span>: -webkit-box;             <span class="hljs-comment">/*将对象转为弹性盒模型展示*/</span><br>    -webkit-box-orient: vertical;     <span class="hljs-comment">/*设置弹性盒模型子元素的排列方式*/</span><br>    -webkit-line-clamp: <span class="hljs-number">2</span>;            <span class="hljs-comment">/*限制文本行数*/</span><br>    <span class="hljs-attribute">overflow</span>: hidden;                 <span class="hljs-comment">/*超出隐藏*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>多行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4em</span>;        <span class="hljs-comment">/*行高和height成倍数，这里以三行文本超出隐藏举例*/</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">4.2em</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">::after</span>&#123;         <span class="hljs-comment">/*若要兼容IE8需用:after*/</span><br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;...&quot;</span>;          <span class="hljs-comment">/*替换内容比较灵活*/</span><br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">right</span>:<span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">3px</span>;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;         <span class="hljs-comment">/*颜色和文字背景保持一致*/</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#fff</span>;  <span class="hljs-comment">/*边缘处理*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="滚动条样式设置"><a href="#滚动条样式设置" class="headerlink" title="滚动条样式设置"></a>滚动条样式设置</h3><ol><li>属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">::-webkit-scrollbar    //滚动条整体部分<br>::-webkit-scrollbar-button   //滚动条两端的按钮<br>::-webkit-scrollbar-track   // 外层轨道<br>::-webkit-scrollbar-track-piece    //内层轨道，滚动条中间部分（除去）<br>::-webkit-scrollbar-thumb //滚动条里面可以拖动的那个<br>::-webkit-scrollbar-corner   //边角<br>::-webkit-resizer   ///定义右下角拖动块的样式<br></code></pre></td></tr></table></figure></li><li>示例<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">//  定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸<br>&amp;::-webkit-scrollbar &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0.16rem</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0.16rem</span>;<br>    // <span class="hljs-attribute">background-color</span>: green;<br>&#125;<br><br>// 定义滚动条轨道 内阴影+圆角<br>&amp;::-webkit-scrollbar-track &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#011822</span>;<br>&#125;<br><br>// 定义滑块  内阴影+圆角<br>&amp;::-webkit-scrollbar-thumb &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0.16rem</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.08rem</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#023548</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="文字向两侧对齐"><a href="#文字向两侧对齐" class="headerlink" title="文字向两侧对齐"></a>文字向两侧对齐</h3><p><code>text-align: justify;</code></p><table><thead><tr><th>text-align</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td></td><td>start</td><td>如果内容方向是左至右，则等于 left，反之则为 right。</td></tr><tr><td></td><td>end</td><td>如果内容方向是左至右，则等于 right，反之则为 left。</td></tr><tr><td></td><td>left</td><td>行内内容向左侧边对齐。</td></tr><tr><td></td><td>right</td><td>行内内容向右侧边对齐。</td></tr><tr><td></td><td>center</td><td>行内内容居中。</td></tr><tr><td></td><td>justify</td><td>文字向两侧对齐，对最后一行无效。</td></tr><tr><td></td><td>justify-all</td><td>和 justify 一致，但是强制使最后一行两端对齐。</td></tr><tr><td></td><td>match-parent</td><td>和 inherit 类似，区别在于 start 和 end 的值根据父元素的 direction 确定，并被替换为恰当的 left 或 right 值。</td></tr></tbody></table><!--|   | <string> | 应用在单元格时，指定单元格内容相对于哪个字符对齐。|-->]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错/难题本</title>
    <link href="/2023/11/20/errorRecord/"/>
    <url>/2023/11/20/errorRecord/</url>
    
    <content type="html"><![CDATA[<h3 id="字体文件较大解决方案"><a href="#字体文件较大解决方案" class="headerlink" title="字体文件较大解决方案"></a>字体文件较大解决方案</h3><p>字体过大的话，会导致页面加载的时候，文字显示不出来，不过可以试试CSS的这个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-display</span>: swap;<br></code></pre></td></tr></table></figure><p>放的方式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">// OPPOSans<br><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&#x27;OPPOSans&#x27;</span>;<br>    <span class="hljs-attribute">font-style</span>: normal;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>    <span class="hljs-attribute">font-display</span>: swap;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OPPOSans&#x27;</span>),<br>            <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://************/fonts/OPPOSans-L.woff&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>            <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://************/fonts/OPPOSans-L.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;ttf&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置字体顺序的地方需要把新字体放在第一位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;OPPOSans&#x27;</span>,Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的加载方式是，页面加载中的时候，用默认字体进行显示，等字体加载完成后，页面字体会自动更新，并且不会阻塞页面渲染和操作，所以第二位的字体尽量找比较接近的系统字体做替代显示</p><h3 id="微信分享无图无文字情况"><a href="#微信分享无图无文字情况" class="headerlink" title="微信分享无图无文字情况"></a>微信分享无图无文字情况</h3><ol><li>已遇到情况最终问题解决方案：微信白名单ip限制 需手动配置</li></ol><h3 id="html-body设置宽高100-间距0仍有底部留白"><a href="#html-body设置宽高100-间距0仍有底部留白" class="headerlink" title="html,body设置宽高100%间距0仍有底部留白"></a>html,body设置宽高100%间距0仍有底部留白</h3><ol><li>answer：img设置display:block;font-size:0;</li></ol><h3 id="git提交之后提交记录没有绿点处理"><a href="#git提交之后提交记录没有绿点处理" class="headerlink" title="git提交之后提交记录没有绿点处理"></a>git提交之后提交记录没有绿点处理</h3><ol><li>记录原因：本地git账号和邮箱与git上不一致导致</li><li>解决：设置一致 <ol><li>查询：<ol><li><code>git config user.name</code></li><li><code>git config user.email</code></li></ol></li><li>设置：<ol><li><code>git config --global user.name yourname</code></li><li><code>git config --global user.email youremail</code></li></ol></li></ol></li></ol><h3 id="certificate-has-expired"><a href="#certificate-has-expired" class="headerlink" title="certificate has expired"></a>certificate has expired</h3><ol><li>解决执行npm(或pnpm)时报：证书过期 certificate has expired问题<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、取消ssl验证：<br> <br>npm config set strict-ssl <span class="hljs-literal">false</span><br> <br>这个方法一般就可以解决了。<br> <br><span class="hljs-number">2</span>、更换npm镜像源：<br> <br>npm config set registry http:<span class="hljs-comment">//registry.cnpmjs.org</span><br>npm config set registry http:<span class="hljs-comment">//registry.npm.taobao.org</span><br> <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>错题本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错题</tag>
      
      <tag>日常记录</tag>
      
      <tag>bug</tag>
      
      <tag>难题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>photoshopStart</title>
    <link href="/2023/11/17/photoshopStart/"/>
    <url>/2023/11/17/photoshopStart/</url>
    
    <content type="html"><![CDATA[<h3 id="认识界面"><a href="#认识界面" class="headerlink" title="认识界面"></a>认识界面</h3><ol><li><h4 id="油漆桶（更改背景色）"><a href="#油漆桶（更改背景色）" class="headerlink" title="油漆桶（更改背景色）"></a>油漆桶（更改背景色）</h4><ol><li><p>上面的代表前景色 下面的是背景色 左上角可重置颜色 右上角可颜色互换</p><ol><li><img src="/img/ps/17002063180368.jpg"></li><li>点击背景色弹出拾色器窗口，可以从中选择</li></ol></li><li><p>选好颜色后shift+左键渲染工作面</p><ol><li><img src="/img/ps/17002045896302.jpg"></li></ol></li><li><p>也可右键点击展开选择预设置颜色</p><ol><li><img src="/img/ps/17002046915979.jpg"></li></ol></li></ol></li><li><h4 id="复位基本功能（一键重置）"><a href="#复位基本功能（一键重置）" class="headerlink" title="复位基本功能（一键重置）"></a>复位基本功能（一键重置）</h4><ol><li>各种操作区域操作乱序 在 <strong>窗口-&gt;工作区-&gt;复位基本功能</strong> 重置</li></ol></li></ol><h3 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h3><ol><li>菜单栏-文件-新建 右边修改初始配置参数<ol><li><img src="/img/ps/17002057788246.jpg"></li></ol></li></ol><h3 id="图像大小"><a href="#图像大小" class="headerlink" title="图像大小"></a>图像大小</h3><ol><li>再次修改文档参数 图像-图像大小<ol><li>快捷键：win：<code>ctrl+alt+i</code> mac:<code>cmd+option+i</code></li><li><img src="/img/ps/17002071119831.jpg"></li></ol></li></ol><h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><ol><li>直接保存（改变源文件）</li><li>另存为</li></ol><h3 id="性能配置-开工前的准备工作"><a href="#性能配置-开工前的准备工作" class="headerlink" title="性能配置-开工前的准备工作"></a>性能配置-开工前的准备工作</h3><ol><li>首选项 <ol><li>快捷键win<code>ctrl+k</code> mac<code>cmd+k</code></li><li>暂存盘<ol><li><img src="/img/ps/17002077698935.jpg"></li></ol></li><li>历史记录<ol><li>可回到做错前的次数 菜单窗口-历史记录</li><li><img src="/img/ps/17002116764872.jpg"></li></ol></li><li>自动保存设置<ol><li><img src="/img/ps/17002118672543.jpg"></li></ol></li><li>快捷键设置<ol><li>菜单编辑-键盘快捷键</li></ol></li></ol></li></ol><h3 id="图层知识"><a href="#图层知识" class="headerlink" title="图层知识"></a>图层知识</h3><ol><li>位置<ol><li>菜单图层</li><li>面板栏的图层面板（窗口-图层）</li></ol></li><li>创建普通图层<ol><li>点击添加按钮（新建图层双击标题区域即可修改名称，增删改查也在此窗口操作）<ol><li><img src="/img/ps/17002125816426.jpg"></li></ol></li><li>option+上面按钮即可唤出<ol><li><img src="/img/ps/17002126818904.jpg"></li></ol></li></ol></li></ol><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><ol><li>查看画面的方式<ol><li>左边抓手工具（按住空格键不松）</li><li>缩放工具（放大镜图标）</li><li>旋转工具（在抓手工具内）</li></ol></li></ol><!--### 移动工具-->]]></content>
    
    
    <categories>
      
      <category>photoShop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown基础语法</title>
    <link href="/2023/11/16/markdownGrammar/"/>
    <url>/2023/11/16/markdownGrammar/</url>
    
    <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/">Markdown 官方教程</a></p><!--* <a href="#preface">图片语法</a>--><ol><li><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><ol><li>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。例如，添加三个 <code>#</code> 表示创建一个三级标题 (<code>&lt;h3&gt;</code>)<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"># h1<br>######  h6<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="2、段落"><a href="#2、段落" class="headerlink" title="2、段落"></a>2、段落</h3><ol><li><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ol><li>段落的换行是使用两个以上空格加上回车。也可以在段落后面使用一个空行来表示重新开始一个段落。</li></ol></li><li><h4 id="加粗倾斜"><a href="#加粗倾斜" class="headerlink" title="加粗倾斜"></a>加粗倾斜</h4></li></ol> <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><p> <em>斜体文本</em><br> <em>斜体文本</em><br> <strong>粗体文本</strong><br> <strong>粗体文本</strong><br> <em><strong>粗斜体文本</strong></em><br> <em><strong>粗斜体文本</strong></em></p><ol start="3"><li><h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4></li></ol> <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">***</span><br><span class="hljs-comment">* * *</span><br><span class="hljs-comment">*****</span><br>- - -<br>----------<br></code></pre></td></tr></table></figure><hr><hr><hr><hr><hr><ol start="4"><li><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4></li></ol> <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~删除线~~<br></code></pre></td></tr></table></figure><p> <del>删除线</del></p><ol start="5"><li><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4></li></ol> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <u>带下划线文本</u></p></li></ol><!--    6. #### 脚注    生成一个脚注1[^footnote].            [^footnote]: 这里是 **脚注** 的 *内容*.        生成一个脚注2[^foot].            [^foot]:这里是**脚注2**的*内容*.--><ol><li><h3 id="3、换行"><a href="#3、换行" class="headerlink" title="3、换行"></a>3、换行</h3><ol><li>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)</li></ol></li><li><h3 id="4、区块"><a href="#4、区块" class="headerlink" title="4、区块"></a>4、区块</h3><ol><li>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">同层引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">同层引用</span><br></code></pre></td></tr></table></figure><blockquote><p>区块引用<br>同层引用<br>同层引用</p></blockquote></li><li>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">最外层</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></li><li>区块中使用列表 <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块中使用列表</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote></li><li>列表中使用区块 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-quote">&gt; 学习</span><br><span class="hljs-quote">&gt; 学而时习之</span><br><span class="hljs-bullet">*</span> 第二项<br></code></pre></td></tr></table></figure></li></ol><ul><li>第一项<blockquote><p>学习<br>学而时习之</p></blockquote></li><li>第二项</li></ul></li><li><h3 id="5、列表"><a href="#5、列表" class="headerlink" title="5、列表"></a>5、列表</h3><ol><li><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></li><li><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li></ol></li><li><h3 id="6、代码"><a href="#6、代码" class="headerlink" title="6、代码"></a>6、代码</h3><ol><li>要将单词或短语表示为代码，请将其包裹在<strong>反引号 (&#96;&#96;)</strong> 中。<ol><li><code>code part</code></li></ol></li><li>转义反引号 <ol><li>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在 <strong>双反引号(&#96;&#96;)</strong> 中。<ol><li><code>Use `code` in your Markdown file.</code></li></ol></li></ol></li><li>代码块<ol><li><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符(<strong>Tab键</strong>)。 也可以用 <code>```</code> 包裹一段代码，并指定一种语言（也可以不指定）</p></li><li><p><strong>(<code>```内容```</code>)</strong><br> <img src="/img/js/17004620062132.jpg"></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>在使用该语法时开头之前必须要有一行空行，若要标记语言则在开头语法加一个空格然后声明语言类型(具体如图所示)，既然开头有要求自然结束也有要求的。结束时切忌不要在结束标签后加空格，否则该标签未关闭。<strong>关闭则直接回车换两行即可</strong>。</p></li></ol></li></ol></li><li><h3 id="7、分割线"><a href="#7、分割线" class="headerlink" title="7、分割线"></a>7、分割线</h3><ol><li>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。<ol><li><hr><ol><li><code>***</code></li></ol></li><li><hr><ol><li><code>---</code></li></ol></li><li><hr><ol><li><code>___</code></li></ol></li></ol></li></ol></li><li><h3 id="8、链接"><a href="#8、链接" class="headerlink" title="8、链接"></a>8、链接</h3><ol><li><strong>链接文本</strong>放在中括号内，链接地址放在后面的括号中，链接title可选。<ol><li><code> [Markdown语法](https://markdown.com.cn)。</code><br> <a href="https://markdown.com.cn/">Markdown语法</a>。</li></ol></li><li>链接title是当<strong>鼠标悬停在链接上时会出现的文字</strong>，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。<br> 1. <code>[Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。</code><br> <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</li></ol></li><li><h3 id="9、图片"><a href="#9、图片" class="headerlink" title="9、图片"></a>9、<a id="preface">图片</a></h3><ol><li>要<strong>添加图像</strong>，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![这是图片](https:<span class="hljs-regexp">//m</span>arkdown.com.cn<span class="hljs-regexp">/assets/img</span>/philly-magic-garden.<span class="hljs-number">9</span>c0b4415.jpg <span class="hljs-string">&quot;Magic Gardens&quot;</span>) <br></code></pre></td></tr></table></figure> <img src="https://markdown.com.cn/assets/img/philly-magic-garden.9c0b4415.jpg" alt="这是图片" title="Magic Gardens"></li><li>给<strong>图片增加链接</strong>，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[![沙漠中的岩石图片]<span class="hljs-params">(https://tse3-mm.cn.bing.net/th/id/OIP-C.ECTYUcRzB9FMRqYOYvZnSQHaEK?<span class="hljs-attr">w</span>=308&amp;<span class="hljs-attr">h</span>=180&amp;<span class="hljs-attr">c</span>=7&amp;<span class="hljs-attr">r</span>=0&amp;<span class="hljs-attr">o</span>=5&amp;<span class="hljs-attr">dpr</span>=2&amp;<span class="hljs-attr">pid</span>=1.7 &quot;Shiprock&quot;)</span>]<span class="hljs-params">(https://markdown.com.cn)</span><br></code></pre></td></tr></table></figure> <a href="https://markdown.com.cn/"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.ECTYUcRzB9FMRqYOYvZnSQHaEK?w=308&h=180&c=7&r=0&o=5&dpr=2&pid=1.7" alt="沙漠中的岩石图片" title="Shiprock"></a></li></ol></li><li><h3 id="10、表格"><a href="#10、表格" class="headerlink" title="10、表格"></a>10、表格</h3></li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐示例</th><th align="right">右对齐示例</th><th align="center">居中对齐示例</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><pre><code class="hljs">用html代码处理    &lt;tr&gt;    &lt;th&gt;属性&lt;/th&gt;    &lt;th&gt;属性值&lt;/th&gt;    &lt;th&gt;描述&lt;/th&gt;  &lt;/tr &gt;&lt;tr &gt;    &lt;td rowspan=&quot;9&quot;&gt;type&lt;/td&gt;    &lt;td&gt;text&lt;/td&gt;    &lt;td&gt;单行文本输入框&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;password&lt;/td&gt;    &lt;td&gt;密码输入框&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;radio&lt;/td&gt;    &lt;td&gt;单选按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;CheckBox&lt;/td&gt;    &lt;td&gt;复选按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;button&lt;/td&gt;    &lt;td&gt;普通按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;submit&lt;/td&gt;    &lt;td&gt;提交按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;reset&lt;/td&gt;    &lt;td&gt;重置按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;image&lt;/td&gt;    &lt;td&gt;图像形式的提交按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;file&lt;/td&gt;    &lt;td&gt;文件域&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;name&lt;/td&gt;    &lt;td&gt;用户自定义&lt;/td&gt;    &lt;td&gt;控件名称&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;value&lt;/td&gt;    &lt;td &gt;用户自定义&lt;/td&gt;    &lt;td &gt;默认文本值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;size&lt;/td&gt;    &lt;td &gt;正整数&lt;/td&gt;    &lt;td &gt;控件在页面中的显示宽度&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;checked&lt;/td&gt;    &lt;td &gt;checked&lt;/td&gt;    &lt;td &gt;定义选择控件默认被选中项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;maxlength&lt;/td&gt;    &lt;td &gt;正整数&lt;/td&gt;    &lt;td &gt;控件允许输入的最多字符&lt;/td&gt;&lt;/tr&gt;</code></pre></table><table>    <tr>        <th>属性</th>        <th>属性值</th>        <th>描述</th>      </tr >    <tr >        <td rowspan="9">type</td>        <td>text</td>        <td>单行文本输入框</td>    </tr>    <tr>        <td>password</td>        <td>密码输入框</td>    </tr>    <tr>        <td>radio</td>        <td>单选按钮</td>    </tr>    <tr>        <td>CheckBox</td>        <td>复选按钮</td>    </tr>    <tr><td>button</td>        <td>普通按钮</td>    </tr>    <tr>        <td>submit</td>        <td>提交按钮</td>    </tr>    <tr>        <td>reset</td>        <td>重置按钮</td>    </tr>    <tr>        <td>image</td>        <td>图像形式的提交按钮</td>    </tr>    <tr>        <td >file</td>        <td>文件域</td>    </tr>    <tr>        <td >name</td>        <td>用户自定义</td>        <td>控件名称</td>    </tr>    <tr>        <td >value</td>        <td >用户自定义</td>        <td >默认文本值</td>    </tr>    <tr>        <td >size</td>        <td >正整数</td>        <td >控件在页面中的显示宽度</td>    </tr>    <tr>        <td >checked</td>        <td >checked</td>        <td >定义选择控件默认被选中项</td>    </tr>    <tr>        <td >maxlength</td>        <td >正整数</td>        <td >控件允许输入的最多字符</td>    </tr></table><h3 id="11、锚点"><a href="#11、锚点" class="headerlink" title="11、锚点"></a>11、锚点</h3><ol><li>使用a标签 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">第一步：添加链接<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#preface&quot;</span>&gt;</span>前言<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>第二步：添加锚点<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preface&quot;</span>&gt;</span>前言<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用md语法 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一步：添加链接[测试2](<span class="hljs-comment">#test2)</span><br>第二步：添加锚点&lt;a <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;测试2&lt;/a&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="12、更改字体大小、颜色、更改字体"><a href="#12、更改字体大小、颜色、更改字体" class="headerlink" title="12、更改字体大小、颜色、更改字体"></a>12、更改字体大小、颜色、更改字体</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;font <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;逐浪立楷&quot;</span> <span class="hljs-attribute">color</span>=green <span class="hljs-attribute">size</span>=10&gt;我是逐浪立楷，绿色，尺寸为5&lt;/font&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>markDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>md</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的安装及git部署</title>
    <link href="/2023/11/15/hexoStall/"/>
    <url>/2023/11/15/hexoStall/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h3><ol><li>node</li><li>git</li></ol><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ol><li>新建一个文件夹用来存放 Hexo 的程序文件</li><li><code>npm install -g hexo-cli</code><ol><li>mac需要管理员权限（sudo）</li></ol></li><li>初始化&amp;本地预览<ol><li><code>hexo init</code> #初始化</li><li><code>npm install</code> #安装组件</li><li><code>hexo g</code> #生成页面</li><li><code>hexo s</code> #启动预览</li></ol></li></ol><h3 id="部署至github"><a href="#部署至github" class="headerlink" title="部署至github"></a>部署至github</h3><ol><li><p>创建github page 仓库</p><ol><li>Repository name 中输入 用户名 <strong>.github.io</strong></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li><li>-创建后默认自动启用 HTTPS，博客地址为：https:&#x2F;&#x2F;用户名.github.io</li></ol></li><li><p>安装hexo-deployer-git</p><ol><li><code>npm install hexo-deployer-git --save</code></li></ol></li><li><p>修改 _config.yml 文件末尾的 Deployment 部分</p> <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:用户名/用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> master <br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>用户名一致，都为git账户名称</strong></p></li><li><p><strong>branch为上传分支，git新建项目时默认为main需切换分支或改为main</strong></p><ol><li><img src="/img/hexo/17001017178769.jpg"></li></ol></li><li><p><strong>确认git发布分支是否为当前上传分支，不是则切换</strong></p><ol><li><img src="/img/hexo/17001017531171.jpg"></li></ol></li></ol></li><li><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages,访问 GitHub 域名 https:&#x2F;&#x2F;用户名.github.io</p></li></ol><h3 id="hexo基础"><a href="#hexo基础" class="headerlink" title="hexo基础"></a>hexo基础</h3><ol><li>hexo基础命令<ol><li><code>hexo init [folder]</code> <ol><li>#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</li></ol></li><li><strong><code>hexo new [layout] &lt;title&gt;</code></strong><ol><li>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</li><li><code>hexo new &quot;post title with &quot;whitespace&quot;</code></li></ol></li><li><code>hexo generate</code><ol><li>生成静态文件。</li><li>简写 <strong><code>hexo g</code></strong></li></ol></li><li><code>hexo publish [layout] &lt;filename&gt;</code> <ol><li>#发表草稿</li></ol></li><li><code>hexo server</code><ol><li>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></li><li><code>-p, --port</code>重设端口</li><li><code>-s, --static</code>只使用静态文件</li><li><code>-l, --log</code>启动日记记录，使用覆盖记录格式</li><li>简写 <strong><code>hexo s</code></strong></li></ol></li><li><code>hexo deploy</code>  <ol><li>部署网站。简写 <strong><code>hexo d</code></strong></li><li><strong><code>hexo g -d</code></strong> 部署之前预先生成静态文件</li></ol></li><li><strong><code>hexo clean</code></strong> <ol><li>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</li></ol></li><li>hexo 更换网站小图标 <ol><li>配置文件中 <strong><code>favicon: /img/index/bk.png </code></strong></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
