<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JsEventLoop</title>
    <link href="/2024/03/07/JsEventLoop/"/>
    <url>/2024/03/07/JsEventLoop/</url>
    
    <content type="html"><![CDATA[<ol><li>经典面试题<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    resolve()<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>上述最终执行结果为<code>1 3 5 4 2</code> Promise函数是同步执行，.then方法为异步执行</li><li>JavaScript是单线程<ol><li>JavaScript是一种单线程的编程语言，意思就是同一时间段只能做一件事，所有任务都需要排队依次完成；</li><li>为什么JavaScript不能有多个线程呢？<ol><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准；</li></ol></li></ol></li><li>同步任务和异步任务<ol><li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li><li>JavaScript开发人员意识到，为了不影响主线程正常运行，就把那些耗时的时间（比如定时器，Ajax操作从网络读取数据等）任务挂起来，依次的放进一个任务队列中，等主线程的任务执行完毕后，再回过来去继续执行队列中的任务；</li><li>于是，任务就可以分成两种：<ol><li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li><li>异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ol></li></ol></li><li>event loop（事件循环）<ol><li>event loop（事件循环）机制 过程<ol><li>所有同步任务都在主线程上执行，形成一个执行栈（调用栈）；</li><li>主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中（队列遵循先进先出得原则）</li><li>一旦主线程的栈中的所有同步任务执行完毕后，调用栈为空时系统就会将队列中的回调函数依次压入调用栈中执行，当调用栈为空时，仍然会不断循环检测任务队列中是否有代码需要执行；</li></ol></li></ol></li><li>宏任务和微任务<ol><li>macrotask（宏任务） 和 microtask（微任务）</li><li>浏览器中常用的宏任务和微任务：<table><thead><tr><th>名称</th><th>事件</th></tr></thead><tbody><tr><td>宏任务</td><td>setTimeout 、setInterval 、UI rendering</td></tr><tr><td>微任务</td><td>promise 、requestAnimationFrame</td></tr></tbody></table></li><li>异步任务既然分为宏任务和微任务，则队列肯定也分为宏任务队列和微任务队列；</li><li>当宏任务和微任务都处于 任务队列（Task Queue） 中时，微任务的优先级大于宏任务，即先将微任务执行完，再执行宏任务；</li><li>执行机制过程如下：<ol><li>第一步： 主线程执行同步任务的同时，把一些异步任务放入‘任务队列’（task queue）中，等待主线程的调用栈为空时，再依次从队列出去任务去执行；</li><li>第二步：检测任务队列中的微队列是否为空，若不为空，则取出一个微任务入栈执行；然后继续执行第2步；如果微队列为空，则开始取出宏队列中的一个宏任务执行；</li><li>第三步：执行完宏队列中的一个宏任务后，会继续检测微队列是否为空，如果有新插入的任务，这继续执行第二步；如果微队列为空，则继续执行宏队列中的下一个任务，然后再继续循环执行第三步；</li></ol></li></ol></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  Promise.resole().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>  &#125;)<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    resolve()<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure><p>结果为 35412    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue nextTick 原理</title>
    <link href="/2024/03/06/VueNextTick/"/>
    <url>/2024/03/06/VueNextTick/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7226210789376065594">资料一</a></p><ol><li>作用<ol><li>无论是在 Vue2 还是 Vue3 中，nextTick 都是用来处理 DOM 更新完毕后执行回调函数的方法。</li></ol></li><li>原理<ol><li><strong>Vue2 中的 nextTick</strong><ol><li>在 Vue2 中，nextTick 的实现基于浏览器的异步任务队列和微任务队列。</li><li><strong>异步任务队列</strong><ol><li>在浏览器中，每个宏任务结束后会检查微任务队列，如果有任务则依次执行。当所有微任务执行完成后，才会执行下一个宏任务。因此可以通过将任务作为微任务添加到微任务队列中，来确保任务在所有宏任务执行完毕后立即执行。</li><li>而使用 setTimeout 可以将任务添加到异步任务队列中，在下一轮事件循环中执行。</li><li>在 Vue2 中，如果没有指定执行环境，则会优先使用 Promise.then &#x2F; MutationObserver，否则使用 setTimeout。</li></ol></li><li><strong>宏任务和微任务</strong><ol><li>在 Vue2 中，可以通过设置 useMacroTask 来使 nextTick 方法使用宏任务或者微任务。</li><li>Vue2 中默认使用微任务，在没有原生 Promise 和 MutationObserver 的情况下，才会改用 setTimeout。</li></ol></li><li>总结<ol><li>在 Vue2 中，nextTick 的实现原理基于浏览器的异步任务队列和微任务队列。Vue2 默认使用微任务，在没有原生 Promise 和 MutationObserver 的情况下才会改用 setTimeout。</li></ol></li></ol></li><li><strong>Vue3 中的 nextTick</strong><ol><li>在 Vue3 中，nextTick 的实现有了较大变化，主要是为了解决浏览器对 Promise 的缺陷和问题。</li><li><strong>Promise 在浏览器中的问题</strong><ol><li>在浏览器中，Promise 有一个缺陷：如果 Promise 在当前事件循环中被解决，那么在 then 回调函数之前添加的任务将不能在同一个任务中执行。</li><li>这是因为 Promise 虽然是微任务，但是需要等到当前宏任务结束才能执行。</li></ol></li><li><strong>Vue3 中解决 Promise 缺陷的方法</strong><ol><li>在 Vue3 中，通过使用 MutationObserver 和 Promise.resolve().then() 来解决 Promise 在浏览器中的缺陷。</li><li>在 Vue3 中，nextTick 的实现原理基于MutationObserver 和 Promise.resolve().then()，通过 MutationObserver 监测 DOM 变化，在下一个微任务中执行回调函数。</li><li>如果当前浏览器不支持原生 Promise，则使用 setTimeout 来模拟 Promise 的行为，并在回调函数执行前添加一个空的定时器来强制推迟执行（解决 iOS 中 setTimeout 在非激活标签页中的问题）。</li><li>如果需要等待所有回调函数执行完成，则可以通过返回一个 Promise 对象来实现。</li></ol></li><li>总结<ol><li>在 Vue3 中，nextTick 的实现原理基于 MutationObserver 和 Promise.resolve().then()。如果浏览器不支持原生 Promise，则使用 setTimeout 来模拟 Promise 的行为，并在回调函数执行前添加一个空的定时器来强制推迟执行。</li></ol></li></ol></li></ol></li><li>结论<ol><li>无论是在 Vue2 还是 Vue3 中，nextTick 都是用来处理 DOM 更新完毕后执行回调函数的方法。</li><li><strong>在 Vue2 中，nextTick 的实现基于浏览器的异步任务队列和微任务队列</strong></li><li><strong>Vue3 中，为了解决浏览器对 Promise 的缺陷和问题，使用 MutationObserver 和 Promise.resolve().then() 来实现</strong></li><li><strong>Vue3 中的 nextTick 方法也支持返回 Promise 对象，方便等待所有回调函数执行完成后再进行下一步操作。</strong></li><li>注意<ol><li>尽管 Vue3 中使用了 MutationObserver 和 Promise.resolve().then() 来解决 Promise 在浏览器中的缺陷，但在某些情况下（例如非激活标签页中），仍然可能会出现问题。因此，在实际使用中，还需要根据具体情况选择合适的方案。</li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件通讯</title>
    <link href="/2024/03/06/VueComponmentCommmunication/"/>
    <url>/2024/03/06/VueComponmentCommmunication/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zjjcchina/article/details/122357661">资料一</a></p><ol><li>vue3组件通信方式<ol><li><a href="#props"><strong>props</strong></a>  父传子</li><li><a href="#emit"><strong>$emit</strong></a>   子传父</li><li><a href="#expose/ref"><strong>expose&#x2F;ref</strong></a>       父用子</li><li><a href="#attrs"><strong>attrs</strong></a>  父传子</li><li><a href="#v-model"><strong>v-model</strong></a> 父传子</li><li><a href="#provide/inject"><strong>provide&#x2F;inject</strong></a>  父传子的子</li><li><a href="#Vuex"><strong>Vuex</strong></a> 跨组件</li><li><a href="#mitt"><strong>mitt</strong></a> 跨组件</li></ol></li><li>Vue2组件通信方式<ol><li><strong>props</strong> 父传子</li><li><strong>.sync</strong> 父传子<ol><li>子组件接收到数据后可以直接修改，并且会同时修改父组件的数据</li></ol></li><li><strong>v-model</strong>  父传子<ol><li>和 .sync 类似，可以实现将父组件传给子组件的数据为双向绑定，子组件通过 $emit 修改父组件的数据</li></ol></li><li><strong>ref</strong> 父用子<ol><li>ref 如果在普通的DOM元素上，引用指向的就是该DOM元素;</li><li>如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 ref 主动获取子组件的属性或者调用子组件的方法</li></ol></li><li><strong>$emit&#x2F;v-on</strong> 子传父</li><li><strong>$attrs&#x2F;$listeners</strong> 父传孙<ol><li>$attrs：包含父作用域里除 class 和 style 除外的非 props 属性集合。通过 this.</li><li>$listeners：包含父作用域里 .native 除外的监听事件集合。如果还要继续传给子组件内部的其他组件，就可以通过 v-on&#x3D;”$linteners”</li></ol></li><li><strong>$children&#x2F;$parent</strong> 父子相互获取</li><li><strong>provide&#x2F;inject</strong> 父传孙</li><li><strong>EventBus</strong> 跨组件</li><li><strong>Vuex</strong> 跨组件</li><li><strong>$root</strong> <code>$root</code>可以拿到 App.vue 里的数据和方法</li><li><strong>slot</strong><ol><li>就是把子组件的数据通过插槽的方式传给父组件使用，然后再插回来<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// Child.vue<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>export <span class="hljs-keyword">default</span>&#123;<br>    data()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            user:&#123;<span class="hljs-built_in"> name</span>:<span class="hljs-string">&quot;沐华&quot;</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>// Parent.vue<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">            </span><span class="language-xquery">&#123;&#123; slotProps.user<span class="hljs-built_in">.name</span> &#125;</span><span class="language-xml">&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><a id="props"><strong>props</strong> </a>父组件-&gt;子组件<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// Parent.vue 传送</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:msg2</span>=<span class="hljs-string">&quot;msg2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, reactive &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> msg2 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;这是传给子组件的信息2&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 或者复杂类型</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> msg2 = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&quot;这是传级子组件的信息2&quot;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// Child.vue 接收</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 不需要引入 直接使用</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// import </span></span></span><span class="hljs-template-variable">&#123; defineProps &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        // 写法一</span><br><span class="hljs-template-variable">        msg2: String</span><br><span class="hljs-template-variable">        // 写法二</span><br><span class="hljs-template-variable">        msg2:&#123;</span><br><span class="hljs-template-variable">            type:String,</span><br><span class="hljs-template-variable">            <span class="hljs-keyword">default</span>:&quot;&quot;</span><br><span class="hljs-template-variable">        &#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props) <span class="hljs-comment">// </span></span></span><span class="hljs-template-variable">&#123; msg2:&quot;这是传级子组件的信息2&quot; &#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><a id="emit"><strong>$emit</strong> </a>子组件-&gt;父组件<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// Child.vue 派发</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    // 写法一</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;emit(&#x27;myClick&#x27;)&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">buttom</span>&gt;</span></span><br><span class="language-xml">    // 写法二</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">buttom</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法一 适用于Vue3.2版本 不需要引入</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// import </span></span></span><span class="hljs-template-variable">&#123; defineEmits &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 对应写法一</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;myClick&quot;</span>,<span class="hljs-string">&quot;myClick2&quot;</span>])</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 对应写法二</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>)=&gt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        emit(&quot;myClick&quot;, &quot;这是发送给父组件的信息&quot;)</span><br><span class="hljs-template-variable">    &#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法二 不适用于 Vue3.2版本，该版本 useContext()已废弃</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; useContext &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> </span></span><span class="hljs-template-variable">&#123; emit &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="hljs-title function_">useContext</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>)=&gt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        emit(&quot;myClick&quot;, &quot;这是发送给父组件的信息&quot;)</span><br><span class="hljs-template-variable">    &#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// Parent.vue 响应</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">myClick</span>=<span class="hljs-string">&quot;onMyClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onMyClick</span> = (<span class="hljs-params">msg</span>) =&gt; </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        console.log(msg) // 这是父组件收到的信息</span><br><span class="hljs-template-variable">    &#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><a id="expose/ref"><strong>expose &#x2F; ref</strong></a> 父组件获取子组件的属性或者调用子组件方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml">// Child.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 方法一 不适用于Vue3.2版本，该版本 useContext()已废弃</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">useContext</span>()</span><br><span class="language-javascript">    <span class="hljs-comment">// 对外暴露属性方法等都可以</span></span><br><span class="language-javascript">    ctx.<span class="hljs-title function_">expose</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">childName</span>: <span class="hljs-string">&quot;这是子组件的属性&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">someMethod</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是子组件的方法&quot;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 方法二 适用于Vue3.2版本, 不需要引入</span></span><br><span class="language-javascript">    <span class="hljs-comment">// import &#123; defineExpose &#125; from &quot;vue&quot;</span></span><br><span class="language-javascript">    <span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">childName</span>: <span class="hljs-string">&quot;这是子组件的属性&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">someMethod</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是子组件的方法&quot;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <br>// Parent.vue  注意 ref=&quot;comp&quot;<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;comp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handlerClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> comp = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlerClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(comp.<span class="hljs-property">value</span>.<span class="hljs-property">childName</span>) <span class="hljs-comment">// 获取子组件对外暴露的属性</span></span><br><span class="language-javascript">        comp.<span class="hljs-property">value</span>.<span class="hljs-title function_">someMethod</span>() <span class="hljs-comment">// 调用子组件对外暴露的方法</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><a id="attrs"><strong>attrs</strong></a> 包含父作用域里除 class 和 style 除外的非 props 属性集合<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// Parent.vue 传送</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:msg1</span>=<span class="hljs-string">&quot;msg1&quot;</span> <span class="hljs-attr">:msg2</span>=<span class="hljs-string">&quot;msg2&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;3333&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, reactive &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> msg1 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;1111&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> msg2 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;2222&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// Child.vue 接收</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; defineProps, useContext, useAttrs &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3.2版本不需要引入 defineProps，直接用</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        msg1: String</span><br><span class="hljs-template-variable">    &#125;</span><span class="language-xml"><span class="language-javascript">)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法一 不适用于 Vue3.2版本，该版本 useContext()已废弃</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">useContext</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 如果没有用 props 接收 msg1 的话就是 </span></span></span><span class="hljs-template-variable">&#123; msg1: &quot;1111&quot;, msg2:&quot;2222&quot;, title: &quot;3333&quot; &#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">attrs</span>) <span class="hljs-comment">// </span></span></span><span class="hljs-template-variable">&#123; msg2:&quot;2222&quot;, title: &quot;3333&quot; &#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法二 适用于 Vue3.2版本</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> attrs = <span class="hljs-title function_">useAttrs</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrs) <span class="hljs-comment">// </span></span></span><span class="hljs-template-variable">&#123; msg2:&quot;2222&quot;, title: &quot;3333&quot; &#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><a id="v-model">v-model</a>可以支持多个数据双向绑定<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// Parent.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-model:key</span>=<span class="hljs-string">&quot;key&quot;</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, reactive &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;1111&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;2222&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// Child.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handlerClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法一  不适用于 Vue3.2版本，该版本 useContext()已废弃</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; useContext &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> </span></span><span class="hljs-template-variable">&#123; emit &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="hljs-title function_">useContext</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法二 适用于 Vue3.2版本，不需要引入</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// import </span></span></span><span class="hljs-template-variable">&#123; defineEmits &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>])</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 用法</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlerClick</span> = (<span class="hljs-params"></span>) =&gt; </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        emit(&quot;update:key&quot;, &quot;新的key&quot;)</span><br><span class="hljs-template-variable">        emit(&quot;update:value&quot;, &quot;新的value&quot;)</span><br><span class="hljs-template-variable">    &#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><a id="provide/inject"><strong>provide&#x2F;inject</strong></a>依赖注入<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// Parent.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; provide &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;沐华&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// Child.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; inject &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;name&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name) <span class="hljs-comment">// 沐华</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">复制代码</span><br></code></pre></td></tr></table></figure></li><li><a id="Vuex">Vuex</a><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pf">// store/index.js<br>import &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span><br>export <span class="hljs-keyword">default</span> createStore(&#123;<br>    <span class="hljs-keyword">state</span>:&#123; count: <span class="hljs-number">1</span> &#125;,<br>    getters:&#123;<br>        getCount: <span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count<br>    &#125;,<br>    mutations:&#123;<br>        add(<span class="hljs-keyword">state</span>)&#123;<br>            <span class="hljs-keyword">state</span>.count++<br>        &#125;<br>    &#125;<br>&#125;)<br> <br>// main.js<br>import &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br>import App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span><br>import store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span><br>createApp(App).use(store).mount(<span class="hljs-string">&quot;#app&quot;</span>)<br> <br>// Page.vue<br>// 方法一 直接使用<br><span class="hljs-variable">&lt;template&gt;</span><br>    <span class="hljs-variable">&lt;div&gt;</span>&#123;&#123; <span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.count &#125;&#125;&lt;/div&gt;<br>    <span class="hljs-variable">&lt;button @click=&quot;$store.commit(&#x27;add&#x27;)&quot;&gt;</span>按钮&lt;/button&gt;<br>&lt;/template&gt;<br> <br>// 方法二 获取<br><span class="hljs-variable">&lt;script setup&gt;</span><br>    import &#123; useStore, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span><br>    <span class="hljs-keyword">const</span> store = useStore()<br>    console.<span class="hljs-keyword">log</span>(store.<span class="hljs-keyword">state</span>.count) // <span class="hljs-number">1</span><br> <br>    <span class="hljs-keyword">const</span> count = computed(()=&gt;store.<span class="hljs-keyword">state</span>.count) // 响应式，会随着vuex数据改变而改变<br>    console.<span class="hljs-keyword">log</span>(count) // <span class="hljs-number">1</span> <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><a id="mitt"><strong>mitt</strong></a><ol><li>Vue3 中没有了 EventBus 跨组件通信，但是现在有了一个替代的方案 mitt.js，原理还是 EventBus</li><li>先安装 <code>npm i mitt -S</code></li><li>封装  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mitt.<span class="hljs-property">js</span><br><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mitt&#x27;</span><br><span class="hljs-keyword">const</span> mitt = <span class="hljs-title function_">mitt</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mitt<br></code></pre></td></tr></table></figure></li><li>通信 <figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// 组件 A</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mitt&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    mitt.emit(&#x27;handleChange&#x27;)</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml">// 组件 B </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mitt&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; onUnmounted &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">someMethed</span> = (<span class="hljs-params"></span>) =&gt; </span></span><span class="hljs-template-variable">&#123; ... &#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">mitt.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;handleChange&#x27;</span>,someMethed)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">()=&gt;</span></span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    mitt.off(&#x27;handleChange&#x27;,someMethed)</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">)</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2024/03/04/httpInterviewQuestion/"/>
    <url>/2024/03/04/httpInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45819386/article/details/123219420">资料一</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">http简介</a></li><li><a href="#question2">http工作原理</a></li><li><a href="#question3">http优缺点</a></li><li><a href="#question4">请求类型get和post区别</a></li><li><a href="#question5">http和https区别</a></li><li><a href="#question6">常见http状态码</a></li><li><a href="#question7">HTTP常见的字段有哪些？</a></li><li>三次握手四次挥手</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">HTTP 简介：</a><ol><li>HTTP 协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议；</li><li>HTTP 是一个基于TCP&#x2F;IP通信协议来传递数据（HTML文件、图片文件、查询结果等）；</li></ol></li><li><a id="question2">HTTP工作原理：</a><ol><li>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端发送所有请求。</li><li>web服务器有：Apache 服务器、lls服务器等；</li><li>HTTP默认端口号为80，但是也可以改为8080或者其他端口；</li></ol></li><li><a id="question3">HTTP的优点和缺点？</a><ol><li>优点<ol><li>支持客户&#x2F;服务器模式</li><li>应用广泛且跨平台</li><li>简单快速、灵活</li></ol></li><li>缺点<ol><li>无连接：</li><li>无状态：无状态可以减轻服务器负担，但进行关联操作时繁琐，Cookie正好可以解决这个问题</li><li>明文传输:调试便利的同时带来了信息易被窃取</li><li>不安全:（HTTPS通过引入SSL&#x2F;TLS层，解决了这个隐患）</li></ol></li></ol></li><li><a id="question4">请求类型Get与Post之间的区别？</a><ol><li>get重点在从服务器上获取资源，post重点在向服务器发送数据；</li><li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等； post较get安全性较高；</li><li>get传输数据是通过URL请求，以field（字段）&#x3D; value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&password=admin%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%94%A8%E6%88%B7%E6%98%AF%E5%8F%AF%E8%A7%81%E7%9A%84%EF%BC%9Bpost%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87Http%E7%9A%84post%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86%E5%AD%97%E6%AE%B5%E4%B8%8E%E5%AF%B9%E5%BA%94%E5%80%BC%E5%B0%81%E5%AD%98%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BD%93%E4%B8%AD%E5%8F%91%E9%80%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AF%B9%E7%94%A8%E6%88%B7%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的</a></li><li>Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；</li><li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。</li></ol></li><li><a id="question5">HTTP与HTTPS的区别？</a><ol><li>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>HTTP和HTTPS 使用完全不同的连接方式，所用的端口不同，前者是80 端口，后者是 443端口</li></ol></li><li><a id="question6">常见HTTP的状态码有哪些？</a><ol><li>200 – 请求成功</li><li>301 – 资源(网页等)被永久转移到其它URL</li><li>404 – 请求的资源(网页等)不存在</li><li>500 – 内部服务器错误</li></ol></li><li><a id="question7">HTTP常见的字段有哪些？</a><ol><li>URI&amp;URL：<ol><li>URI:统一资源标识符，不仅可以标识http，ftp等其他的网络资源</li><li>URL:统一资源定位符</li></ol></li><li>请求头：<ol><li>Accept可接受的响应内容类型（Content-Types）。</li><li>Accept-Charset可接受的字符集</li><li>Accept-Encoding可接受的响应内容的编码方式。</li><li>Accept-Language可接受的响应内容语言列表。</li><li>Accept-Datetime可接受的按照时间来表示的响应内容版本</li><li>Authorization用于表示HTTP协议中需要认证资源的认证信息</li></ol></li><li>请求方法：<ol><li>GET ：获取一个资源，同时参数直接跟在URL后面,url长度受限制2048字节</li><li>POST：不仅可以获取资源，还可以提交资源（譬如上传文件），参数放在请求体中，包大小4G</li><li>HEAD：只要响应头，没有响应体，通常用于测试URL是否存在</li><li>DELETE:删除一个资源</li><li>PUT：通常修改一个资源</li><li>OPTIONS：询问服务器支持的方法</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接</li></ol></li><li>响应头:<ol><li>Content-Length:响应体的长度</li><li>Server：服务器的信息</li><li>Content-Type：内容的类型，text／html，xml等</li><li>Last-Modified ：最有的修改日期，通常跟缓存相关 20151108</li><li>Location: 新的地址</li></ol></li><li>响应码:<ol><li>200 OK 访问正常</li><li>206 跟断点续传相关</li><li>3XX 重定向：Location</li><li>304 缓存有效</li><li>307 临时重定向</li><li>4XX 客户端问题</li><li>401 代表没有权限访问</li><li>404 代表访问的资源不存在</li><li>5XX 通常服务器内部处理的问题</li></ol></li></ol></li><li><a id="question8">三次握手与四次挥手</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/03/01/GitInterviewQuestion/"/>
    <url>/2024/03/01/GitInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7122755913043148813">资料一</a><br><a href="https://blog.csdn.net/nobody_1/article/details/88956315">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">常用git命令</a></li><li><a href="#question2">提交时产生冲突，如何产生如何解决</a></li><li><a href="#question3">提交误操作，怎么撤销</a></li><li><a href="#question4">如何修改提交的历史信息</a></li><li><a href="#question5">git stash</a></li><li><a href="#question6">如何查看分支提交的历史记录，查看某个文件的历史记录</a></li><li><a href="#question7">git fetch和git pull区别</a></li><li><a href="#question8">git merge和git rebase区别</a></li><li><a href="#question9">git系统中HEAD，工作树和索引区别</a></li><li><a href="#question10">之前项目中使用GitFlow工作流程吗，有什么好处</a></li><li><a href="#question11">git cherry-pick</a></li><li><a href="#question12">git和其他版本控制器有啥区别</a></li><li><a href="#question13">忽略提交</a></li><li><a href="#question14">如何把本地仓库的内容推向一个空的远程仓库</a></li><li><a href="#question15">git submodule</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><p><a id="question1">列举工作中常用的几个git命令？</a></p><ol><li>git add file || git add</li><li>git commit -m || git commit -a</li><li>git status -s</li><li>git fetch&#x2F;git merge || git pull</li><li>git feflog</li></ol></li><li><p><a id="question2">提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？</a></p></li><li><p><a id="question3">如果本次提交误操作，如何撤销？</a></p><ol><li>撤销提交到索引区的文件，可以通过git reset HEAD file</li><li>撤销提交到本地仓库的文件，可以通过git reset –soft HEAD^n恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更</li><li>通过git reset –mixed HEAD^n恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更</li><li>通过git reset –hard HEAD^n恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。</li></ol></li><li><p><a id="question4">如果我想修改提交的历史信息，应该用什么命令？</a></p><ol><li>修改最近一次提交的历史记录，就可以用git commit –amend命令；</li><li>修改之前提交的历史记录，就需要按照下面的步骤<ol><li>首先查看前三次的提交历史记录：<code>git log -3</code></li><li>执行命令git rebase –i HEAD~3，会把前3次的提交记录按照倒叙列出来；</li><li>根据提示，执行git commit –amend命令，进入vim编辑器并修改提交信息。</li><li>然后执行git rebase –continue命令</li></ol></li></ol></li><li><p><a id="question5">你使用过git stash命令吗？你一般什么情况下会使用它？</a></p><ol><li>命令git stash是把工作区修改的内容存储在栈区。<ol><li>解决冲突文件时，会先执行git stash，然后解决冲突；</li><li>遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发；</li><li>切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换；</li></ol></li></ol></li><li><p><a id="question6">如何查看分支提交的历史记录？查看某个文件的历史记录呢？</a></p><ol><li>命令git log –number：表示查看当前分支前number个详细的提交历史记录；</li><li>命令git log –number –pretty&#x3D;oneline：在上个命令的基础上进行简化，只显示sha-1码和提交信息；</li><li>命令git reflog –number: 表示查看所有分支前number个简化的提交历史记录；</li><li>命令git reflog –number –pretty&#x3D;oneline：显示简化的信息历史信息；</li><li>如果要查看某文件的提交历史记录，直接在上面命令后面加上文件名即可。</li><li>注意：如果没有number则显示全部提交次数。</li></ol></li><li><p><a id="question7">能不能说一下git fetch和git pull命令之间的区别？</a></p><ol><li>git fetch branch是把名为branch的远程分支拉取到本地；</li><li>而git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull &#x3D; fetch + merge。</li></ol></li><li><p><a id="question8">使用过git merge和git rebase吗？它们之间有什么区别？</a></p><ol><li>git merge和git rebase都是合并分支的命令。</li><li>git merge branch会把branch分支的差异内容pull到本地，然后与本地分支的内容一并形成一个committer对象提交到主分支上，合并后的分支与主分支一致；</li><li>git rebase branch会把branch分支优先合并到主分支，然后把本地分支的commit放到主分支后面，合并后的分支就好像从合并后主分支又拉了一个分支一样，本地分支本身不会保留提交历史。</li></ol></li><li><p><a id="question9">能说一下git系统中HEAD、工作树和索引之间的区别吗？</a></p><ol><li>HEAD文件包含当前分支的引用（指针）；</li><li>工作树是把当前分支检出到工作空间后形成的目录树，一般的开发工作都会基于工作树进行；</li><li>索引index文件是对工作树进行代码修改后，通过add命令更新索引文件；GIT系统通过索引index文件生成tree对象；</li></ol></li><li><p><a id="question10">之前项目中是使用的GitFlow工作流程吗？它有什么好处？</a></p><ol><li>GitFlow可以用来管理分支。GitFlow工作流中常用的分支有下面几类：<ol><li>master分支</li><li>develop分支</li><li>feature分支</li><li>release分支</li><li>hotfix分支</li></ol></li><li>GitFlow主要工作流程<ol><li>初始化项目为gitflow , 默认创建master分支 , 然后从master拉取第一个develop分支</li><li>从develop拉取feature分支进行编码开发(多个开发人员拉取多个feature同时进行并行开发 , 互不影响)</li><li>feature分支完成后 , 合并到develop(不推送 , feature功能完成还未提测 , 推送后会影响其他功能分支的开发)；合并feature到develop , 可以选择删除当前feature , 也可以不删除。但当前feature就不可更改了，必须从release分支继续编码修改</li><li>从develop拉取release分支进行提测 , 提测过程中在release分支上修改BUG</li><li>release分支上线后 , 合并release分支到develop&#x2F;master并推送；合并之后，可选删除当前release分支，若不删除，则当前release不可修改。线上有问题也必须从master拉取hotfix分支进行修改；</li><li>上线之后若发现线上BUG , 从master拉取hotfix进行BUG修改；</li><li>hotfix通过测试上线后，合并hotfix分支到develop&#x2F;master并推送；合并之后，可选删除当前hotfix ，若不删除，则当前hotfix不可修改，若补丁未修复，需要从master拉取新的hotfix继续修改；</li><li>当进行一个feature时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前feature分支；</li><li>当进行一个release分支时 , 若develop分支有变动 , 如其他开发人员完成功能并上线 , 则需要将完成的功能合并到自己分支上，即合并develop到当前release分支 (!!! 因为当前release分支通过测试后会发布到线上 , 如果不合并最新的develop分支 , 就会发生丢代码的情况)；</li><li>GitFlow的好处:为不同的分支分配一个明确的角色，并定义分支之间如何交互以及什么时间交互；可以帮助大型项目理清分支之间的关系，简化分支的复杂度。</li></ol></li></ol></li><li><p><a id="question11">使用过git cherry-pick，有什么作用？</a></p><ol><li>命令git cherry-pick可以把branch A的commit复制到branch B上。</li><li>在branch B上进行命令操作：<ol><li>复制单个提交：git cherry-pick commitId</li><li>复制多个提交：git cherry-pick commitId1…commitId3</li><li>注意：复制多个提交的命令不包含commitId1.</li></ol></li></ol></li><li><p><a id="question12">git跟其他版本控制器有啥区别？</a></p><ol><li>GIT是分布式版本控制系统，其他类似于SVN是集中式版本控制系统。</li><li>分布式区别于集中式在于：每个节点的地位都是平等，拥有自己的版本库，在没有网络的情况下，对工作空间内代码的修改可以提交到本地仓库，此时的本地仓库相当于集中式的远程仓库，可以基于本地仓库进行提交、撤销等常规操作，从而方便日常开发。</li><li></li></ol></li><li><p><a id="question13">我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git status时都让这些文件显示出来，我们该如何操作？</a></p><ol><li>touch .gitignore<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ vim <span class="hljs-string">.gitignore</span><br>$ cat <span class="hljs-string">.gitignore</span><br><span class="hljs-string">/target/class</span><br><span class="hljs-string">.settings</span><br><span class="hljs-string">.imp</span><br>*<span class="hljs-string">.ini</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><a id="question14">如何把本地仓库的内容推向一个空的远程仓库？</a></p></li><li><p><a id="question15">git submodule</a></p><ol><li>Git 工具的 submodule 功能就是建立了当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。</li><li>当项目比较复杂，部分代码希望独立为子模块进行版本控制时，可以使用 git submodule 功能。</li><li>使用 git submodule 功能时，主项目仓库并不会包含子模块的文件，只会保留一份子模块的配置信息及版本信息，作为主项目版本管理的一部分。</li><li>一个有用的场景是：当项目依赖并跟踪一个开源的第三方库时，将第三方库设置为submodule。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2024/02/29/WebpackInterviewQuestion/"/>
    <url>/2024/02/29/WebpackInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7066807280557096974">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/44438844">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">简单说一下webpack的构建流程</a></li><li><a href="#question2">Loader和Plugin的区别</a></li><li><a href="#question3">webpack的热更新原理</a></li><li><a href="#question4">如何提高webpack的打包速度</a></li><li><a href="#question5">如何减少webpack打包体积</a></li><li><a href="#question6">有哪些常用的loader</a></li><li><a href="#question7">常用的plugin</a></li><li><a href="#question8">用过哪些可以提供效率的插件</a></li><li><a href="#question9">source map是什么，生产环境怎么用</a></li><li><a href="#question10">文件指纹是什么</a></li><li><a href="#question11">tree shaking原理是什么</a></li><li><a href="#question12">说一下Babel原理</a></li><li><a href="#question13">有写过loader吗 简述一下思路</a></li><li><a href="#question14">有写过plugin吗 简述一下思路</a></li><li><a href="#question15">怎么配置单页应用？怎么配置多页应用？</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">简单说一下 webpack 的构建流程</a><ol><li><strong>初始化参数</strong>：从配置文件和shell语句中读取与合并参数，得到最终的参数。</li><li><strong>开始编译</strong>：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行compiler对象的run方法开始执行编译。</li><li><strong>确定入口</strong>：根据配置中的entry找出所有的入口文件</li><li><strong>编译模块</strong>：从入口文件出发，调用所有配置的Loader对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理。</li><li><strong>完成模块编译</strong>：在经过第四步使用Loader编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系。</li><li><strong>输出资源</strong>：根据入口和模块之间的关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</li><li><strong>输出完成</strong>：在确定输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol></li><li><a id="question2">Loader 和 Plugin 的区别</a><ol><li><strong>Loader</strong>本质就是一个函数，在该函数对接收到的内容进行转换，返回转换后的结果。你可以理解为是一个“管道”，在外部接收到的内容通过这个“管道”进行转换，然后再将转换后的结果输出。因为 webpack 只认识 js，所以，你也可以将 Loader 称之为“翻译官”，对其他类型的资源进行转译的预处理工作。</li><li><strong>Plugin</strong> 直译为插件，基于事件流框架 Tapable。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。<ol><li>通过这个 Tapable 框架，你可以更深层的谈一下 webpack 底层 plugin 是如何实现的以及微内核，其实 webpack 就是微内核架构的一个例子，本质上就是一个是很小的功能，它并没有携带任何业务的功能，比如：打包多个页面，在打包页面上做相应的操作，其实它都没有，形象的来说它更像是一个底座，这底座可以插上各个地方增添的功能</li><li>扩展：<ol><li>微内核系统一般分为两部分 —核心系统和插件系统，这样就提供了很好的灵活性和可扩展性。核心系统是最小可运行的模块，它提供的是通用逻辑（比如 Tapable），而插件系统这些是具体的逻辑（比如HtmlWebpackPlugin插件），再比如系统怎么跑起来，插件之间怎么通信等模块都属于核心系统里面，让系统更加丰富多彩就是插件系统了。插件之间可以相互独立，也可以有依赖。</li><li>核心系统怎么知道哪些插件可用呢？<ol><li>这就需要注册表了，其实我们的 webpack.config.js 就起到了这样的作用，它告诉我们需要使用哪些插件。</li></ol></li><li>插件系统和核心系统怎么通信呢？<ol><li>这就需要用到 Tapable 了，里面有各种 hooks，并且在运行各个生命周期过程中会执行对应的回调。我们的核心系统有生命周期的概念，插件里面也有，因为它们的架构是类似的。我们的核心系统在运行后会先读取注册表信息，这个过程其实就是订阅事件，主车回调的过程。插件可以在运行回调的过程中再不断订阅自己需要的其他事件，注册其他回调。服务于具体逻辑的插件模块是独立于核心系统之外的，但是它可能会需要操作核心模块的系统服务来实现这些规定的功能，此时核心系统需要提供一个上下文对象（context），当然，插件模块与外部进行交互只允许通过此上下文对象完成。上下文对象提供了基础操作（调起其他插件模块、调起系统服务，获取系统信息）的 API 和事件。</li><li>这样待核心系统的生命周期顺序执行的过程，也就伴随这对应的时期的插件的生命周期交替执行，生命周期走完了，整个程序流程也就结束了。</li></ol></li></ol></li></ol></li></ol></li><li><a id="question3">说一下 webpack 的热更新原理</a><ol><li>webpack 的热更新又称为热替换（Hot Module Replacement），缩写为 HMR，这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</li><li>HMR 的核心就是客户端从服务端拉取更新后的文件，准确的说是 chunk diff（chunk需要更新的部分），实际上 webpack-dev-server 与浏览器之间维护了一个 WebSocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 ajax 请求来获取更改内容（文件列表、hash），这样客户端就可以再借助这些信息继续向 webpack-dev-server 发起 jsonp 请求获取该 chunk 的增量更新。后续的部分由 HotModulePlugin 来完成，提供了相关的 API 以供开发真针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</li><li><a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></li><li>基本实现原理大致这样的，构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。</li></ol></li><li><a id="question4">如何提高 webpack 的打包速度？</a><ol><li>多入口情况下，使用 optimization.splitChunks 来提取公共代码。</li><li>通过 externals 配置来提取常用库。</li><li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块，通过 DllPlugin 来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin 将编译编译的模块加载进来。</li><li>使用 thread-loader 实现多进程加速编译。</li><li>使用 terser-webpack-plugin 对js进行代码压缩。</li><li>优化 resolve 配置缩小范围。</li><li>使用 tree-shaking 和 Scope hoisting 来剔除多余代码。</li></ol></li><li><a id="question5">如何减少 webpack 打包体积？</a><ol><li>使用 externals 配置来提取常用库。</li><li>使用 tree-sjaking 和 scope hoisting 来剔除多余代码。</li><li>使用 optimize-css-assets-webpack-plugin 压缩css。</li><li>使用 terser-webpack-plugin 对 js 进行代码压缩。</li></ol></li><li><a id="question6">webpack 有哪些常见的 loader？你用过哪些 loader？</a><ol><li>cache-loader：可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里。</li><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件（处理图片、字体、图标）。</li><li>url-loader：与file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader，小于阈值时返回文件 base64 形式编码（处理图片）。</li><li>image-loader：加载并且压缩图片文件。</li><li>babel-loader：把 ES6 转换成 ES5。</li><li>ts-loader：将 typescript 转换成 JavaScript。</li><li>svg-inline-loader：将压缩后的SVG内容注入代码中。</li><li>raw-loader：加载文件原始内容（utf-8）。</li><li>sass-loader：将 scss&#x2F;sass 代码转换成 css。</li><li>css-loader：加载 css，支持模块化、压缩、文件导入等特性。</li><li>less-loader：将 less 代码转换成 css。</li><li>style-loader：生成 style 标签，将 js 中的样式资源插入，并添加到 header 中生效。</li><li>postcss-loader：扩展 css 语法，使用下一代 css，可以配合 autoprefixer 插件自动补齐 css3 前缀。</li><li>eslint-loader：通过 eslint 检查 JavaScript 代码。</li><li>tslint-loader：通过tslint 检查 typesc 代码。</li><li>vue-loader：加载 vue.js 单文件组件。</li><li>awesome-typescript-loader：将 typescript 转换成 JavaScript，性能优于 ts-loader。</li></ol></li><li><a id="question7">webpack 有哪些常见的 plugin？你用过哪些 plugin？</a><ol><li>ignore-plugin：忽略部分文件。</li><li>html-webpack-plugin：简化 html 文件创建。</li><li>web-webpack-plugin：可以方便地为单页应用输出 html，比 html-webpack-plugin 好用。</li><li>terser-webpack-plugin：支持压缩ES6。</li><li>optimize-css-assets-webpack-plugin：压缩css代码。</li><li>mini-css-extract-plugin：分离样式文件，css 提取为单独文件，支持按需加载。</li><li>werviceworker-webpack-plugin：为网页应用追加离线缓存功能。</li><li>clean-webpack-plugin：目录清理。</li><li>ModuleconcatenationPlugin：开启 Scope Hoisting。</li><li>ebpack-bundle-analyzer：可视化 webpack 输出文件的体积（业务组件、依赖第三方模块）。</li><li>speed-measure-webpack-plugin：可以看到每个 loader 和 plugin 执行耗时（这个打包耗时、plugin 和 loader 耗时）。</li><li>HotModuleReplacementPlugin：模块热替换。</li></ol></li><li><a id="question8">在使用 webpack 开发时，你用过哪些可以提供效率的插件？</a><ol><li>webpack-dashboard：可以更有好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码。</li><li>speed-measure-webpack-plugin：简称SMP，分析出 webpack 打包过程中 loader 和 plugin的耗时，有助于找到构建过程中的性能瓶颈。</li><li>HotModuleReplacementPlugin：模块热替换。</li><li>size-plugin：监控资源体积变化，尽早发现问题。</li></ol></li><li><a id="question9">source map 是什么？生产环境怎么用？</a><ol><li>source map 是将编译、打包、压缩后的代码映射会源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 source map。</li><li>map 文件只要不打开开发者工具，浏览器是不会加载的。</li><li>生产环境一般有三种处理方案：<ol><li>hidden-source-map：借助第三方错误监控平台 Sentry 使用。</li><li>nosource-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 source-map 高</li><li>source-map：通过 nginx 设置将.map文件指对白名单开发。 注意：在生产环境中避免使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。</li></ol></li></ol></li><li><a id="question10">文件指纹是什么？</a><ol><li>文件指纹是指打包后输出文件的名的后缀。<ol><li>hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 就会变化。</li><li>chunkhash：和webpack打包的 chunk 有关，不同的 chunk、不同的 entry 会生成不同的 chunkhash。</li><li>contenthash：根据文件内容来定义 hash，文件内容不发生变化，则contenthash就不会变化。 直接在输出文件名添加对应的 hash值即可。</li></ol></li></ol></li><li><a id="question11">tree shaking 原理是什么？</a><ol><li>webpack中，tree-shaking 的实现 一是先标记出模块导出值中哪些没有被动用过，二是 Terser 使用删除掉这些没被用到的导出语句。</li><li>标记功能需要配置 optimization.usedExports &#x3D; true 开启   <ol><li>标记过程大致可划分为三个步骤：<ol><li>Make 阶段：收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中。</li><li>Seal 阶段：遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时：若变量没有被其他模块使用则删除对应的导出语句。 Webpack 中 Tree Shaking 的实现分为如下步骤：<ol><li>在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中</li><li>在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中</li><li>在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语句</li><li>使用 DCE 工具删除 Dead Code，实现完整的树摇效果 <a href="https://juejin.cn/post/7002410645316436004">详细tree-shaking原理</a></li></ol></li></ol></li></ol></li></ol></li><li><a id="question12">说一下 Babel 原理</a><ol><li>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：<ol><li>解析：将代码转换成 AST (抽象语法树AST)<ol><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ol></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ol><li>Taro就是利用 babel 完成的小程序语法转换</li></ol></li><li>生成：以新的 AST 为基础生成代码 <a href="https://juejin.cn/post/6844903746804137991">详细参考</a></li></ol></li></ol></li><li><a id="question13">有写过 loader 吗？简单描述一下思路</a><ol><li>开发的基本思路：因为 loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 loader 只负责自己需要负责的事情</li><li>loader 拿到的是源文件的内容（content）</li><li>通过**this.getOptions() **拿到传入的参数，</li><li>可以通过返回值的方式将处理后的内容输出或者通过 <strong>this.callback()</strong> 同步方式将内容返回出去，<ol><li>也可以调用 this.async() 生成一个异步的函数， callback 来处理传入的内容，</li></ol></li><li>再通过调用 <strong>cabllback（）</strong>将处理后的内容返回出去。</li><li>开发的过程中尽量使用异步 loader。使用 schema-utils 来检验的我们的参数。然后再利用第三方提供的模块进行 loader 的开发。</li></ol></li><li><a id="question14">有写过 plugin 吗？简答描述一下思路</a><ol><li>开发的基本思路： webpack 在运行生命周期中会广播出许多事件，PLugin 可以监听这些事件，在特定的阶段写入想要添加的自定义功能。webpack 的 tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</li><li>通过 consturctor 获取传入的配置参数</li><li>apply() 方法得到 compiler，</li><li>compiler 暴露了和 webpack 整个生命周期相关的钩子</li><li>通过 conpiler.hooks.thiscompilation 初始 compilation。</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子，</li><li>再使用相关的 hooks 对资源进行添加或者修改。</li><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改（emit 事件是修改 webpack 输出资源的最后时机）。</li><li>异步的事件需要再插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住。</li></ol></li><li><a id="question15">怎么配置单页应用？怎么配置多页应用？</a><ol><li>单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可</li><li>多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：<ol><li>每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表</li><li>随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</li></ol></li><li>如何进行多页面打包配置？<ol><li>配置多个入口文件</li><li>借助HtmlwebpackPlugin插件创建对应html<ol><li>配置多个entry, 需要new多个htmlWebpackPlugin</li><li>配置template, filename, 对应的chunks</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react.js</title>
    <link href="/2024/02/28/ReactInterviewQuestion/"/>
    <url>/2024/02/28/ReactInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/677917087">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/438358521">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>React的严格模式如何使用，有什么用处？</li><li>在React中遍历的方法有哪些？</li><li>在React中页面重新加载时怎样保留数据？</li><li>React必须使用JSX吗？</li><li>为什么使用jsx的组件中没有看到使用react却需要引入react</li><li>在React中怎么使用async&#x2F;await？</li><li>React.Children.map和js的map有什么区别？</li><li>React 中的高阶组件运用了什么设计模式？</li><li>类组件和函数组件有何不同？</li><li>React 中 keys 的作用是什么？</li><li>为什么调用 setState 而不是直接改变 state？</li><li>React 类组件中 setState 是同步的还是异步的？</li><li>React实现缓存的方式有哪些？他们有什么区别？</li><li>React的生命周期有哪些？</li><li>React 废弃了哪些生命周期？为什么</li><li>React 16.X 中 props 改变后在哪个生命周期中处理</li><li>React 性能优化在哪个生命周期？它优化的原理是什么？</li><li>state 和 props 触发更新的生命周期分别有什么区别？</li><li>React中发起网络请求应该在哪个生命周期中进行？为什么？</li><li>React 16中新生命周期有哪些</li><li>组件通信</li><li>如何解决 props 层级过深的问题</li><li>组件通信的方式有哪些</li><li>对 React Hook 的理解，它的实现原理是什么</li><li>为什么 useState 要使用数组而不是对象</li><li>React Hooks 解决了哪些问题？</li><li>React Hook 的使用限制有哪些？</li><li>useEffect 与 useLayoutEffect 的区别</li><li>React Hooks在平时开发中需要注意的问题和原因</li><li>对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</li><li>React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的</li><li>虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</li><li>React 与 Vue 的 diff 算法有何不同？</li><li>React 设计思路，它的理念是什么？</li><li>React组件命名推荐的方式是哪个？</li><li>react 最新版本解决了什么问题，增加了哪些东西</li><li>React 数据持久化有什么实践吗？</li><li>对 React 和 Vue 的理解，它们的异同</li><li>React中props.children和React.Children的区别</li><li>React的状态提升是什么？使用场景有哪些？</li><li>React中constructor和getInitialState的区别</li><li>React的严格模式如何使用，有什么用处？</li><li>同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？</li><li>对React SSR的理解</li><li>HOC相比 mixins 有什么优点？</li><li>React的事件和普通的HTML事件有什么不同？</li><li>React 事件机制</li><li>React 组件中怎么做事件代理？它的原理是什么？</li><li>React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</li><li>对React-Fiber的理解，它解决了什么问题？</li><li>React.Component 和 React.PureComponent 的区别</li><li>Component, Element, Instance 之间有什么区别和联系？</li><li>React.createClass和extends Component的区别有哪些？</li><li>React 高阶组件是什么，和普通组件有什么区别，适用什么场景</li><li>对componentWillReceiveProps（已更名为UNSAFE_componentWillReceiveProps） 的理解</li><li>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</li><li>React如何判断什么时候重新渲染组件</li><li>React声明组件有哪几种方法，有什么不同？</li><li>对React中Fragment的理解，它的使用场景是什么？</li><li>React如何获取组件对应的DOM元素？</li><li>React中可以在render访问refs吗？为什么？</li><li>对React的插槽(Portals)的理解，如何使用，有哪些使用场景</li><li>在React中如何避免不必要的render？</li><li>对 React-Intl 的理解，它的工作原理？</li><li>对 React context 的理解</li><li>为什么React并不推荐优先考虑使用Context？</li><li>React中什么是受控组件和非控组件？</li><li>React中refs的作用是什么？有哪些应用场景？</li><li>React组件的构造函数有什么作用？它是必须的吗？</li><li>React.forwardRef是什么？它有什么作用</li><li>类组件与函数组件有什么异同？</li><li>React-Router的实现原理是什么？</li><li>如何配置 React-Router 实现路由切换</li><li>React-Router怎么设置重定向？</li><li>react-router 里的 Link 标签和 a 标签的区别</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li>React的严格模式如何使用，有什么用处？<ol><li>strictMode是一个用来突出显示应用程序中潜在的问题。与Fragment一样，strictMode不会渲染任何可见的UI。它为其后代元素触发额外的检查和警告。可以为应用程序的任何部分启用严格模式。</li><li>有助于<ol><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ol></li></ol></li><li>在React中遍历的方法有哪些？<ol><li>遍历数组：map &amp;&amp; forEach</li><li>遍历对象：map &amp;&amp; for in</li></ol></li><li>在React中页面重新加载时怎样保留数据？<ol><li><strong>Redux</strong>： 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li><li><strong>data.js</strong>： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；</li><li><strong>sessionStorge</strong>： 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据</li><li><strong>history API</strong>： History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。</li></ol></li><li>React必须使用JSX吗？<ol><li>React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。</li><li>每个 JSX 元素只是调用 React.createElement(component, props, …children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</li></ol></li><li>为什么使用jsx的组件中没有看到使用react却需要引入react？<ol><li>本质上来说JSX是React.createElement(component, props, …children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。</li></ol></li><li>在React中怎么使用async&#x2F;await？<ol><li>async&#x2F;await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async&#x2F;await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。</li></ol></li><li>React.Children.map和js的map有什么区别？<ol><li>JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。</li></ol></li><li>React 中的高阶组件运用了什么设计模式？<ol><li>使用了装饰模式，高阶组件的运用</li><li>装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：<code>@testable class MyTestableClass &#123;&#125;</code></li></ol></li><li>类组件和函数组件有何不同？<ol><li>在 React 16.8版本（引入钩子）之前，使用基于类的组件来创建需要维护内部状态或利用生命周期方法的组件（即componentDidMount和shouldComponentUpdate）。基于类的组件是 ES6 类，它扩展了 React 的 Component 类，并且至少实现了render()方法。</li><li>函数组件是无状态的（同样，小于 React 16.8版本），并返回要呈现的输出。它们渲染 UI 的首选只依赖于属性，因为它们比基于类的组件更简单、更具性能。</li></ol></li><li>React 中 keys 的作用是什么？<ol><li>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</li><li>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串</li><li>在集合中添加和删除项目时，不使用键或将索引用作键会导致奇怪的行为。</li></ol></li><li>为什么调用 setState 而不是直接改变 state？<ol><li>如果您尝试直接改变组件的状态，React 将无法得知它需要重新渲染组件。通过使用setState()方法，React 可以更新组件的UI。</li><li>如果需要基于另一个状态（或属性）更新组件的状态，请向setState()传递一个函数，该函数将 state 和 props 作为其两个参数</li></ol></li><li>React 类组件中 setState 是同步的还是异步的？<ol><li>在 React 管理的事件回调和生命周期中，setState 是异步的，而其他时候 setState 都是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候是立即更新的。</li><li>批量更新 setState 时，多次执行 setState 只会触发一次 Render 过程。相反在立即更新 setState 时，每次 setState 都会触发一次 Render 过程。</li><li>注意：在函数组件中生成的函数是通过闭包引用了 state，而不是通过 this.state 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了。</li><li>可以将类组件中的 setState 理解为 函数组件 useState 的第二个返回值。</li></ol></li><li>React实现缓存的方式有哪些？他们有什么区别？<ol><li>React 组件中常用 PureComponent、React.memo、hook函数useCallback、useMemo等方法 缓存上次计算的结果。</li><li>PureComponent：主要是用在类组件中，使用PureComponent, 每次会对props进行一次浅比较，也可以在shouldComponentUpdate，去做更深层次的比对。</li><li>React.memo、hook函数useCallback、useMemo主要应用在函数组件中。</li><li></li></ol></li><li>React的生命周期有哪些？<ol><li>React 通常将组件生命周期分为三个阶段：<ol><li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程；</li><li>更新过程（Update），组件状态发生变化，重新更新渲染的过程；</li><li>卸载过程（Unmount），组件从DOM树中被移除的过程；</li></ol></li><li>组件挂载阶段<ol><li>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：<ol><li>constructor<ol><li>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数Constructor。</li><li>constructor中通常只做两件事：<ol><li>初始化组件的 state</li><li>给事件处理方法绑定 this <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  super(props);</span></span><br><span class="hljs-comment"><span class="hljs-function">  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.state = &#123; counter: 0 &#125;</span></span><br><span class="hljs-function">  <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span> = <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>getDerivedStateFromProps<ol><li><code>static getDerivedStateFromProps(props, state)</code></li><li>这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。</li><li>该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。</li></ol></li><li>render<ol><li>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：<ol><li>React 元素：这里包括原生的 DOM 以及 React 组件；</li><li>数组和 Fragment（片段）：可以返回多个元素；</li><li>Portals（插槽）：可以将子元素渲染到不同的 DOM 子树种；</li><li>字符串和数字：被渲染成 DOM 中的 text 节点；</li><li>布尔值或 null：不渲染任何内容。</li></ol></li></ol></li><li>componentDidMount<ol><li>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：<ol><li>执行依赖于DOM的操作；</li><li>发送网络请求；（官方建议）</li><li>添加订阅消息（会在componentWillUnmount取消订阅）；</li><li>如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。</li></ol></li></ol></li></ol></li></ol></li><li>组件更新阶段<ol><li>当组件的 props 改变了，或组件内部调用了 setState&#x2F;forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：<ol><li>getDerivedStateFromProps</li><li>shouldComponentUpdate<ol><li><code>shouldComponentUpdate(nextProps, nextState)</code></li><li>在说这个生命周期函数之前，来看两个问题：<ol><li>setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：<ol><li><code>this.setState(&#123;number: this.state.number&#125;)</code></li><li>如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</li><li>第一个问题答案是 会 </li><li>第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</li><li>有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢</li></ol></li><li>shouldComponentUpdate登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。</li><li>注意： 添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</li></ol></li></ol></li><li>render</li><li>getSnapshotBeforeUpdate<ol><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li><li>这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。</li></ol></li><li>componentDidUpdate<ol><li>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</li><li>当组件更新后，对 DOM 进行操作；</li><li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li><li><code>componentDidUpdate(prevProps, prevState, snapshot)&#123;&#125;</code><ol><li>该方法有三个参数：</li><li>prevProps: 更新前的props</li><li>prevState: 更新前的state</li><li>snapshot: getSnapshotBeforeUpdate()生命周期的返回值</li></ol></li></ol></li></ol></li></ol></li><li>组件卸载阶段<ol><li>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：<ol><li>清除 timer，取消网络请求或清除</li><li>取消在 componentDidMount() 中创建的订阅等；</li><li>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</li></ol></li></ol></li><li>错误处理阶段<ol><li>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶<ol><li>error：抛出的错误。</li><li>info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li></ol></li></ol></li><li>React常见生命周期的过程大致如下：<ol><li>挂载阶段，首先执行constructor构造方法，来创建组件</li><li>创建完成之后，就会执行render方法，该方法会返回需要渲染的内容</li><li>随后，React会将需要渲染的内容挂载到DOM树上</li><li>挂载完成之后就会执行componentDidMount生命周期函数</li><li>如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数</li><li>render函数重新执行之后，就会重新进行DOM树的挂载</li><li>挂载完成之后就会执行componentDidUpdate生命周期函数</li><li>当移除组件时，就会执行componentWillUnmount生命周期函数</li></ol></li><li>React主要生命周期总结：<ol><li>getDefaultProps：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li><li>getInitialState：用于初始化组件的 state 值；</li><li>componentWillMount：在组件创建后、render 之前，会走到 componentWillMount 阶段。React16 直接废弃了这个生命周期</li><li>render：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li><li>componentDidMount：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li></ol></li></ol></li><li>React 废弃了哪些生命周期？为什么？<ol><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ol></li><li>React 16.X 中 props 改变后在哪个生命周期中处理<ol><li>在getDerivedStateFromProps中进行处理。</li></ol></li><li>React 性能优化在哪个生命周期？它优化的原理是什么？<ol><li>react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。</li><li>shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。</li><li>需要注意，在进行新旧对比的时候，是<strong>浅对比</strong>也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。面对这个问题，可以使用如下方法进行解决：<ol><li>使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层</li><li>使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。</li></ol></li></ol></li><li>state 和 props 触发更新的生命周期分别有什么区别？<ol><li>state 更新流程：shouldComponentUpdate-componentWillUpdate-render-componentDidUpdate</li><li>props 更新流程：componentWillReceiveProps-shouldComponentUpdate-componentWillUpdate-render-componentDidUpdate</li><li>相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：<ol><li>componentWillReceiveProps：它在Component接受到新的 props 时被触发。</li><li>componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。该生命周期是 React16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期getDerivedStateFromProps 来代替它。</li></ol></li></ol></li><li>React中发起网络请求应该在哪个生命周期中进行？为什么？<ol><li>对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。</li><li>如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。</li><li>react的生命周期： constructor() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount()</li><li>上面这些方法的调用是有次序的，由上而下依次调用。<ol><li>constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。</li><li>componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。</li><li>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。</li></ol></li><li>总结：<ol><li>跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。</li><li>在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。</li><li>react16.0以后，componentWillMount可能会被执行多次。</li></ol></li></ol></li><li>React 16中新生命周期有哪些<ol><li>React16 自上而下地对生命周期做了另一种维度的解读：<ol><li>Render 阶段：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构</li><li>Pre-commit阶段：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；</li><li>Commit 阶段：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。</li><li>与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：<ol><li>挂载过程：<ol><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ol></li><li>更新过程：<ol><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ol></li><li>卸载过程：<ol><li>componentWillUnmount</li></ol></li></ol></li></ol></li></ol></li><li>组件通信<ol><li>React组件间通信常见的几种情况:<ol><li>父组件向子组件通信</li><li>子组件向父组件通信</li><li>跨级组件通信</li><li>非嵌套关系的组件通信</li></ol></li><li>通信方式<ol><li>父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;react&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>子组件向父组件通信：: props+回调的方式。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">cb</span> = msg =&gt;&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>          props.<span class="hljs-title function_">callback</span>(msg)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;cb(</span>&quot;<span class="hljs-attr">你好</span>!&quot;)&#125;&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params">msg</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>跨级组件的通信方式<ol><li>父组件向子组件的子组件通信，向更深层子组件通信：<ol><li>使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。</li><li>使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// context方式实现跨级组件通信 </span><br><span class="hljs-comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span><br>const <span class="hljs-type">BatteryContext</span> = createContext();<br><span class="hljs-comment">//  子组件的子组件 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render()&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>                &#123;<br>                    color =&gt; &lt;h1 style=&#123;&#123;<span class="hljs-string">&quot;color&quot;</span>:color&#125;&#125;&gt;我是红色的:&#123;color&#125;&lt;/h1&gt;<br>                &#125;<br>            &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  子组件</span><br>const <span class="hljs-type">Child</span> = () =&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;<span class="hljs-type">GrandChild</span>/&gt;<br>    )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>      state = &#123;<br>          color:<span class="hljs-string">&quot;red&quot;</span><br>      &#125;<br>      render()&#123;<br>          const &#123;color&#125; = <span class="hljs-keyword">this</span>.state<br>          <span class="hljs-keyword">return</span> (<br>          &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span> value=&#123;color&#125;&gt;<br>              &lt;<span class="hljs-type">Child</span>&gt;&lt;/<span class="hljs-type">Child</span>&gt;<br>          &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span>&gt;<br>          )<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>非嵌套关系组件的通信方式<ol><li>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件</li><li>可以使用自定义事件通信（发布订阅模式）</li><li>可以通过redux等进行全局状态管理</li><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ol></li></ol></li></ol></li><li>如何解决 props 层级过深的问题<ol><li>使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；</li><li>使用Redux等状态库。</li></ol></li><li>组件通信的方式有哪些<ol><li>⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯</li><li>⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中</li><li>兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信</li><li>跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过</li><li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信</li><li>全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</li></ol></li><li>对 React Hook 的理解，它的实现原理是什么<ol><li>React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组件两种组件形式的思考和侧重。</li><li>类组件<ol><li>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。</li><li>React 类组件内部预置了相当多的“现成的东西”等着我们去调度&#x2F;定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。</li><li>它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。</li></ol></li><li>函数组件<ol><li>函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。</li></ol></li><li>通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：<ol><li>类组件需要继承 class，函数组件不需要；</li><li>类组件可以访问生命周期方法，函数组件不能；</li><li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li><li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li><li>函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。</li></ol></li><li>React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。</li></ol></li><li>为什么 useState 要使用数组而不是对象<ol><li>如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净</li><li>如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</li><li>useState 返回的是 array 而不是 object 的原因就是为了降低使用的复杂度；返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。</li></ol></li><li>React Hooks 解决了哪些问题？<ol><li>在组件之间复用状态逻辑很难</li><li>复杂组件变得难以理解</li><li>难以理解的 class</li></ol></li><li>React Hook 的使用限制有哪些？<ol><li>不要在循环、条件或嵌套函数中调用 Hook；<ol><li>因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</li></ol></li><li>在 React 的函数组件中调用 Hook。</li></ol></li><li>useEffect 与 useLayoutEffect 的区别<ol><li>共同点<ol><li>运用效果： useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。</li><li>使用方式：useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</li></ol></li><li>不同点<ol><li>使用场景： useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。</li><li>使用效果： useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。</li><li>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</li></ol></li></ol></li><li>React Hooks在平时开发中需要注意的问题和原因<ol><li>不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</li><li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑<ol><li>使用push直接更改数组无法获取到新值，应该采用析构方式，</li></ol></li><li>useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</li><li>善用useCallback<ol><li>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。</li></ol></li><li>不要滥用useContext<ol><li>可以使用基于 useContext 封装的状态管理工具</li></ol></li><li>React Hooks 和生命周期的关系<ol><li>函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。</li><li>但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。 </li><li>即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。</li><li>下面是具体的 class 与 Hooks 的生命周期对应关系：<ol><li>constructor：函数组件不需要构造函数，可以通过调用 <strong>useState 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 useState。<ol><li><code>const [num, UpdateNum] = useState(0)</code></li></ol></li><li>getDerivedStateFromProps：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。</li><li>render：这是函数组件体本身。</li><li>componentDidMount, componentDidUpdate：<ol><li>useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。</li></ol></li><li>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便<ol><li>componentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数</li></ol></li></ol></li></ol></li></ol></li><li>对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？<ol><li>为什么要用 Virtual DOM：<ol><li>保证性能下限，在不进行手动优化的情况下，提供过得去的性能</li><li>跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</li></ol></li><li>React diff 算法的原理是什么？<ol><li>实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。</li><li>具体的流程如下：<ol><li>真实的 DOM 首先会映射为虚拟 DOM；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li><li>一个生成补丁、更新差异的过程统称为 diff 算法</li></ol></li><li>diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：<ol><li>策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）<ol><li>这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</li></ol></li><li>如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）<ol><li>在组件比对的过程中：<ol><li>如果组件是同一类型则进行树比对；</li><li>如果不是则直接放入补丁中。</li><li>只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。</li></ol></li></ol></li><li>策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）<ol><li>元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。</li></ol></li></ol></li></ol></li></ol></li><li>React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的<ol><li>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。</li><li>在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。 注意事项：<ol><li>key值一定要和具体的元素一一对应；</li><li>尽量不要用数组的index去作为key；</li><li>不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。</li></ol></li></ol></li><li>虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么<ol><li>虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。</li><li>在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</li><li>在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验&#x2F;研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。</li><li>虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。</li></ol></li><li>React 与 Vue 的 diff 算法有何不同？<ol><li>diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。</li><li>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。<ol><li>树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li><li>组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li><li>元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。</li><li>以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。</li></ol></li><li>Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</li></ol></li><li>React 设计思路，它的理念是什么？<ol><li>编写简单直观的代码</li><li>简化可复用的组件</li><li>Virtual DOM</li><li>函数式编程</li><li>一次学习，随处编写</li></ol></li><li>React组件命名推荐的方式是哪个？<ol><li>通过引用而不是使用来命名组件displayName。<ol><li>使用displayName命名组件：<code>export default React.createClass(&#123;  displayName: &#39;TodoApp&#39;,  // ...&#125;)</code></li><li>React推荐的方法：<ol><li><code>export default class TodoApp extends React.Component &#123;  // ...&#125;</code></li></ol></li></ol></li></ol></li><li>react 最新版本解决了什么问题，增加了哪些东西<ol><li>React 16.x的三大新特性 Time Slicing、Suspense、 hooks<ol><li>Time Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能</li><li>Suspense （解决网络IO问题） 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式</li><li>提供了一个内置函数componentDidCatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。</li></ol></li><li>React16.8<ol><li>加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：<ol><li>在组件间复用状态逻辑很难</li><li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li><li>class组件的this指向问题</li><li>难以记忆的生命周期</li></ol></li><li>hooks很好的解决了上述问题，hooks提供了很多方法<ol><li>useState 返回有状态值，以及更新这个状态值的函数</li><li>useEffect 接受包含命令式，可能有副作用代码的函数。</li><li>useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，</li><li>useReducer useState 的替代方案。接受类型为 （state，action）&#x3D;&gt; newState的reducer，并返回与dispatch方法配对的当前状态。</li><li>useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li><li>useImperativeMethods 自定义使用ref时公开给父组件的实例值</li><li>useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</li><li>useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染</li></ol></li></ol></li><li>React16.9<ol><li>重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码review和 debug 期间，使这些有问题的字样更突出</li><li>废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。</li><li>废弃”Factory”组件。 工厂组件会导致 React 变大且变慢。</li><li>act（）也支持异步函数，并且你可以在调用它时使用 await。</li><li>使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</li></ol></li><li>React16.13.0<ol><li>支持在渲染期间调用setState，但仅适用于同一组件</li><li>可检测冲突的样式规则并记录警告</li><li>废弃 unstable_createPortal，使用CreatePortal</li><li>将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。</li></ol></li><li>react 18<ol><li>v18 中我们可以通过 createRoot Api 手动创建 root 节点。</li><li>在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise链、setTimeout等异步代码以及原生事件处理函数。</li><li>如果想退出自动批处理立即更新的话，可以使用 ReactDOM.flushSync() 进行包裹。</li><li>useTransition :接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的pending 状态和startTransition函数。</li><li>SSR下的 Suspense 组件</li><li>useSyncExternalStore:这个 API 可以防止在 concurrent 模式下，任务中断后第三方 store 被修改，恢复任务时出现tearing从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 useSyncExternalStore 可以使 React 在 concurrent mode 下，保持自身 state 和来自 Redux 的状态同步。</li><li>useInsertionEffect:这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与<code>&lt;style&gt;</code>标签一起插入到文档中。</li><li>useId:React 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的HTML结构相匹配。我们平时使用的如Math.random()在SSR 面前是没法保证客户端与服务端之间的 id 唯一性。<ol><li>React为了解决这个问题，提出来useOpaqueIdentifier这个hook, 不过它在不同环境会产生不同的结果.<ol><li>在服务端会生成一个字符串</li><li>在客户端会生成一个对象，必须直接传递给DOM属性</li></ol></li><li>而useId 可以生成客户端与服务端之间的唯一id ，并且返回一个字符串。这样一个组件可以只需调用一次useId ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 id。</li></ol></li><li>useDefferdValue<ol><li>React 可以通过 useDefferdValue 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 timeoutMs 期限内未能完成，它将强制更新。</li><li>useDefferdValue 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染I，等待这个状态更新完毕之后再渲染。</li></ol></li></ol></li></ol></li><li>React 数据持久化有什么实践吗？<ol><li>redux-persist</li><li>redux-persist会将redux的store中的数据缓存到浏览器的localStorage中</li></ol></li><li>对 React 和 Vue 的理解，它们的异同<ol><li>相似之处：<ol><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能</li><li>都有props的概念，允许组件间的数据传递</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</li></ol></li><li>不同之处：<ol><li>数据流<ol><li>Vue默认支持数据双向绑定，而React一直提倡单向数据流</li></ol></li><li>虚拟DOM<ol><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ol></li><li>组件化<ol><li>React与Vue最大的不同是模板的编写。<ol><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ol></li><li>React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用</li><li>在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。</li></ol></li><li>监听数据变化的实现原理不同<ol><li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ol></li><li>高阶组<ol><li>react可以通过高阶组件（Higher Order Components– HOC）来扩展，而vue需要通过mixins来扩展。</li><li>原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</li></ol></li><li>构建工具<ol><li>React &#x3D;&#x3D;&gt; Create React APP</li><li>Vue &#x3D;&#x3D;&gt; vue-cli</li></ol></li><li>跨平台<ol><li>React &#x3D;&#x3D;&gt; React Native</li><li>Vue &#x3D;&#x3D;&gt; Weex</li></ol></li></ol></li></ol></li><li>React中props.children和React.Children的区别<ol><li>在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">ParentComponent</span>(props)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">(</span><br>&lt;div&gt;<br>&#123;props.children&#125;<br>&lt;/div&gt;<br>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。</li></ol></li><li>React的状态提升是什么？使用场景有哪些？<ol><li>React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。</li><li>官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。</li><li>概括来说就是<strong>将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件</strong>。</li></ol></li><li>React中constructor和getInitialState的区别?<ol><li>两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。 getInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，</li></ol></li><li>React的严格模式如何使用，有什么用处？<ol><li>StrictMode是一个用来突出显示应用程序中潜在问题的工具。与Fragment一样，StrictMode不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。</li></ol></li><li>同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？<ol><li>react：包含react所必须的核心代码</li><li>react-dom：react渲染在不同平台所需要的核心代码</li><li>babel：将jsx转换成React代码的工具</li></ol></li><li>对React SSR的理解<ol><li>服务端渲染是数据与模版组成的html，即 HTML &#x3D; 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;</li><li>SSR的优势：<ol><li>对SEO友好</li><li>所有的模版、图片等资源都存在服务器端</li><li>一个html返回所有数据</li><li>减少HTTP请求</li><li>响应快、用户体验好、首屏渲染快</li></ol></li><li>SSR的局限：<ol><li>服务端压力较大 本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;</li><li>开发条件受限 在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;</li><li>学习成本相对较高 除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</li></ol></li></ol></li><li>HOC相比 mixins 有什么优点？<ol><li>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：<ol><li>隐含了一些依赖，比如我在组件中写了某个 state 并且在 mixin 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 mixin 中查找依赖</li><li>多个 mixin 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了。</li><li>雪球效应，虽然我一个组件还是使用着同一个 mixin，但是一个 mixin 会被多个组件使用，可能会存在需求使得 mixin 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li></ol></li></ol></li><li>React的事件和普通的HTML事件有什么不同？<ol><li>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</li><li>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</li><li>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</li><li>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：<ol><li>兼容所有浏览器，更好的跨平台；</li><li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li><li>方便 react 统一管理和事务机制。</li><li>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会沿着fiber树模拟的dom树发生捕获和冒泡，最终会冒泡到 render 选择的容器节点上。</li></ol></li></ol></li><li>React 事件机制<ol><li>React中的事件是一个合成事件（SyntheticEvent），合成事件指的是react用js模拟了一个Dom事件流（类似，fiber树模拟Dom树结构） 合成事件的事件流在fiber树中发生捕获和冒泡。</li><li>React 根据 W3C 规范来定义这些合成事件，它的产生主要有两方面原因： <ol><li>统一解决了跨浏览器的兼容性问题 </li><li>避免这类DOM事件滥用，如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响</li><li>React并不是将click事件绑在该 div 的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。 其中，由于event对象是复用的，事件处理函数执行完后，属性会被清空，所以event的属性无法被异步访问，详情请查阅event-pooling</li></ol></li></ol></li><li>React 组件中怎么做事件代理？它的原理是什么？<ol><li>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。在React底层，主要对合成事件做了两件事：<ol><li>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li><li>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</li></ol></li></ol></li><li>React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代<ol><li>这三者是目前react解决代码复用的主要方式：<ol><li>高阶组件（HOC）：是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li><li>render props：是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li><li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。<ol><li>HOC 官方解释∶ 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</li><li>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</li><li>HOC的优缺点∶<ol><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li><li>缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ol></li></ol></li><li>Render props 官方解释∶”render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<ol><li>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</li><li>由此可以看到，render props的优缺点也很明显∶<ol><li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li><li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li></ol></li></ol></li><li>Hooks 官方解释∶ Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</li><li>总结:<ol><li>Hoc、render props和hook都是为了解决代码复用的问题</li><li>但是hoc和render props都有特定的使用场景和明显的缺点</li><li>hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</li></ol></li></ol></li></ol></li><li>对React-Fiber的理解，它解决了什么问题？<ol><li>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。</li><li>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</li><li>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:<ol><li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li><li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li></ol></li><li>核心思想: <ol><li>Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</li></ol></li></ol></li><li>React.Component 和 React.PureComponent 的区别<ol><li>React.Component 就是react得到普通组件。</li><li>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</li><li>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</li><li>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</li><li>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</li></ol></li><li>Component, Element, Instance 之间有什么区别和联系？<ol><li>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</li><li>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</li><li>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</li><li>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</li></ol></li><li>React.createClass和extends Component的区别有哪些？<ol><li>语法区别<ol><li>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</li><li>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</li></ol></li><li>propType 和 getDefaultProps<ol><li>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</li><li>React.Component：通过设置两个属性propTypes和defaultProps</li></ol></li><li>状态的区别<ol><li>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</li><li>React.Component：通过constructor设置初始状态</li></ol></li><li>this区别<ol><li>React.createClass：会正确绑定this</li><li>React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</li></ol></li><li>Mixins<ol><li>React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。</li><li>如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。</li></ol></li></ol></li><li>React 高阶组件是什么，和普通组件有什么区别，适用什么场景<ol><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</li><li>高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</li><li>适用场景<ol><li>代码复用，逻辑抽象</li><li>渲染劫持</li><li>State 抽象和更改</li><li>Props 更改</li></ol></li><li>具体应用例子<ol><li>权限控制： 利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别</li><li>组件渲染性能追踪： 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录</li><li>页面复用</li></ol></li></ol></li><li>对componentWillReceiveProps（已更名为UNSAFE_componentWillReceiveProps） 的理解<ol><li>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</li><li>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</li><li>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</li><li>注意：React官网已经把componentWillReceiveProps重名为UNSAFE_componentWillReceiveProps，可以用getDerivedStateFromProps替代。</li></ol></li><li>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？<ol><li>setState（）方法被调用<ol><li>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</li><li>父组件重新渲染<ol><li>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</li></ol></li><li>重新渲染 render 会做些什么?<ol><li>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</li><li>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li><li>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</li><li>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。</li><li>在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。「Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。」</li><li>React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</li></ol></li></ol></li></ol></li><li>React如何判断什么时候重新渲染组件？<ol><li>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。</li><li>当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</li></ol></li><li>React声明组件有哪几种方法，有什么不同？<ol><li>函数式定义的无状态组件</li><li>ES5原生方式React.createClass定义的组件</li><li>ES6形式的extends React.Component定义的组件</li><li>不同：<ol><li>无状态函数式组件 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</li><li>ES5 原生方式 React.createClass RFC React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</li><li>E6继承形式 React.Component RCC 目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</li><li>无状态组件相对于于后者的区别： 与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</li></ol></li></ol></li><li>对React中Fragment的理解，它的使用场景是什么？<ol><li>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：<ol><li>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</li></ol></li></ol></li><li>React如何获取组件对应的DOM元素？<ol><li>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:<ol><li>字符串格式：字符串格式，这是React16版本之前用得最多的，例如：<p ref="info">span</p></li><li>函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：&lt;p ref&#x3D;{ele &#x3D;&gt; this.info &#x3D; ele}&gt;</p></li><li>createRef方法：React 16提供的一个API，使用React.createRef()来实现</li></ol></li></ol></li><li>React中可以在render访问refs吗？为什么？<ol><li>不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：</li></ol></li><li>对React的插槽(Portals)的理解，如何使用，有哪些使用场景<ol><li>React 官方对 Portals 的定义：<ol><li>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</li><li>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。</li><li>通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。Portals语法如下：<code>ReactDOM.createPortal(child, container);</code>第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;第二个参数 container 是一个 DOM 元素。</li><li>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上</li><li>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</li></ol></li></ol></li><li>在React中如何避免不必要的render？<ol><li>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：<ol><li>shouldComponentUpdate 和 PureComponent<ol><li>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</li></ol></li><li>利用高阶组件<ol><li>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</li></ol></li><li>使用 React.memo<ol><li>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</li></ol></li></ol></li></ol></li><li>对 React-Intl 的理解，它的工作原理？<ol><li>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</li><li>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</li><li>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</li></ol></li><li>对 React context 的理解<ol><li>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</li><li>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</li><li>可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</li><li>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</li><li>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</li></ol></li><li>为什么React并不推荐优先考虑使用Context？<ol><li>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</li></ol></li><li>React中什么是受控组件和非控组件？<ol><li>受控组件<ol><li>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</li><li>受控组件更新state的流程：<ol><li>可以通过初始state中设置表单的默认值</li><li>每当表单的值发生变化时，调用onChange事件处理器</li><li>事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</li><li>一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</li></ol></li><li>受控组件缺陷：<ol><li>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</li></ol></li></ol></li><li>非受控组件<ol><li>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</li></ol></li><li>总结<ol><li>页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</li></ol></li></ol></li><li>React中refs的作用是什么？有哪些应用场景？<ol><li>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：<ol><li>处理焦点、文本选择或者媒体的控制</li><li>触发必要的动画</li><li>集成第三方 DOM 库</li></ol></li><li>Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性</li><li>由于函数组件没有实例，因此不能在函数组件上直接使用ref;但可以通过闭合的帮助在函数组件内部进行使用 Refs：</li><li>注意：<ol><li>不应该过度的使用 Refs</li><li>ref 的返回值取决于节点的类型<ol><li>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。</li><li>当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。</li></ol></li><li>当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs</li></ol></li></ol></li><li>React组件的构造函数有什么作用？它是必须的吗？<ol><li>构造函数主要用于两个目的：<ol><li>通过将对象分配给this.state来初始化本地状态</li><li>将事件处理程序方法绑定到实例上</li></ol></li><li>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</li><li>注意：<ol><li>constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用</li><li>JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</li></ol></li></ol></li><li>React.forwardRef是什么？它有什么作用？<ol><li>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<ol><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ol></li></ol></li><li>类组件与函数组件有什么异同？<ol><li>相同点：<ol><li>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</li><li>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</li></ol></li><li>不同点：<ol><li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li><li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li><li>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</li><li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li><li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li></ol></li></ol></li><li>React-Router的实现原理是什么？<ol><li>客户端路由实现的思想：<ol><li>基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化<ol><li>改变 hash 可以直接通过 location.hash&#x3D;xxx</li></ol></li><li>基于 H5 history 路由：<ol><li>改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API。监听 url 的变化可以通过自定义事件触发实现</li></ol></li></ol></li><li>react-router 实现的思想：<ol><li>基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知</li><li>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</li></ol></li></ol></li><li>如何配置 React-Router 实现路由切换<ol><li>使用<code>&lt;Route&gt; </code>组件</li><li>结合使用<code>&lt;Switch&gt;组件和&lt;Route&gt;</code>组件<ol><li><code>&lt;Switch&gt;用于将&lt;Route&gt;</code>分组。</li><li><code>&lt;Switch&gt;不是分组&lt;Route&gt;</code>所必须的，但他通常很有用。 一个<code>&lt;Switch&gt;</code>会遍历其所有的子<code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素。</li></ol></li><li>使用<code>&lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt;</code>组件<ol><li><code>&lt;Link&gt;</code>组件来在你的应用程序中创建链接。无论你在何处渲染一个<code>&lt;Link&gt;</code>，都会在应用程序的 HTML 中渲染锚（<code>&lt;a&gt;</code>）。</li><li>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向。</li></ol></li></ol></li><li>React-Router怎么设置重定向？<ol><li>使用<code>&lt;Redirect&gt;</code>组件实现路由的重定向：</li></ol></li><li>react-router 里的 Link 标签和 a 标签的区别<ol><li>从最终渲染的 DOM 来看，这两者都是链接，都是 标签，</li><li>区别是∶ <code>&lt;Link&gt;是react-router</code> 里实现路由跳转的链接，一般配合<code>&lt;Route&gt; </code>使用，<code>react-router</code>接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的<code>&lt;Route&gt;</code>对应的页面内容更新，而不会刷新整个页面。</li><li><code>&lt;Link&gt;</code>做了3件事情:<ol><li>有onclick那就执行onclick</li><li>click的时候阻止a标签默认事件</li><li>根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而<a>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</li></ol></li><li>a标签默认事件禁掉之后做了什么才实现了跳转? <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> domArr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>[...domArr].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        location.<span class="hljs-property">href</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">href</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>React-Router如何获取URL的参数和历史对象？<ol><li>get传值<ol><li>路由配置还是普通的配置，如：’admin’，传参方式如：’admin?id&#x3D;’1111’’。通过this.props.location.search获取url获取到一个字符串’?id&#x3D;’1111’ 可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。</li></ol></li><li>动态路由传值<ol><li>路由需要配置成动态路由：如path&#x3D;’&#x2F;admin&#x2F;:id’，传参方式，如’admin&#x2F;111’。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取</li></ol></li><li>通过query或state传值<ol><li>传参方式如：在Link组件的to属性中可以传递对象{pathname:’&#x2F;admin’,query:’111’,state:’111’};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。</li></ol></li><li>获取历史对象<ol><li>如果React &gt;&#x3D; 16.8 时可以使用 React Router中提供的Hooks useHistory</li><li>使用this.props.history获取历史对象</li></ol></li></ol></li><li>React-Router 4怎样在路由变化时重新渲染同一个组件？<ol><li>当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据</li><li>利用生命周期componentWillReceiveProps，进行重新render的预处理操作。</li></ol></li><li>React-Router的路由有几种模式？<ol><li>React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：<ol><li>BrowserRouter 创建的 URL 格式：xxx.com&#x2F;path</li><li>HashRouter 创建的 URL 格式：xxx.com&#x2F;#&#x2F;path</li></ol></li><li>BrowserRouter<ol><li>它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span></span><br><span class="hljs-tag">    <span class="hljs-attr">basename</span>=<span class="hljs-string">&#123;string&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">forceRefresh</span>=<span class="hljs-string">&#123;bool&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">getUserConfirmation</span>=<span class="hljs-string">&#123;func&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyLength</span>=<span class="hljs-string">&#123;number&#125;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure></li><li>HashRouter 使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，HashRouter 是通过 URL 的 hash 属性来控制路由跳转的： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">HashRouter</span></span><br><span class="hljs-tag">    <span class="hljs-attr">basename</span>=<span class="hljs-string">&#123;string&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">getUserConfirmation</span>=<span class="hljs-string">&#123;func&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">hashType</span>=<span class="hljs-string">&#123;string&#125;</span>  </span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>React-Router 4的Switch有什么用？<ol><li>Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <Route> 或 <Redirect>，它里面不能放其他元素。</li><li>精确匹配路径</li></ol></li><li>React setState 调用的原理<ol><li>具体的执行过程如下（源码级解析）：<ol><li>首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li><li>enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；</li><li>在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。</li><li>注意：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</li></ol></li></ol></li><li>React setState 调用之后发生了什么？是同步还是异步？<ol><li>React中setState后发生了什么<ol><li>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</li><li>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</li><li>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</li></ol></li><li>setState 是同步还是异步的<ol><li>异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li><li>同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</li></ol></li></ol></li><li>React中的setState批量更新的过程是什么？<ol><li>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</li><li>需要注意：只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</li></ol></li><li>React中有使用过getDefaultProps吗？它有什么作用？<ol><li>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）</li></ol></li><li>React中setState的第二个参数作用是什么？<ol><li>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值</li></ol></li><li>React中的setState和replaceState的区别是什么？<ol><li>setState()用于设置状态对象，<code>setState(object nextState[, function callback])</code><ol><li>nextState，将要设置的新状态，该状态会和当前的state合并</li><li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</li><li>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</li></ol></li><li>replaceState()<ol><li>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：<code>replaceState(object nextState[, function callback])</code><ol><li>nextState，将要设置的新状态，该状态会替换当前的state。</li><li>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</li></ol></li></ol></li><li>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</li></ol></li><li>在React中组件的this.state和setState有什么区别？<ol><li>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的</li></ol></li><li>state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程<ol><li>通过connect和mapStateToProps将state注入到组件中</li><li>reducer 到组件经历的过程：<ol><li>reducer对action对象处理，更新组件状态，并将新的状态值返回store。</li><li>通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件</li></ol></li></ol></li><li>React组件的state和props有什么区别？<ol><li>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</li><li>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</li><li>区别<ol><li>props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li><li>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</li><li>state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</li></ol></li></ol></li><li>React中的props为什么是只读的？<ol><li>this.props 是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</li><li>提到函数式编程就要提一个概念：纯函数。它有几个特点：<ol><li>给定相同的输入，总是返回相同的输出。</li><li>过程没有副作用。</li><li>不依赖外部状态。</li></ol></li><li>this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</li></ol></li><li>在React中组件的props改变时更新组件的有哪些方法？<ol><li>在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。</li></ol></li><li>React中怎么检验props？验证props的目的是什么？<ol><li>React为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</li></ol></li><li>Redux 原理及工作流程<ol><li>Redux源码主要分为以下几个模块文件<ol><li>compose.js 提供从右到左进行函数式编程</li><li>createStore.js 提供作为生成唯一store的函数</li><li>combineReducers.js 提供合并多个reducer的函数，保证store的唯一性</li><li>bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作</li><li>applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</li></ol></li><li>工作流程<ol><li>const store&#x3D; createStore（fn）生成数据;</li><li>action: {type: Symble(‘action01), payload:’payload’ }定义行为;</li><li>dispatch发起action：store.dispatch(doSomething(‘action001’));</li><li>reducer：处理action，返回新的state;</li></ol></li><li>通俗点解释：<ol><li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</li><li>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li><li>State—旦有变化，Store就会调用监听函数，来更新View</li></ol></li></ol></li><li>Redux 中异步的请求怎么处理<ol><li>redux-thunk</li><li>redux-saga</li></ol></li><li>Redux 怎么实现属性传递，介绍下原理<ol><li>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：<ol><li>view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()&#x3D;&gt;dispatch(ADD)</li><li>action 的ADD 传到reducer上</li><li>reducer传到store上 const store &#x3D; createStore(reducer);</li><li>store再通过 mapStateToProps 映射穿到view上text:State.text</li></ol></li></ol></li><li>Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？<ol><li>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，</li><li>换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。<ol><li>redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。</li><li>柯里化函数两端一个是 middewares，一个是store.dispatch</li></ol></li></ol></li><li>Redux 请求中间件如何处理并发<ol><li>使用redux-Saga</li></ol></li><li>Redux 状态管理器和变量挂载到 window 中有什么区别<ol><li>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</li></ol></li><li>mobox 和 redux 有什么区别？</li><li>Redux 和 Vuex 有什么区别，它们的共同思想</li><li>Redux 中间件是怎么拿到store 和 action? 然后怎么处理?<br>1. redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })&#x3D;&gt; next &#x3D;&gt; action。</li><li>Redux中的connect有什么作用<br>1. connect负责连接React和Redux<ol><li>获取state</li><li>包装原组件</li><li>监听store tree变化</li></ol></li><li><ul><li></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js</title>
    <link href="/2024/02/28/VueInterviewQuestion/"/>
    <url>/2024/02/28/VueInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7139921537896808479">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/677917087">资料二</a><br><a href="https://juejin.cn/post/7208005892313579576">资料三</a><br><a href="https://juejin.cn/post/7275943802934149160#heading-2">资料四</a><br><a href="https://juejin.cn/post/7227453567686033468#heading-11">资料五</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">Options Api与Composition Api的区别</a></li><li><a href="#question2">Vue3.0性能提升主要是通过哪几方面体现的</a></li><li><a href="#question3">Vue3.0里为什么要用Proxy API 替代defineProperty API</a></li><li><a href="#question4">Vue3响应式原理</a></li><li><a href="#question5">Vue3中Treeshaking特性，举例说明</a></li><li><a href="#question6">Vue3新特性</a></li><li><a href="#question7">Vue3组合式API生命周期钩子函数有变化吗</a></li><li><a href="#question8">watch和watchEffect的区别</a></li><li><a href="#question9">v-if和v-for的优先级哪个高</a></li><li><a href="#question10">script setup是干啥的</a></li><li><a href="#question11">vue2&#x2F;vue3组件通信方式</a></li><li><a href="#question12">ref与reactive的区别</a></li><li><a href="#question13">EventBus与mitt的区别</a></li><li><a href="#question14">谈谈pinia</a></li><li><a href="#question15">vue2和vuex3渲染器的diff算法区别</a></li></ol><h4 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h4><ol><li>请描述下对vue生命周期的理解</li><li>MVVM的理解？</li><li>双向数据绑定是什么</li><li>Vue2.x 响应式原理的理解</li><li>Vue2.x 中如何检测数组的变化？</li><li>Vue组件之间的通信方式都有哪些?</li><li>为什么data属性是一个函数而不是一个对象?</li><li>动态给vue的data添加一个新的属性时会发生什么?怎样解决?</li><li>v—if和v—for的优先级是什么?</li><li>v-show和v—if有什么区别?使用场景分别是什么?</li><li>你知道vue中key的原理吗?说说你对它的理解</li><li>说说你对vue的mixin的理解，有什么应用场景?</li><li>Vue常用的修饰符有哪些有什么应用场景</li><li>Vue中的$next Tick有什么作用?</li><li>Vue实例挂载的过程</li><li>你了解vue的diff算法吗?</li><li>Vue中组件和插件有什么区别?</li><li>Vue项目中你是如何解决跨域的呢?</li><li>有写过自定义指令吗?自定义指令的应用场景有哪些?</li><li>Vue中的过滤器了解吗?过滤器的应用场景有哪些?</li><li>说说你对slot的理解?slot使用场景有哪些?</li><li>什么是虚拟DOM?如何实现一个虚拟DOM?说说你的思路</li><li>Vue项目中有封装过axios吗?主要是封装哪方面的?</li><li>是怎么处理vue项目中的错误的?</li><li>你了解axios的原理吗?有看过它的源码吗?</li><li>vue要做权限管理该怎么做?</li><li>说说你对keep-alive的理解是什么?</li><li>你对SPA单页面的理解,它的优缺点分别是什么?如何实现SPA应用呢</li><li>SPA首屏加载速度慢的怎么解决?</li><li>vue项目本地开发完成后部署到服务器后报404是什么原因呢?</li><li>SSR解决了什么问题?有做过SSR吗?你是怎么做的?</li><li>说一下在 Vue2.x 中如何检测数组的变化？</li><li>如何让 CSS 值在当前的组件中起作用(scoped及其原理</li><li><a href="#scoped">scoped 是如何实现样式穿透的？</a></li><li>Vue 中如何进行组件的使用？Vue 如何实现全局组件的注册？</li><li>构建 vue-cli 工程都用到了哪些技术？他们的作用分别是什么？</li><li>vue-cli 工程常用的 npm 命令有哪些？</li><li><a href="#nextTick">nextTick 的作用是什么？他的实现原理是什么？</a></li><li>说一下 Vue SSR 的实现原理</li><li>说一下 Vue 的 computed 的实现原理</li><li>说一下 Vue complier 的实现原理是什么样的？</li><li>vue 如何快速定位那个组件出现性能问题的</li><li>Vue 与 Angular 以及 React 的区别是什么？</li><li><a href="#watchcomputed">说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？</a></li><li>说一下 ref 的作用是什么？</li><li>说一下你知道的 vue 修饰符都有哪些？</li><li>如何实现 vue 项目中的性能优化？</li><li><a href="extend">Vue.extend 和 Vue.component 的区别是什么？</a></li><li>vue 中的 spa 应用如何优化首屏加载速度?</li><li>移动端如何实现一个比较友好的 header 组件</li><li>既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？</li><li>Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？</li><li><a href="#question53">你的接口请求一般放在哪个生命周期中？为什么要这样做？</a></li><li><a href="#question54">说一下你对 vue 事件绑定原理的理解？</a></li><li>说一下 vue 模版编译的原理是什么</li><li><a href="#question56">delete 和 Vue.delete 删除数组的区别是什么？</a></li><li>v-on 可以实现监听多个方法么？</li><li>vue 的数据为什么频繁变化但只会更新一次？</li><li>说一下 vue 中 computed 和 methods 的区别是什么？</li><li>在 Vue 中要获取当前时间你会放到 computed 还是 methods 里？</li><li>在给 vue 中的元素设置 key 值时可以使用 Math 的 random 方法么？</li><li>插槽与作用域插槽的区别是什么？</li><li>vue 中相同逻辑如何进行抽离？</li><li>如何监听 pushstate 和 replacestate 的变化呢？</li><li>说一说自定义指令有哪些生命周期？</li><li>vue 为什么采用异步渲染</li><li>组件中写 name 选项有哪些好处</li></ol><h4 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h4><ol><li>Vue3.0所采用的Composition Api 与Vue2.x使用的Options Api有什么不同?</li><li>vue3.0的设计目标是什么?做了哪些优化</li><li>用Vue3.0写过组件吗?如果想实现一个Modal你会怎么设计?</li><li>vue3.0性能提升主要是通过哪几方面体现的?</li><li>Vue3.0里为什么要用Proxy API替代defineProperty APl?</li><li>说说Vue 3.0中Treeshaking特性?举例说明—下?</li><li>描述Vu3生命周期</li><li>请介绍Vue3中的Teleport组件。</li><li>如何理解reactive、ref 、toRef 和 toRefs？</li><li>setup中如何获得组件实例？</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><p><a id="question1">Options Api与Composition Api的区别</a></p><ol><li><strong>Option api</strong>：选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑。用组件的选项（data,computed,methods,watch）组织逻辑在大多数情况下都有效。然而，当组件变得复杂，导致对应属性的列表也会增长，这可能导致组件难以阅读和理解。</li><li><strong>Composition api</strong>中，组件根据逻辑功能来组织，一个功能所定义的所有api会放在一起（高内聚，低耦合）</li><li>Composition api 相对 Option api的两大优点<ol><li>逻辑组织 <ol><li>option api在处理一个大型组件时，内部逻辑点容易碎片化，可能同时存在于method，computed，watch等api中，我们必须不断地跳转相关代码的选项块，这种碎片化使得理解和维护复杂组件变得困难。</li><li>Composition api将某个逻辑关注点相关的代码全都放在一个函数里，这样，当需要修改一个功能时，就不再需要在文件中跳来跳去。</li></ol></li><li>逻辑复用<ol><li>在vue2中，当混入多个mixin会存在两个非常明显的问题：命名冲突，数据来源不清晰</li><li>而composition api可以通过编写多个hooks函数就很好地解决了</li></ol></li></ol></li><li>总结：<ol><li>在逻辑组织和逻辑复用方面，Composition API是优于Option API</li><li>因为Composition API几乎是函数，会有更好的类型推断</li><li>Composition API对tree-shaking友好，代码也更容易压缩</li><li>Composition API中见不到this的使用，减少了this指向不明的情况</li><li>如果是小型组件，可以继续使用Option API</li></ol></li></ol></li><li><p><a id="question2">Vue3.0性能提升主要是通过哪几方面体现的</a></p><ol><li>编译阶段优化<ol><li>回顾vue2每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染。因此，vue3在编译阶段，做了进一步优化<ol><li>diff算法优化<ol><li>vue3在diff算法中相比于vue2增加了静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较</li></ol></li><li>静态提升<ol><li>vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。</li><li>没做静态提升之前，未参与更新的元素也在render函数内部，会重复创建阶段。做了静态提升后，未参与更新元素，被放置在render函数外，每次渲染的时候只要取出即可，同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于Diff。</li></ol></li><li>事件监听缓存<ol><li>默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用。</li></ol></li><li>SSR优化<ol><li>当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。</li></ol></li></ol></li></ol></li><li>源码体积<ol><li>相比vue2，vue3整体体积变小了，除了移出一些不常用的API，最重要的是Tree shaking。</li><li>任何一个函数，如ref，reavtived，computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。</li></ol></li><li>响应式系统<ol><li>vue2中采用defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。</li><li>vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。<ol><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组的length属性</li><li>可以监听删除属性</li></ol></li></ol></li></ol></li><li><p><a id="question3">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</a></p><ol><li>vue2中采用defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式，但是存在以下的问题：<ol><li>检测不到对象属性的添加和删除</li><li>数组api方法无法监听到</li><li>需要对每个对象进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ol></li><li>proxy：监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作。</li><li>总结：<ol><li>Object.defineProperty只能遍历对象属性进行劫持</li><li>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的。</li><li>Proxy可以直接监听数组的变化（push，shift，splice）</li><li>Proxy有多达13种拦截方法，不限于apply，ownKeys,deleteProperty,has等等，这是Object.defineProperty不具备的</li></ol></li></ol></li><li><p><a id="question4">Vue3.0响应式原理</a></p><ol><li>vue3响应式是使用ES6的proxy和Reflect相互配合实现数据响应式，解决了vue2中视图不能自动更新的问题。</li><li>proxy是深度监听，所以可以监听对象和数组内的任意元素，从而实现试图实时更新</li><li><a href="https://juejin.cn/post/6858899262596448270">详细的原理</a></li><li>总结响应式大致分为三个阶段：<ol><li>初始化阶段<ol><li>初始化阶段通过组件初始化方法形成对应的proxy对象，然后形成一个负责渲染的effect。</li></ol></li><li>get依赖收集阶段<ol><li>通过解析template，替换真实data属性，来触发get，然后通过stack方法，通过proxy对象和key形成对应的deps，将负责渲染的effect存入deps。（这个过程还有其他的effect，比如watchEffect存入deps中）</li></ol></li><li>set派发更新阶段<ol><li>当我通过this[key] &#x3D; value改变属性的时候，首先通过trigger方法，通过proxy对象和key找到对应的deps，然后给deps分类分成computedRunners和effect，然后依次执行，如果需要调度的，直接放入调度。</li></ol></li></ol></li><li>proxy只会代理对象的第一层，vue3怎么处理<ol><li>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理，这样就实现了深度观测</li></ol></li><li>监测数组时候可能会触发多次get&#x2F;set，如何防治<ol><li>可以判断key是否为当前代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一，才有可能执行trigger。</li></ol></li></ol></li><li><p><a id="question5">说说Vue 3.0中Treeshaking特性？举例说明一下？</a></p><ol><li>是什么<ol><li>tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫Dead code elimination</li><li>保持代码运行结果不变的前提下，去除无用的代码</li><li>vue2中，无论使用什么功能，最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到。</li><li>而vue3源码引入tree shaking特性，将全局API进行分块。如果不使用某些功能，就不会包含在基础包中。</li></ol></li><li>如何做<ol><li>tree shaking是基于ES6模版语法（import和exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量。</li><li>做了两件事：<ol><li>编译阶段利用ES6 Module判断哪些模块已经加载</li><li>判断哪些模块和变量未被使用或者引用，进而删除对应代码</li></ol></li></ol></li><li>作用<ol><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ol></li></ol></li><li><p><a id="question6">Vue3 新特性有哪些？</a></p><ol><li>性能提升<ol><li>Object.defineProperty改为proxy</li><li>重写了Vdom（diff算法优化，增加静态标记）</li><li>进行模版编译优化（静态提升，不参与更新的元素只被创建一次）</li><li>更加高效的组件初始化</li></ol></li><li>更好的支持TypeScript<ol><li>Vue.js 2.x 选用 Flow 做类型检查，来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好。</li><li>Vue.js 3.0 抛弃了 Flow ，使用 TypeScript 重构了整个项目</li><li>TypeScript 提供了更好的类型检查，能支持复杂的类型推断</li></ol></li><li>新增Composition API<ol><li>Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强。</li><li>在 Vue3 中，定义 methods、watch、computed、data数据等都放在了 setup() 函数中。</li><li>setup()函数会在created()生命周期之前执行。执行顺序为：beforeCreate &gt; setup &gt; created</li></ol></li><li>新增组件<ol><li>Fragment 不再限制 template 只有一个根节点。</li><li>Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。</li><li>Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。</li></ol></li><li>Tree-shaking：支持摇树优化<ol><li>摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快。</li></ol></li><li>Custom Renderer API： 自定义渲染器<ol><li>实现 DOM 的方式进行 WebGL 编程。</li></ol></li></ol></li><li><p><a id="question7">vue3 组合式API生命周期钩子函数有变化吗？</a></p><ol><li><img src="/img/js/17091064404677.jpg"></li></ol></li><li><p><a id="question8">watch 和 watchEffect 的区别？</a></p><ol><li>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：<ol><li><p>watch ：既要指明监视的数据源，也要指明监视的回调。</p></li><li><p>而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</p></li><li><p>watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</p></li><li><p>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。</p></li><li><p>watchEffect有点像 computed ：</p><ol><li>但 computed 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。</li><li>而 watcheffect注重的是过程（回调函数的函数体），所以不用写返回值。</li></ol></li><li><p>watch与 vue2.x中 watch 配置功能一致，但也有两个小坑</p><ol><li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，强制开启了深度监视（deep配置失效）</li><li>监视 reactive 定义的响应式数据中某个属性时，deep配置有效。</li></ol> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;你好啊&#x27;</span>)<br><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br><span class="hljs-attr">job</span>:&#123;<br><span class="hljs-attr">j1</span>:&#123;<br><span class="hljs-attr">salary</span>:<span class="hljs-number">20</span><br>&#125;<br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//情况1：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>)<br>&#125;)<br><span class="hljs-comment">//情况2：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum, msg],<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum或msg变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>)<br>&#125;)<br><span class="hljs-comment">//情况3：监视reactive定义的响应式数据</span><br><span class="hljs-comment">//若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue，且强制开启了深度监视。</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person变化了&quot;</span>, newValue, oldValue),(<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>) <span class="hljs-comment">//此处的deep配置不再生效。</span><br>&#125;)<br><span class="hljs-comment">//情况4：监视reactive所定义的一个响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.name变化了&quot;</span>, newValue, oldValue)<br>&#125;)<br><span class="hljs-comment">//情况5：监视reactive所定义的一个响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>, <span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">age</span>],<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.name或person.age变化了&quot;</span>, newValue, oldValue)<br>&#125;)<br><span class="hljs-comment">//特殊情况：</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person.job变化了&quot;</span>, newValue, oldValue)<br>&#125;, &#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)       <br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><a id="question9">v-if 和 v-for 的优先级哪个高？</a></p><ol><li>vue2中v-for优先级高</li><li>vue3中v-if优先级高</li></ol></li><li><p><a id="question10">script setup 是干啥的？</a></p><ol><li>scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：<ol><li>属性和方法无需返回，可以直接使用。</li><li>引入组件的时候，会自动注册，无需通过 components 手动注册。</li><li>使用 defineProps 接收父组件传递的值。</li><li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。</li><li>默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。</li></ol></li></ol></li><li><p><a id="question11">Vue2&#x2F;Vue3组件通信方式？</a></p><ol><li><a href="https://juejin.cn/post/6999687348120190983">详细</a></li><li>vue3通信<ol><li>props</li><li>$emit</li><li>expose&#x2F;ref</li><li>attrs</li><li>v-model</li><li>provide&#x2F;inject</li><li>vuex&#x2F;pinia</li><li>mitt</li></ol></li><li>vue2通信<ol><li>props</li><li>.sync</li><li>v-model</li><li>ref</li><li>$emit&#x2F;v-on</li><li>$attrs&#x2F;$listeners</li><li>$children&#x2F;$parent</li><li>provide&#x2F;inject</li><li>EventBus</li><li>Vuex</li><li>$root</li><li>slot</li></ol></li></ol></li><li><p><a id="question12">ref与reactive的区别？</a></p><ol><li>ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。<ol><li>template 模板中使用的数据和方法，都需要通过 setup 函数 return 出去才可以被使用。</li><li>ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li><li>ref 函数可以接收原始数据类型与引用数据类型。</li><li>reactive 函数只能接收引用数据类型。</li><li>ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li><li>在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li></ol></li></ol></li><li><p><a id="question13">EventBus与mitt区别？</a></p><ol><li>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的 $on&#x2F;$emit&#x2F;$off 等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。</li><li>而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了， Vue3 推荐尽可能使用 props&#x2F;emits、provide&#x2F;inject、vuex 等其他方式来替代。</li><li>当然，如果 Vue3 内部的方式无法满足你，官方建议使用一些外部的辅助库，例如：mitt。其优点如下：<ol><li>非常小，压缩后仅有 200 bytes。</li><li>完整 TS 支持，源码由 TS 编码。</li><li>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</li><li>使用简单，仅有 on、emit、off 等少量实用API。</li></ol></li></ol></li><li><p><a id="question14">谈谈pinia?</a></p><ol><li>Pinia 是 Vue 官方团队成员专门开发的一个全新状态管理库，并且 Vue 的官方状态管理库已经更改为了 Pinia。在 Vuex 官方仓库中也介绍说可以把 Pinia 当成是不同名称的 Vuex 5，这也意味不会再出 5 版本了。</li><li>优点<ol><li>更加轻量级，压缩后提交只有1.6kb。</li><li>完整的 TS 的支持，Pinia 源码完全由 TS 编码完成。</li><li>移除 mutations，只剩下 state 、 actions 、 getters 。</li><li>没有了像 Vuex 那样的模块镶嵌结构，它只有 store 概念，并支持多个 store，且都是互相独立隔离的。当然，你也可以手动从一个模块中导入另一个模块，来实现模块的镶嵌结构。</li><li>无需手动添加每个 store，它的模块默认情况下创建就自动注册。</li><li>支持服务端渲染（SSR）。</li><li>支持 Vue DevTools。</li><li>更友好的代码分割机制，<a href="https://juejin.cn/post/7057439040911441957#heading-2">传送门</a>。</li></ol></li><li>Pinia 配套有个插件 pinia-plugin-persist进行数据持久化，否则一刷新就会造成数据丢失</li></ol></li><li><p><a id="question15">vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</a></p><ol><li>vue2 双端diff算法流程图<ol><li><img src="/img/js/vue2diff.jpg"></li></ol></li><li>vue3 快速diff算法流程图<ol><li><img src="/img/js/vue3diff.jpg"></li></ol></li><li>vue2、vue3 的 diff 算法实现差异<ol><li><ul><li><ol><li>主要体现在：处理完首尾节点后，对剩余节点的处理方式。</li><li>在 vue2 中是通过对旧节点列表建立一个 { key, oldVnode }的映射表，然后遍历新节点列表的剩余节点，根据newVnode.key在旧映射表中寻找可复用的节点，然后打补丁并且移动到正确的位置。</li><li>而在 vue3 中是建立一个存储新节点数组中的剩余节点在旧节点数组上的索引的映射关系数组，建立完成这个数组后也即找到了可复用的节点，然后通过这个数组计算得到最长递增子序列，这个序列中的节点保持不动，然后将新节点数组中的剩余节点移动到正确的位置。</li></ol></li></ul></li><li><ul><li><ol><li>Vue 2.x使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。</li><li>Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能</li><li>因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。</li></ol></li></ul></li></ol></li></ol></li><li><p><a id="scoped">scoped 是如何实现样式穿透的？</a></p><ol><li>在vue文件中的style标签上，有一个特殊的属性：scoped。</li><li>当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，通过该属性，可以使得组件之间的样式不互相污染。</li><li>原理：<ol><li>为组件实例生成一个唯一标识，给组件中的每个标签对应的dom元素添加一个标签属性，data-v-xxxx</li><li>给<style scoped>中的每个选择器的最后一个选择器添加一个属性选择器，原选择器[data-v-xxxx]，如：原选择器为.container #id div，则更改后选择器为.container #id div[data-v-xxxx]</li></ol></li></ol></li><li><p><a id="nextTick">nextTick 的作用是什么？他的实现原理是什么？</a></p><ol><li>Vue 在更新 DOM 时是异步执行的，当数据发生变化，Vue 将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</li><li>this.$nextTick() 的作用就是可以将里面的回调函数延迟下次 DOM 更新循环结束之后执行。在修改数据之后立即使用这个方法，获取更新后的 DOM。</li><li>更新原理<ol><li>vue 里面用到了观察者模式，默认组件渲染的时候，会创建一个 watcher，并且渲染视图</li><li>当渲染视图的时候，会取 data 中的数据，触发属性的 get 方法，就让这个属性的 dep 记录watcher（注意：每一个data属性都对应一个dep）</li><li>同时让 watcher 也记住 dep ，dep 和 watcher 是多对多的关系，因为一个属性可能对应多个视图，一个视图对应多个数据</li><li>如果数据发生变化，也就是在 set 的时候，会触发 dep.notify() ，通知 dep 中存放的 watcher 去更新</li><li>每次更新数据都会同步调用 watcher 中 update 方法，此时就可以将更新的逻辑缓存起来，等会同步更新数据的逻辑执行完毕后，依次调用 (去重的逻辑)</li></ol></li></ol></li><li><p><a id="watchcomputed">watch跟computed的区别</a></p><ol><li>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</li><li>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</li><li>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</li><li>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</li><li>使用场景：computed—-当一个属性受多个属性影响的时候，使用computed—–购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch—–搜索框.</li></ol></li><li><p><a id="extend">Vue.extend 和 Vue.component 的区别是什么？</a></p><ol><li>extend和component作用基本相同，区别在于我们需不需要使用组件名称，不需要使用组件名称时，用extend会简便些；需要使用新的标签来定义组件时，那么就用component去创建组件;</li></ol></li><li><p><a id="ssr">SSR</a></p><ol><li>服务端渲染 SSR (Server-Side Rendering)，是指在服务端完成页面的html 拼接处理， 然后再发送给浏览器，将不具有交互能力的html结构绑定事件和状态，在客户端展示为具有完整交互能力的应用程序。</li><li>适用场景<ol><li>需更好的支持 SEO 优势在于同步。</li><li>需更快的到达时间 优势在于慢网络和运行缓慢的设备场景。</li></ol></li></ol></li><li><p><a id="question51">既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM进⾏diff检测差异?</a></p><ol><li>现在前端框架有两种数据变动侦测方式，一种是pull，一种是push.</li><li>pull 的代表是React ，在进行 setState 操作后显示更新数据，React 会使用 diff 算法一层层找出差异，然后 patch 到 DOM 树上，React 一开始不知道那里变化了，只是知道变化了，然后暴力进行查找那变化了，另一个代表是 Angular 的脏检查。</li><li>Vue 的响应式系统就是 Push 的代表，Vue 初始化的时候就会对 data 的数据进行依赖收集，因此Vue能实时知道那里发生了变化，一般绑定的细粒度过高，会生成大量的Watcher 实例，则会造成过大的内存和依赖追踪的开销，而细粒度过低无法侦测到变化。因此，Vue采用的是中等细粒度的方案，只针对组件级别的进行响应式监听也就是push，这样可以知道那个组件发生了变化，再对组件进行diff算法找到具体变化的位置，这是pull操作，vue是pull + push 结合进行变化侦测的。</li></ol></li><li><p><a id="question53">Vue请求是在Created还是Mounted？</a></p><ol><li>常规生命周期：<ol><li>beforeCreate  &#x2F;&#x2F; 这时候data，methods函数未挂载</li><li>created       &#x2F;&#x2F; data已挂载、methods函数已挂载</li><li>beforeMount   &#x2F;&#x2F; 相关的render函数首次被调用,dom未挂载</li><li>mounted       &#x2F;&#x2F; dom已渲染挂载完成</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ol></li><li>如果我们的请求不需要获取&#x2F;借助&#x2F;依赖&#x2F;改变DOM，这时请求可以放在Created</li><li>反之则可以放在Mounted里</li></ol></li><li><p><a id="question54">vue中的事件绑定原理</a></p><ol><li>原生的事件绑定，原生 dom 事件的绑定,采用的是 addEventListener 实现。</li><li>组件的事件绑定，组件绑定事件采用的是 $on 方法 。<ol><li>给组件绑定一个事件，有两种绑定方法<ol><li>一种@click.native，这个绑定的就是原生事件</li><li>另一种@click，这个绑定的就是组件自定义事件</li><li>为什么组件要加native？因为组件最终会把nativeOn属性放到on的属性中去，这个on会单独处理</li><li>组件中的nativeOn 等价于 普通元素on，组件on会单独处理</li></ol></li></ol></li></ol></li><li><p><a id="question56">delete和Vue.delete的区别</a></p><ol><li>delete只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。数组长度也不变。（逻辑删）</li><li>Vue.delete是直接删除该元素，长度发生变化。（物理删）</li></ol></li><li><p><a id="question65">自定义指令有哪些生命周期？</a></p><ol><li>bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。</li><li>inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。</li><li>update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</li><li>componentUpdated:被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind:只调用一次，指令与元素解绑时调用。</li></ol></li><li><p><a id="question67">组件中写 name 选项有哪些好处</a></p><ol><li>增加 name 属性，可以实现组件递归调⽤自身，调用的时候用的就是 name 名字</li><li>可以表示组件的具体名称，⽅便调试和查找对应的组件 比如说 keep-alive 的 include 和 exclude 就是通过组件的 name 属性区分谁缓存谁不缓存的</li></ol></li><li><p><a id="question66">为什么vue采用异步渲染</a></p><ol><li>因为不采用异步更新，在每次更新数据都会对当前组件进行重新渲染。所以为了性能考虑，vue 会在本轮数据更新后，再去异步更新视图。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文</title>
    <link href="/2024/02/19/frontInterviewQuestion/"/>
    <url>/2024/02/19/frontInterviewQuestion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45712370/article/details/134951791">资料一</a><br><a href="https://zhuanlan.zhihu.com/p/677919386">资料二</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><a href="#question1">js的数据类型及他们的区别</a></li><li><a href="#question2">判断数据类型的几种方法</a></li><li><a href="#question3">作用域和作用域链</a></li><li><a href="#question4">原型和原型链</a></li><li><a href="#question5">闭包</a></li><li><a href="#question6">内存泄漏，垃圾回收机制</a></li><li><a href="#question7">js获取dom</a></li><li><a href="#question8">浅拷贝和深拷贝</a></li><li><a href="#question9">route和router的区别详解</a></li><li><a href="#question10">如何改变this指向（call，apply，bind区别）</a></li><li><a href="#question11">箭头函数与普通函数区别</a></li><li><a href="#question12">浏览器存储的区别</a></li><li><a href="#question13">继承方式</a></li><li><a href="#question14">常用的数组方法</a></li><li><a href="#question15">什么是promise</a></li><li><a href="#question16">async，await</a></li><li><a href="#question17">宏任务和微任务以及执行顺序</a></li><li><a href="#question18">var let const的区别</a></li><li><a href="#question19">ES6的新特性</a></li><li><a href="#question20">从浏览器输入url后都经历了什么</a></li><li><a href="#question21">TCP协议和HTTP协议</a></li><li><a href="#question22">http和https区别</a></li><li><a href="#question23">如何解决前端跨域问题</a></li><li><a href="#question24">websocket和webwork</a></li><li><a href="#question25">性能优化</a></li><li><a href="#question26">Webpack是什么</a></li><li><a href="#question27">Webpack的基本功能？</a></li><li><a href="#question28">标准盒模型和怪异盒模型（IE盒模型）</a></li><li><a href="#question29">让一个元素水平&#x2F;垂直居中</a></li><li><a href="#question30">flex：1代表什么</a></li><li><a href="#question31">回溯算法</a></li><li><a href="#question32">冒泡算法排序</a></li><li><a href="#question33">快速排序</a></li><li><a href="#question34">什么是MVVM，MVC模型</a></li><li><a href="#question35">写react&#x2F;vue项目中为什么要在列表组件中写key，其作用是什么</a></li><li><a href="#question36"><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code></a></li><li><a href="#question37">防抖和节流的区别和实现</a></li><li><a href="#question38">Set,Map.WeakSet和WeakMap的区别</a></li><li><a href="#question39">深度优先遍历和广度优先遍历的实现</a></li><li><a href="#question40">分别用深度优先思想和广度优先思想实现一个拷贝函数</a></li><li><a href="#question41">ES5&#x2F;ES6的继承除了写法之外还有什么区别</a></li><li><a href="#question42">setTimeout,Promise,Async&#x2F;Await的区别</a></li><li><a href="#question43">Async&#x2F;Await如何通过同步的方式实现异步</a></li><li><a href="#question44">JS异步解决方案的发展历程以及优缺点</a></li><li><a href="#question45">Promise构造函数是同步执行还是异步执行，then呢</a></li><li><a href="#question46">如何实现一个new</a></li><li><a href="#question47">简单阐述http2的多路复用</a></li><li><a href="#question48">TCP的三次握手和四次挥手</a></li><li><a href="#question49">A，B机器正常连接后，B机器突然重启，A处于TCP什么状态</a></li><li><a href="#question50">react中setState什么时候是同步的，什么时候是异步的</a></li><li><a href="#question51">npm模块安装机制，为什么输入npm install就可以自动安装对应的</a></li><li><a href="#question52">重绘和回流及如何优化</a></li><li><a href="#question53">观察者模式和订阅-发布模式区别，各自适用什么场景</a></li><li><a href="#question54">Redux和Vuex的设计思想</a></li><li><a href="#question55">浏览器和Node事件循环的区别</a></li><li><a href="#question56">介绍模块化发展历程</a></li><li><a href="#question57">全局作用域中，用const和let声明的变量不在window上，那到底在哪</a></li><li><a href="#question58">cookie和token都存放在header中，为什么不会劫持token</a></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol><li><a id="question1">Js的数据类型有哪些他们的区别是什么</a><ol><li>基本数据类型(存储在内存中<ol><li>String</li><li>Number</li><li>Boolean</li><li>Null</li><li>undefined</li><li>Symbol</li></ol></li><li>引用数据类型（存储的是对象在内存中的地址<ol><li>Object</li><li>Array</li><li>Date</li><li>Function</li></ol></li><li>区别<ol><li>存储方式：基本数据类型直接存储数据值，而引用数据类型存储的是对象的引用</li><li>内存占用：基本数据类型占用固定的内存空间，而引用数据类型的大小取决于对象的大小。</li><li>赋值方式：基本数据类型的赋值是通过将值直接复制给变量，而引用数据类型的赋值是将对象的引用赋给变量。</li><li>传递方式：基本数据类型作为参数传递时，传递的是值的副本，而引用数据类型作为参数传递时，传递的是引用的副本。</li></ol></li></ol></li><li><a id="question2">判断数据类型有几种方法</a><ol><li><strong>typeof</strong><ol><li>其中typeof返回的类型都是字符串形式</li><li>缺点：typeof null的值为Object，无法分辨是null还是Object</li><li><code>alert(typeof &quot;helloworld&quot;)</code></li></ol></li><li><strong>instanceof</strong><ol><li>instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。</li><li><code>[1,2,3] instanceof Array </code></li></ol></li><li><strong>Object.prototype.toString.call</strong><ol><li>（适用于所有类型的判断检测,注意区分大小写. toString方法,在Object原型上返回数据格式,）</li><li><code>console.log(Object.prototype.toString.call(&quot;123&quot;))           --------&gt;[object String]</code></li></ol></li><li><strong>constructor</strong><ol><li>constructor 判断方法跟instanceof相似,但是constructor检测Object与instanceof不一样,constructor还可以处理基本数据类型的检测,不仅仅是对象类型</li><li><code>console.log(A.constructor === B)</code></li></ol></li><li><strong>jquery.type()</strong><ol><li>如果对象是null跟undefined,直接返回”null”和”undefined”,</li><li><code>console.log(jQuery.type(undefined) === &quot;undefined&quot;)           --------&gt;true</code></li></ol></li><li><strong>&#x3D;&#x3D;&#x3D;</strong><ol><li>有局限的判断:严格运算符&#x3D;&#x3D;&#x3D;</li></ol></li><li>总结<ol><li>一般变量用typeof</li><li>已知对象类型用instanceof</li><li>通用方法Object.prototype.toString.call()</li></ol></li></ol></li><li><a id="question3">作用域和作用域链</a><ol><li>作用域：规定变量和函数的可使用范围称作作用域</li><li>作用域链：每个函数都有一个作用域链，查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作作用域链</li></ol></li><li><a id="question4">原型和原型链</a><ol><li>原型：<ol><li>原型分为隐式原型和显式原型，每个对象都有一个隐式原型，它指向自己的构造函数的显式原型</li><li>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法</li></ol></li><li>原型链：<ol><li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li><li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li></ol></li><li>原型和原型链的区别<ol><li>原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法</li></ol></li></ol></li><li><a id="question5">什么是闭包</a><ol><li>JS中内层函数可以访问外层函数的变量，使内部私有变量不受外界干扰，起到保护和保存的作用，我们把这个特性称作闭包。</li><li>好处<ol><li>隔离作用域，保护私有变量；有了闭包才有局部变量，要不然都是全局变量了。</li><li>让我们可以使用回调，操作其他函数内部；</li><li>变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；</li></ol></li><li>坏处<ol><li>内层函数引用外层函数变量，内层函数占用内存。如果不释放内存，过多时，易引起内存泄露</li></ol></li><li>引用场景<ol><li>for循环中的保留i的操作 </li><li>防抖和节流</li></ol></li></ol></li><li><a id="question6">内存泄露、垃圾回收机制</a><ol><li>内存泄露：是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏，内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃。</li><li>垃圾回收机制：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清除或释放内存。（标记清除&#x2F;引用计数）</li></ol></li><li><a id="question7">Js获取dom</a><ol><li>getElementById</li><li>getElementByClassName</li><li>getElementByTagName</li><li>querySelector</li><li>querySelectorAll</li></ol></li><li><a id="question8">浅拷贝与深拷贝</a><ol><li>浅拷贝<ol><li><strong>Object.assign()</strong><ol><li><code>Object.assign(target, ...sources)</code></li></ol></li><li><strong>…</strong><ol><li><code>let objClone = &#123; ...obj &#125;;</code></li></ol></li><li>Array.prototype.<strong>concat</strong>()拷贝数组</li><li>Array.prototype.<strong>slice</strong>()拷贝数组</li><li>手动实现 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">shallowClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span> !== <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">const</span> cloneTarget = Array.isArray(<span class="hljs-keyword">target</span>) ? [] : &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (let prop in <span class="hljs-keyword">target</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span>.hasOwnProperty(prop)) &#123;<br>                cloneTarget[prop] = <span class="hljs-keyword">target</span>[prop];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneTarget;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> shallowCloneObj = shallowClone(obj)<br><br>shallowCloneObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>shallowCloneObj.arr === obj.arr  <span class="hljs-comment">// true，对于对象类型只拷贝了引用</span><br></code></pre></td></tr></table></figure></li></ol></li><li>深拷贝<ol><li><strong>JSON.parse(JSON.stringify(target));</strong></li><li><strong>递归基础版深拷贝</strong> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">deepClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span>) &#123;<br>        let cloneObj = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key in <span class="hljs-keyword">target</span>) &#123; <span class="hljs-comment">// 遍历</span><br>            <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">target</span>[key]<br>            <span class="hljs-keyword">if</span> (typeof val === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; val) &#123;<br>                cloneObj[key] = deepClone(val) <span class="hljs-comment">// 是对象就再次调用该函数递归</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cloneObj[key] = val <span class="hljs-comment">// 基本类型的话直接复制值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneObj<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 开头的测试obj存在循环引用，除去这个条件进行测试</span><br><span class="hljs-keyword">const</span> clonedObj = deepClone(obj)<br><br><span class="hljs-comment">// 测试</span><br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.arr === obj.arr  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br></code></pre></td></tr></table></figure></li><li><strong>递归完美版深拷贝</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">// WeakMap作为记录对象Hash表（用于防止循环引用）</span><br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br>    <span class="hljs-comment">// 判断是否为object类型的辅助函数，减少重复代码</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target ) || <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">data</span>) &#123;<br><br>        <span class="hljs-comment">// 基础类型直接返回值</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(data)) &#123;<br>            <span class="hljs-keyword">return</span> data<br>        &#125;<br><br>        <span class="hljs-comment">// 日期或者正则对象则直接构造一个新的对象返回</span><br>        <span class="hljs-keyword">if</span> ([<span class="hljs-title class_">Date</span>, <span class="hljs-title class_">RegExp</span>].<span class="hljs-title function_">includes</span>(data.<span class="hljs-property">constructor</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> data.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>)<br>        &#125;<br><br>        <span class="hljs-comment">// 处理函数对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + data.<span class="hljs-title function_">toString</span>())()<br>        &#125;<br><br>        <span class="hljs-comment">// 如果该对象已存在，则直接返回该对象</span><br>        <span class="hljs-keyword">const</span> exist = map.<span class="hljs-title function_">get</span>(data)<br>        <span class="hljs-keyword">if</span> (exist) &#123;<br>            <span class="hljs-keyword">return</span> exist<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Map对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：map中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Set对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：set中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">add</span>(val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 收集键名（考虑了以Symbol作为key以及不可枚举的属性）</span><br>        <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(data)<br>        <span class="hljs-comment">// 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性以及对应的属性描述</span><br>        <span class="hljs-keyword">const</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(data)<br>        <span class="hljs-comment">// 结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链， 这里得到的result是对data的浅拷贝</span><br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(data), allDesc)<br><br>        <span class="hljs-comment">// 新对象加入到map中，进行记录</span><br>        map.<span class="hljs-title function_">set</span>(data, result)<br><br>        <span class="hljs-comment">// Object.create()是浅拷贝，所以要判断并递归执行深拷贝</span><br>        keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> val = data[key]<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                <span class="hljs-comment">// 属性值为 对象类型 或 函数对象 的话也需要进行深拷贝</span><br>                result[key] = <span class="hljs-title function_">clone</span>(val)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[key] = val<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">clone</span>(target)<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> clonedObj = <span class="hljs-title function_">deepClone</span>(obj)<br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.<span class="hljs-property">arr</span> === obj.<span class="hljs-property">arr</span>  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br>clonedObj.<span class="hljs-property">func</span> === obj.<span class="hljs-property">func</span>  <span class="hljs-comment">// false，说明function也复制了一份</span><br>clonedObj.<span class="hljs-property">proto</span>  <span class="hljs-comment">// proto，可以取到原型的属性</span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><a id="question9">route和router的区别详解</a><ol><li>router是用来操作路由的</li><li>route是用来获取路由信息的。 $route.path $route.params route.query等</li></ol></li><li><a id="question10">如何改变this指向（call、apply与bind区别）</a><ol><li>call、bind、apply 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法。</li><li>传参 call、bind可以传递无数个参数，apply只有两个参数，第二个参数为数组</li><li>返回 call和apply方法是直接调用函数并改变函数上下文，而bind方法则是返回一个新函数，稍后调用时绑定指定的上下文。</li></ol></li><li><a id="question11">箭头函数和普通函数的区别</a><ol><li>箭头函数是普通函数的简写，但是它不具备很多普通函数的特性</li><li>箭头函数都是匿名函数</li><li>箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply();普通函数的this指向调用它的那个对象</li><li>没有arguments对象，不能使用arguments,取而代之用rest参数…解决</li><li>不会进行函数提升</li><li>箭头函数不能用于构造函数，不能使用new</li></ol></li><li><a id="question12">浏览器存储，他们的区别？</a><ol><li>localStorage：永久保存，以键值对保存，存储空间5M</li><li>sessionStorage：关闭页签&#x2F;浏览器时清空</li><li>cookie：随着请求发送，通过设置过期时间删除</li><li>session：保存在服务端</li><li>ocalStorage&#x2F;sessionStorage是window的属性，cookie是document的方法</li></ol></li><li><a id="question13">继承方式有哪些</a><ol><li><strong>原型链继承</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>());<br></code></pre></td></tr></table></figure></li><li>因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</li></ol></li><li><strong>构造函数继承（借助 call）</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title class_">Parent1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child1&#x27;</span><br>&#125;<br>         <br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child);  <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure></li><li>它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</li></ol></li><li><strong>组合继承（前两种组合）</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span> () &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>         <br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第二次调用 Parent3()</span><br>  <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span>;<br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>);  <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><strong>原型式继承</strong><ol><li>ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let parent4 = &#123;<br>  <span class="hljs-type">name</span>: &quot;parent4&quot;,<br>  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],<br>  getName: <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">return</span> this.name;<br>  &#125;<br>&#125;;<br>         <br>let person4 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person4.name = &quot;tom&quot;;<br>person4.friends.push(&quot;jerry&quot;);<br>let person5 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person5.friends.push(&quot;lucy&quot;);<br>         <br>console.log(person4.name);<br>console.log(person4.name === person4.getName());<br>console.log(person5.name);<br>console.log(person4.friends);<br>console.log(person5.friends);<br></code></pre></td></tr></table></figure></li><li>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能</li></ol></li><li><strong>寄生式继承</strong><ol><li>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> parent5 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent5&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original);<br>  clone.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person5 = <span class="hljs-title function_">clone</span>(parent5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li></ol></li><li><strong>寄生组合式继承</strong><ol><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (parent, child) &#123;<br>  <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br> <span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>);<br>         <br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li><li>结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式</li></ol></li><li>ES6 的 extends 关键字实现逻辑<ol><li>code <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>  &#125;<br>  <span class="hljs-comment">// 原型方法</span><br>  <span class="hljs-comment">// 即 Person.prototype.getName = function() &#123; &#125;</span><br>  <span class="hljs-comment">// 下面可以简写为 getName() &#123;...&#125;</span><br>  getName = function () &#123;<br>    console.log(&#x27;<span class="hljs-type">Person</span>:&#x27;, <span class="hljs-keyword">this</span>.name)<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gamer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name, age) &#123;<br>    <span class="hljs-comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-keyword">super</span>(name)<br>    <span class="hljs-keyword">this</span>.age = age<br>  &#125;<br>&#125;<br> <br>const asuna = <span class="hljs-keyword">new</span> <span class="hljs-type">Gamer</span>(&#x27;<span class="hljs-type">Asuna</span>&#x27;, <span class="hljs-number">20</span>)<br>asuna.getName() <span class="hljs-comment">// 成功访问到父类的方法</span><br></code></pre></td></tr></table></figure></li><li>通过编译解码可以发现，extends内步也是采用的寄生组合继承方式。</li></ol></li></ol></li><li><a id="question14">常用的数组方法有哪些？</a><ol><li>改变原数组<ol><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>sort</li><li>splice</li><li>reverse</li></ol></li><li>不改变原数组<ol><li>concat</li><li>join</li><li>map</li><li>forEach</li><li>filter</li><li>slice</li></ol></li></ol></li><li><a id="question15">什么是Promise</a><ol><li>Promise异步编程的一种解决方案。Promise是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br><span class="hljs-comment">//做一些异步操作</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行完成Promise&#x27;</span>);<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>Promise对象有三种状态，他们分别是 pending（等待中） resolved（已完成）rejected（拒绝）</li><li>Promise.all哪怕一个请求失败了也能得到其余正确的请求结果的解决方案</li><li>promise 的then会返回一个新的 promise 对象，能保证 then 方 可以进行链式调用</li></ol></li><li><a id="question16">async、await</a><ol><li>Async 和 await 是一种同步的写法，但还是异步的操作，两个必须配合一起使用</li><li>函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西，如果是promise则会等待promaise 返回结果，接普通函数直接进行链式调用</li><li>如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错，await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行</li><li>async&#x2F;await 的优势在于处理 then 链;单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</li></ol></li><li><a id="question17">宏任务和微任务有哪些？执行顺序</a><ol><li>宏任务<ol><li>script</li><li>setTimeout</li><li>setInterval</li></ol></li><li>微任务<ol><li>Promise</li><li>process.nextTick</li></ol></li><li>微任务会优先于宏任务执行。这意味着在当前任务执行结束后，所有微任务都会被立即执行，而宏任务只有在所有微任务执行完毕后才会执行。</li></ol></li><li><a id="question18">var  let  const的区别</a><ol><li>var声明的变量存在变量提升，即变量可以在声明之前调用，var允许重复声明变量var不存在块级作用域</li><li>let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</li><li>let和const存在块级作用域</li><li>let和const在同一作用域不允许重复声明变量</li><li>const声明的是常量，常量不可以修改</li><li>const变量不能修改指针，但是可以修改值，比如我们定义一个对象，我们就可以修改对象里的属性值，但是不可以重写整个对象。</li></ol></li><li><a id="question19">ES6新特性</a><ol><li>模版字符串</li><li>箭头函数</li><li>拓展运算符</li><li>map和set</li><li>promise和proxy</li><li>数组方法from,map,filter,forEach,some,every</li><li>等等</li></ol></li><li><a id="question20">从浏览器输入url后都经历了什么</a><ol><li>浏览器输入域名</li><li>浏览器查找域名的ip地址<ol><li>查找浏览器缓存</li><li>查找系统缓存</li><li>查找路由缓存</li><li>递归查询</li><li>迭代查询</li></ol></li><li>浏览器与目标服务器建立tcp连接<ol><li>三次握手</li></ol></li><li>浏览器通过http协议发送请求</li><li>某些服务器会做永久重定向响应</li><li>浏览器跟踪重定向地址</li><li>服务器处理请求</li><li>服务器发出一个HTML响应</li><li>释放tcp连接<ol><li>四次挥手</li></ol></li><li>浏览器显示页面</li><li>浏览器发送获取嵌入在html中的其他内容</li></ol></li><li><a id="question21">TCP协议和HTTP 协议</a><ol><li>TCP协议在建立过程中会进行三次握手四次挥手，三次握手确保双方同步并避免无效连接，四次挥手则正常终止连接或异常终止连接。</li><li>HTTP协议是超文本传输协议（Hyper Text Transfer Protocol），是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的。</li></ol></li><li><a id="question22">HTTP与HTTPS有什么区别</a><ol><li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</li></ol></li><li><a id="question23">如何解决前端跨域问题</a><ol><li>jsonp</li><li>CORS</li><li>postMessage</li><li>document.domain</li><li>window.name</li><li>location.hash</li><li>http-proxy</li><li>nginx代理</li><li>nodejs中间件代理</li><li>WebSocket协议跨域<ol><li>webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信。</li></ol></li></ol></li><li><a id="question24">WebSocket和webwork</a><ol><li>WebSocket作用是即使通信双向通信，webwork是多进程的</li><li><a href="https://blog.csdn.net/zxc123401/article/details/131491466">资料详解</a></li></ol></li><li><a id="question25">性能优化</a><ol><li>异步组件：对于较大的组件，可以使用异步组件进行延迟加载，提高页面加载速度。</li><li>列表性能优化：对于大数据列表，使用虚拟滚动或分页加载来减少渲染的数据量。</li><li>图片优化：使用适当的图片压缩和懒加载，并提供多种分辨率的图片，以避免不必要的网络负载。</li><li>组件懒加载：将页面按需加载，只加载当前视图所需的组件，减少首次加载的体积和渲染时间。</li><li>减少重绘和回流：合理使用CSS样式，避免频繁的DOM操作，以减少页面的重绘和回流。</li><li>接口过慢：后端优化接口，分段式请求接口，对加载过慢的接口做过度动画提升用户体验。</li><li>使用浏览器缓存：在合适的情况下，使用浏览器缓存可以显著减少请求时间，提高页面加载速度。</li></ol></li><li><a id="question26">Webpack是什么</a><ol><li>Webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。</li><li>它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。</li><li>对于不同类型的依赖，Webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</li></ol></li><li><a id="question27">Webpack的基本功能？</a><ol><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li><li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li><li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ol></li><li><a id="question28">盒模型和怪异盒模型</a><ol><li>标准盒模型总宽度&#x3D;**width+margin(左右)+padding(左右)border(左右)**。box-sizing:<strong>centent-box</strong></li><li>怪异盒模型的总宽度&#x3D;width+margin(左右)( width已经包含了padding和border值)。box-sizing:<strong>border-box</strong></li></ol></li><li><a id="question29">让一个元素水平&#x2F;垂直居中</a><ol><li>父、子元素宽高未知时<ol><li><strong>table-cell</strong>（使用表格样式）</li><li><strong>flex</strong> 布局（父级 justify-content: center 和 align-items: center 即可）</li><li><strong>absolute + transform</strong>（定位的上、左为 50%，translate 上、左负 50%）</li><li><strong>absolute + margin: auto</strong>（定位的上下左右为 0）</li><li><strong>Grid</strong> 网格布局</li><li>直接使用 <strong>table</strong>（改变结构实现，和第一条类似）</li></ol></li><li>子元素固定宽高已知时（假设子元素宽高为 200px）<ol><li><strong>absolute + calc</strong>（定位上、左负50%时减去子元素宽、高）</li><li><strong>absolute + 负margin</strong>（定位的上、左为 50%，margin 的上、左负子元素的一半）</li></ol></li><li>父元素高度已知（假设为 400px），子元素宽高未知<ol><li><strong>text-align + vertical-align</strong></li></ol></li></ol></li><li><a id="question30">flex:1 到底代表什么 </a><ol><li>是一个简写方式，相当于同时设置了 <code>flex-grow: 1</code>、<code>flex-shrink: 1</code>、<code>flex-basis: 0</code> 这三个属性。满足项目的自适应需求。</li></ol></li><li><a id="question31">回溯算法</a><ol><li>数组arr[1,2,3] 输出结果[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]</li><li>定义一个空数组res，用于存储所有的排列结果。</li><li>定义一个空数组path，用于存储当前的排列结果。</li><li>编写回溯函数backtrack，函数参数为当前的排列结果path和可选的数字列表nums。</li><li>如果nums为空，说明已经选完了所有的数字，将path加入到res中。</li><li>遍历nums中的每个数字，将其加入到path中，然后从nums中删除该数字，递归调用backtrack函数。</li><li>递归结束后，将path中的最后一个数字删除，将该数字加入到nums中，回溯到上一层。</li><li>调用backtrack函数，开始全排列。</li><li>code<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">def permute(nums):<br>    <span class="hljs-keyword">res</span> = []<br>    path = []<br>    def backtrack(path, nums):<br>        <span class="hljs-keyword">if</span> not nums:<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            path.<span class="hljs-keyword">append</span>(nums[i])<br>            backtrack(path, nums[:i]+nums[i+<span class="hljs-number">1</span>:])<br>            path.<span class="hljs-keyword">pop</span>()<br>    backtrack(path, nums)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br> <br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">res</span> = permute(arr)<br><span class="hljs-keyword">for</span> r in <span class="hljs-keyword">res</span>:<br>    <span class="hljs-keyword">print</span>(r)<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question32">冒泡算法排序</a><ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-comment">/* 1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。</span><br><span class="hljs-comment">    　　　2.第一轮的时候最后一个元素应该是最大的一个。</span><br><span class="hljs-comment">    　　　3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> temp = arr[j]<br>        arr[j] = arr[j + <span class="hljs-number">1</span>]<br>        arr[j + <span class="hljs-number">1</span>] = temp<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>     <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br>bubbleSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question33">快速排序</a><ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/*</span><br><span class="hljs-comment">快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。</span><br><span class="hljs-comment">然后递归调用，在两边都实行快速排序。  </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr<br>  &#125;<br>  <span class="hljs-keyword">var</span> middle = Math.<span class="hljs-built_in">floor</span>(arr.<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">var</span> middleData = arr.<span class="hljs-built_in">splice</span>(middle, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br> <br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">left</span> = []<br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">right</span> = []<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; middleData) &#123;<br>      <span class="hljs-built_in">left</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">right</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> quickSort(<span class="hljs-built_in">left</span>).concat([middleData], quickSort(<span class="hljs-built_in">right</span>))<br>&#125;<br> <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br><span class="hljs-keyword">var</span> newArr = quickSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question34">什么是MVVM，MVC模型</a><ol><li>M V C:Model View Controller<ol><li>Controller负责将Model的数据用View显示出来。</li></ol></li><li>M V VM 视图模型双向绑定<ol><li>Model，View，ViewModel</li><li>Model 和 View 并无直接关联，而是通过 ViewModel 来进行交互的（即双向数据绑定），</li><li>View的变化可以引起Model的变化，Model的变化也可以引起View变化（类似于浅拷贝）。ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</li><li>使用：react vue</li></ol></li></ol></li><li><a id="question35">写React &#x2F; Vue项目时为什么要在列表组件中写key，其作用是什么?</a><ol><li>key是给每一个vnode的唯一id,可以依靠key,更准确,更快的拿到oldVnode中对应的vnode节点</li></ol></li><li><a id="question36">[‘1’, ‘2’, ‘3’].map(parseInt)</a><ol><li><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map((value, index) =&gt; &#123;  parseInt(value, index);&#125;);</code></li><li>相当于执行<ol><li>parseInt(‘1’, 0) &#x2F;&#x2F; radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。返回1</li><li>parseInt(‘2’, 1) &#x2F;&#x2F; 基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li><li>parseInt(‘3’, 2) &#x2F;&#x2F; 基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</li></ol></li><li>结果：<code>[1, NaN, NaN]</code></li></ol></li><li><a id="question37">什么是防抖和节流?有什么区别?如何实现?</a><ol><li>防抖<ol><li>所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</li></ol></li><li>节流<ol><li>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。</li></ol></li><li><strong>防抖就是回城，节流就是放技能</strong></li></ol></li><li><a id="question38">介绍下Set、 Map. WeakSet 和WeakMap的区别?</a><a href="https://juejin.cn/post/6981747653323276319">详解</a><ol><li>Set<ol><li>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</li><li>Set 本身是一种构造函数，用来生成 Set 数据结构。</li><li>Set 实例属性<ol><li>constructor： 构造函数</li><li>size：元素数量</li></ol></li><li>Set 实例方法<ol><li>操作方法<ol><li>add(value)：新增，相当于 array里的push</li><li>delete(value)：存在即删除集合中value</li><li>has(value)：判断集合中是否存在 value</li><li>clear()：清空集合</li></ol></li><li>遍历方法（遍历顺序为插入顺序）<ol><li>keys()：返回一个包含集合中所有键的迭代器</li><li>values()：返回一个包含集合中所有值得迭代器</li><li>entries()：返回一个包含Set对象中所有元素得键值对迭代器</li><li>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值</li><li>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致</li></ol></li></ol></li><li>Array.from 方法可以将 Set 结构转为数组</li></ol></li><li>WeakSet<ol><li>WeakSet 结构与 Set 类似，也是不重复的值的集合。 WeakSet 对象允许你将弱引用对象储存在一个集合中。</li><li>WeakSet 与 Set 的区别<ol><li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li><li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li><li>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数。</li></ol></li><li>WeakSet方法<ol><li>add(value)：在WeakSet 对象中添加一个元素value</li><li>has(value)：判断 WeakSet 对象中是否包含value</li><li>delete(value)：删除元素 value</li><li>clear()：注意该方法已废弃, WeakSet没这个方法</li></ol></li></ol></li><li>Map<ol><li>Map诞生原因:<ol><li>为了解决对象只能用字符串当作键的问题。</li><li>ES6 提供了 Map 数据结构，类似于对象，也是键值对的集合，但是 “键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</li></ol></li><li>Map的属性和方法<ol><li>size属性返回 Map 结构的成员总数。</li><li>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<ol><li>set方法返回的是当前的Map对象，因此可以采用链式写法。</li><li><code>let map = new Map().set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;);</code></li><li>如果对同一个键多次赋值，后面的值将覆盖前面的值:</li></ol></li><li>get方法读取key对应的键值，如果找不到key，返回undefined。</li><li>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li>delete方法删除某个键，返回true。如果删除失败，返回false。</li><li>clear方法清除所有成员，没有返回值。</li></ol></li><li>注意<ol><li>数组做参数<ol><li>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</li></ol></li><li>Map 的键实际上是跟内存地址绑定的<ol><li>如果读取一个未知的键，则返回undefined</li><li>只有对同一个对象的引用，Map 结构才将其视为同一个键</li></ol></li></ol></li><li>Map遍历方法<ol><li>Map.prototype.keys()：返回键名的遍历器。</li><li>Map.prototype.values()：返回键值的遍历器。</li><li>Map.prototype.entries()：返回所有成员的遍历器。</li><li>Map.prototype.forEach()：遍历 Map 的所有成员。</li></ol></li><li>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）</li></ol></li><li>WeakMap<ol><li>WeakMap结构与Map结构类似，也是用于生成键值对的集合</li><li>WeakMap与Map的区别<ol><li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li></ol></li><li>WeakMap 的语法<ol><li>没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性</li><li>无法清空，即不支持clear方法</li><li>WeakMap只有四个方法可用：get()、set()、has()、delete()。</li></ol></li><li>WeakMap 的用途<ol><li>WeakMap 应用的典型场合就是 DOM 节点作为键名。</li></ol></li></ol></li></ol></li><li><a id="question39">介绍下深度优先遍历和广度优先遍历，如何实现?</a><ol><li>深度优先遍历：是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止。</li><li>广度优先遍历：是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。</li></ol></li><li><a id="question40">请分别用深度优先思想和广度优先思想实现一个拷贝函数?</a><ol><li><a href="https://blog.csdn.net/qq_46299172/article/details/108545861">address</a></li><li>深度优先的深拷贝 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">DFSdeepClone</span> = (<span class="hljs-params">obj, visitedArr = []</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> _obj = &#123;&#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) || <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;object&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">let</span> index = visitedArr.<span class="hljs-title function_">indexOf</span>(obj)<br>    _obj = <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) ? [] : &#123;&#125;<br>    <span class="hljs-keyword">if</span> (~index) &#123; <span class="hljs-comment">// 判断环状数据 ~-1 == 0 一个骚操作而已</span><br>      _obj = visitedArr[index]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      visitedArr.<span class="hljs-title function_">push</span>(obj)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>        _obj[item] = <span class="hljs-title class_">DFSdeepClone</span>(obj[item], visitedArr)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    _obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#x27;</span> + obj.<span class="hljs-title function_">toString</span>() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _obj = obj<br>  &#125;<br>  <span class="hljs-keyword">return</span> _obj<br>&#125;<br></code></pre></td></tr></table></figure></li><li>广度优先的拷贝 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> BFSdeepClone = (obj) =&gt; &#123;<br><span class="hljs-built_in">let</span> <span class="hljs-built_in">origin</span> = [obj],<br>  copyObj = &#123;&#125;,<br>  <span class="hljs-built_in">copy</span> = [copyObj]<br>  // 去除环状数据<br><span class="hljs-built_in">let</span> visitedQueue = [],<br>  visitedCopyQueue = []<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">origin</span>.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">let</span> items = <span class="hljs-built_in">origin</span>.shift(),<br>    _obj = <span class="hljs-built_in">copy</span>.shift()<br>  visitedQueue.<span class="hljs-built_in">push</span>(items)<br>  <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;object&#x27;) || isTypeOf(items, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item <span class="hljs-keyword">in</span> items) &#123;<br>      <span class="hljs-built_in">let</span> val = items[item]<br>      <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;object&#x27;)) &#123;<br>        <span class="hljs-built_in">let</span> index = visitedQueue.indexOf(val)<br>        <span class="hljs-keyword">if</span> (!~index) &#123;<br>          _obj[item] = &#123;&#125;<br>            //下次<span class="hljs-keyword">while</span>循环使用给空对象提供数据<br>          <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>            // 推入引用对象<br>          <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          _obj[item] = visitedCopyQueue[index]<br>          visitedQueue.<span class="hljs-built_in">push</span>(_obj)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>        // 数组类型在这里创建了一个空数组<br>        _obj[item] = []<br>        <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>        <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;function&#x27;)) &#123;<br>        _obj[item] = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + val.toString() + &#x27;)&#x27;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        _obj[item] = val<br>      &#125;<br>    &#125;<br>    // 将已经处理过的对象数据推入数组 给环状数据使用<br>    visitedCopyQueue.<span class="hljs-built_in">push</span>(_obj)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;function&#x27;)) &#123;<br>    copyObj = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + items.toString() + &#x27;)&#x27;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    copyObj = obj<br>  &#125;<br>&#125;<br>  <span class="hljs-built_in">return</span> copyObj<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question41">ES5&#x2F;ES6的继承除了写法以外还有什么区别?</a><ol><li>ES5的继承：<ol><li>先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）；</li><li>通过原型或构造函数机制来实现；</li></ol></li><li>ES6的继承：<ol><li>先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</li><li>通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承<ol><li>子类必须在constructor方法中调用super方法，否则新建实例报错。因 为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。</li><li>注意 super 关键字指代父类的实例，即父类的 this 对象</li><li>注意 在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错</li></ol></li></ol></li></ol></li><li><a id="question42">setTimeout、Promise、 Async&#x2F;Await的区别</a><ol><li>setTimeout属性宏任务，Promise里面的then方法属于微任务，Async&#x2F;Await中await语法后面紧跟的表达式是同步的，但接下来的代码是异步的，属于微任务。</li><li>setTimeout<ol><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br>   setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>   &#125;, <span class="hljs-number">0</span>);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>输出script start -&gt; script end -&gt; set</li></ol></li><li>Promise：<ol><li>Promise本身是同步的，但在执行resolve或者rejects时是异步的，即then方法是异步的。</li><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br> let promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>     resolve();<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1 end&quot;</span>);<br> &#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br> &#125;)<br>        <br> setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br> &#125;, <span class="hljs-number">0</span>)<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>输出顺序： script start -&gt; promise1 -&gt; promise1 end -&gt; script end -&gt; promise2 -&gt;setTimeout</li></ol></li><li>async&#x2F;await<ol><li>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</li><li>await后面跟一个表达式，async方法执行时，遇到await后会立即执行表达式，然后把表达式后边的代码放到微任务队列中，让出执行栈让同步代码先执行；</li><li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>await async2();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>输出顺序：script start -&gt; async1 start -&gt; async2 -&gt; script end -&gt; async1 end</li></ol></li></ol></li><li><a id="question43">Async&#x2F;Await如何通过同步的方式实现异步</a><ol><li>Async 和 Await 都是异步编程的关键字。</li><li>在 Async 函数内部使用 await 关键字来等待异步操作完成。await 表示等待异步操作返回结果后再继续执行后续的代码。</li><li>Async&#x2F;Await 是如何通过同步的方式实现异步的呢？答案就是 Generator 函数和 Promise。</li><li>Generator 函数是一种特殊的函数，它可以被暂停和恢复执行。在 Generator 函数中，我们可以使用 yield 关键字将控制权交给调用方，并在下次调用时从上次暂停的位置继续执行。这种特性可以用来实现异步操作。</li><li>Promise 是 ES6 引入的另一种异步编程技术。Promise 对象表示一个尚未完成或失败的操作，它可以被异步执行，并返回一个代表操作结果的值。</li><li>Async 函数实际上是一种特殊的 Generator 函数，它使用 yield 关键字暂停执行，并在异步操作完成后，通过调用 next 方法恢复执行。这个过程中，Async 函数内部创建了一个 Promise 对象，并将该 Promise 对象返回给调用方。</li><li>使用 Async&#x2F;Await 可以避免回调地狱和 Promise 层层嵌套的问题。</li></ol></li><li><a id="question44">JS异步解决方案的发展历程以及优缺点</a><ol><li>回调函数（callback）</li><li>Promise</li><li>Generator</li><li>Async&#x2F;await</li></ol></li><li><a id="question45">Promise构造函数是同步执行还是异步执行，那么then方法呢?</a><ol><li>promise构造函数是同步执行的，then方法是异步执行的</li></ol></li><li><a id="question46">如何实现一个new</a><ol><li>创建一个空的简单 JavaScript 对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；（ 通俗理解就是新对象隐式原型__proto__链接到构造函数显式原型prototype上。）</li><li>将步骤 1 新创建的对象作为 this 的上下文；（ 实际是执行了构造函数 并将构造函数作用域指向新对象 ）</li><li>如果该函数没有返回对象，则返回 this。（ 实际是返回一个空对象， new Object()就是返回一个空对象{} ）</li><li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">constructor, ...arg</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 对应于上面的步骤 1</span><br>  obj.<span class="hljs-property">__proto__</span> = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 对应于上面的步骤 2</span><br><br>  <span class="hljs-keyword">var</span> res = constructor.<span class="hljs-title function_">apply</span>(obj, arg); <span class="hljs-comment">// 对应于上面的步骤 3</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(res) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ? res : obj; <span class="hljs-comment">// 对应于上面的步骤 4</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Fun</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">_new</span>(<span class="hljs-title class_">Fun</span>, <span class="hljs-string">&#x27;小明&#x27;</span>));<br><br><span class="hljs-comment">// Fun &#123;name: &quot;小明&quot;&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><a id="question47">简单讲解一下http2的多路复用</a><ol><li>在 HTTP&#x2F;2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</li><li>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。</li><li>多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</li></ol></li><li><a id="question48">谈谈你对TCP三次握手和四次挥手</a><ol><li>TCP协议？<ol><li>TCP( Transmission control protocol )即传输控制协议，是一种面向连接、可靠的数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。<ol><li>面向连接：数据传输之前客户端和服务器端必须建立连接</li><li>可靠的：数据传输是有序的 要对数据进行校验</li></ol></li></ol></li><li>TCP三次握手<ol><li>为了保证客户端和服务器端的可靠连接，TCP建立连接时必须要进行三次会话，也叫TCP三次握手，进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。<ol><li>我打给你 问你能听到吗</li><li>你说你能听到 问我能听到吗</li><li>我说我能听到 开始交流吧</li></ol></li></ol></li><li>TCP四次挥手（我客户端 你服务端）<ol><li>我告诉你 我要关闭了</li><li>你说 好吧 你关闭吧</li><li>你再说 那我也关闭了？</li><li>我说 行你也关吧</li></ol></li></ol></li><li><a id="question49">A、B机器正常连接后，B机器突然重启，问A此时处于TCP什么状态</a><ol><li>等待 超时 抛出异常</li></ol></li><li><a id="question50">React中setState什么时候是同步的，什么时候是异步的?</a><ol><li><ul><li><ol><li>由 React 控制的事件处理程序，以及生命周期函数调用 setState 不会同步更新 state 。</li><li>React 控制之外的事件中调用 setState 是同步更新的。比如原生 js 绑定的事件，setTimeout&#x2F;setInterval 等。</li></ol></li></ul></li><li>在合成事件 和 生命周期钩子(除componentDidUpdate) 中，setState是”异步”的；</li><li>在 原生事件 和setTimeout 中，setState是同步的，可以马上获取更新后的值；</li><li>批量更新：多个顺序的setState不是同步地一个一个执行，会一个一个加入队列，然后最后一起执行。在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新。</li><li>函数式： setState第一个参数为函数形式时，在这个函数中可以回调拿到最新的state对象，然后函数return出的对象将被设置成newState。<code>this.setState((state, props) =&gt; newState)</code></li></ol></li><li><a id="question51">介绍下npm模块安装机制，为什么输入npm install就可以自动安装对应的</a><ol><li>npm 模块安装机制：<ol><li>发出npm install命令</li><li>查询node_modules目录之中是否已经存在指定模块<ol><li>若存在，不再重新安装</li><li>若不存在<ol><li>npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的.npm目录里</li><li>解压压缩包到当前项目的node_modules目录</li></ol></li></ol></li></ol></li><li>npm 实现原理<ol><li>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）<ol><li>执行工程自身 preinstall</li><li>确定首层依赖模块</li><li>获取模块<ol><li>获取模块是一个递归的过程，分为以下几步<ol><li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li><li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li><li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li></ol></li></ol></li><li>模块扁平化（dedupe）</li><li>安装模块<ol><li>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</li></ol></li><li>执行工程自身生命周期<ol><li>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</li></ol></li><li>生成或更新版本描述文件，npm install 过程完成。</li></ol></li></ol></li></ol></li><li><a id="question52">重绘和回流(Repaint &amp; Reflow)，以及如何进行优化</a><ol><li>重绘<ol><li>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</li></ol></li><li>回流<ol><li>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</li></ol></li><li>回流必定会发生重绘，重绘不一定会引发回流。</li><li>下列属性都会强制渲染刷新队列<ol><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ol></li><li><a href="https://www.cnblogs.com/zjknb/p/13974879.html">减少重绘与回流</a></li></ol></li><li><a id="question53">介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</a><ol><li>观察者模式里，只有两个角色 —— 观察者(Observer) + 被观察者(Subject || Observable)</li><li>发布订阅模式里，却不仅仅只有发布者(Publisher)和订阅者(Subscriber)两个角色，还有一个经常被我们忽略的 —— 经纪人Broker<br> 1. </li><li>使用：<ol><li>观察者模式，多用于单个应用内部</li><li>发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件</li></ol></li></ol></li><li><a id="question54">聊聊 Redux 和Vuex的设计思想</a><ol><li>不管是 Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。</li><li>Redux 和 Vuex 的设计思想都是为了让应用程序的状态变得更加可控、可预测和易于维护。通过使用单一数据源、状态只读、组件解耦、动态更新和中心化管理等技术手段，这两个库可以实现复杂应用程序的状态管理，并提高代码的可重用性和可扩展性。</li></ol></li><li><a id="question55">说说浏览器和Node事件循环的区别</a><ol><li>执行环境不同：浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，而Node.js中的事件循环是运行在单独的的线程中。因此，在浏览器中，事件循环跟渲染进程共享同一个线程，可能会出现线程阻塞。</li><li>宏任务和微任务的实现方式不同<ol><li>在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。 常见的宏任务包括：setTimeout, setInterval, DOM事件等，常见的微任务包括：Promise.then, MutationObserve等。</li><li>在Node.js中，宏任务和微任务的实现方式有所不同。Node.js使用libuv库提供的事件循环机制来管理宏任务，而使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。当当前阶段的所有任务执行完毕后，才会执行process.nextTick()的为任务队列。</li></ol></li><li>在处理 I&#x2F;O 操作和定时器方面有些许不同<ol><li>Node.js 中采用异步 I&#x2F;O 和非阻塞 I&#x2F;O，可以提供更高效的事件循环机制。而浏览器中，大多数的 I&#x2F;O 操作都是通过 Web APIs 实现的，这些 API 通常是基于异步回调函数实现的。在处理定时器方面，Node.js 提供了 setImmediate() 方法来代替 setTimeout() 函数，在性能上有所提升。</li></ol></li></ol></li><li><a id="question56">介绍模块化发展历程</a><ol><li>文件划分方式</li><li>命名空间方式</li><li>立即执行函数 IIFE 方式<ol><li>具体做法，就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象（window）上的方式实现。</li></ol></li><li>利用自执行函数参数作为依赖声明使用<ol><li>具体做法就是在第3阶段的基础上，利用立即执行函数的参数传递模块依赖项。这样就使得每个模块之间的关系变得更加明显了。</li></ol></li><li>模块化规范的出现 <ol><li>CommonJS 规范<ol><li>一个文件就是一个模块</li><li>每个模块都有单独的作用域</li><li>通过 module.exports 导出成员</li><li>通过 require 函数载入模块</li></ol></li><li>AMD 规范与 Require.js</li><li>CMD 规范与 Sea.js</li></ol></li><li>模块化标准规范</li><li>总的来说，前端模块化，目前算是统一成了 CommonJS 和 ES Modules 这两个规范</li></ol></li><li><a id="question57">全局作用域中，用const 和let声明的变量不在window 上，那到底在哪</a><ol><li>在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中。那要怎么获取呢？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象Window，那就不加 window（global），直接访问即可。</li></ol></li><li><a id="question58">cookie和 token 都存放在header中，为什么不会劫持token?</a><ol><li>因为传统的cookie保存的session id，服务器会根据这个session id，确保服务器与客户端对话；这是的cookie是有状态的，意味着验证记录或者会话需要一直在服务端和客户端保持。而token是无状态的，服务器不记录哪些用户登录了或者哪些 JWT 被发布了，只判断token是否有效，通常我们都会给token设置有效时间，来确保不被劫持。所有劫持cookie比劫持token，更有效，毕竟cookie在某种情况下可以一直使用下去，而token不行。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React-个人学习归纳</title>
    <link href="/2024/01/23/ReactStart/"/>
    <url>/2024/01/23/ReactStart/</url>
    
    <content type="html"><![CDATA[<ol><li><h4 id="项目创建及目录结构"><a href="#项目创建及目录结构" class="headerlink" title="项目创建及目录结构"></a>项目创建及目录结构</h4><ol><li>使用官方的脚手架<ol><li>通过npx create-react-app <projectname>能创建一个最基本的react项目)</li><li><strong>只做了react基本的搭建和构建，没有配上任何路由和状态管理。项目使用webpack构建</strong></li><li>上面安装如果失败，尝试下方方法：<ol><li>全局安装create-react-app <code>npm install -g create-react-app</code></li><li>创建一个名为 my-react的项目<code>create-react-app my-react</code></li><li><a href="https://blog.csdn.net/m0_47670683/article/details/124413133">create-react-app报错的解决方法</a></li></ol></li></ol></li><li>使用市场上集成脚手架<ol><li>官方脚手架提供的项目模板非常简单，因此也有很多集成的脚手架</li><li>典型的比如umi。这一类脚手架创建出来的项目会集成好很多功能，比如路由，mock</li></ol></li><li>两个核心库<ol><li>react react核心库，提供react的各个功能</li><li>React-dom 提供一些dom操作方法 用于把react创建出来的react对象挂载到真正的htmldom中，或者从htmldom中卸载。核心作用类似于vue中的mount。</li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><br><span class="hljs-comment">// React.StrictMode 开启严格模式</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">// 卸载(2s后页面清除)</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  root.<span class="hljs-title function_">unmount</span>();<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="组件中的jsx"><a href="#组件中的jsx" class="headerlink" title="组件中的jsx"></a>组件中的jsx</h4><ol><li>组件<ol><li>组件化开发，定义一个基本组件的必要条件：<ol><li><strong>组件html模板</strong></li><li><strong>数据和方法</strong></li></ol></li><li>react实现(函数组件及class组件)；由此思考为什么可以在js中直接如此返回？由此引申出jsx。<strong>组件首字母一定要大写</strong>，这是因为当React解析JSX代码时，如果遇到以小写字母开头的标签，它将被视为HTML标签或React内置组件。而如果遇到以大写字母开头的标签，React将其视为自定义组件。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数组件-新版本写法 </span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">FnHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>  <span class="hljs-comment">// class组件-老版本写法</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>helloClass<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloClass</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HelloClass</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li>jsx的特点<ol><li>直接js中混用（js文件后缀直接修改为jsx也是可以的）<ol><li>react项目利用babel做了对js的编译，所以是可以在js里写jsx的</li></ol></li><li>写法接近js，jsx几乎和js一样，不同点在于，可以更方便的写html在js里，写在js里的html最后会被编译成一个js对象，也可以用react自带createElement创建这个对象</li><li><strong>jsx和react是相互独立的。react可以用自带createElement创建这个对象，和jsx创建的dom是一模一样的</strong>。 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fnreactdom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>,[],<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-comment">// 元素，属性，内容</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>jsx里面渲染不同内容的区别<table><thead><tr><th>内容</th><th>渲染</th></tr></thead><tbody><tr><td>字符串、数字</td><td>直接渲染</td></tr><tr><td>方法</td><td>无法渲染</td></tr><tr><td>对象</td><td>只能渲染element对象</td></tr><tr><td>布尔值</td><td>不渲染任何内容</td></tr><tr><td>数组</td><td>把数组里的每一项单独渲染</td></tr><tr><td>Undefine、null</td><td>不渲染任何内容</td></tr><tr><td>表达式</td><td>运行表达式</td></tr></tbody></table> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FnHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">FnHello</span>();<br><span class="hljs-keyword">let</span> com1 = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span>;<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;obj&#125;</span><br><span class="language-xml">    &#123;com1&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">FnHello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FnHello</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HelloClass</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HelloClass</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ol><li>规则模式<ol><li>类似于原生 on+方法名（首字母大写）</li><li>一定要赋值给事件一个方法 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(1);</span><br><span class="language-xml">      &#125;&#125;&gt;匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1&#125;</span>&gt;</span>dianji<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>特别注意问题：<ol><li>不做处理的情况下，this会指向undefined<ol><li>改变this指向：<ol><li>bind</li><li>匿名箭头函数</li><li>方法本身写成箭头函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 正常：为undefined；bind修改this指向：指向App对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;<br>  fn2=<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//App对象</span><br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(1);</span><br><span class="language-xml">      &#125;&#125;&gt;匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1&#125;</span>&gt;</span>正常<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn1.bind(this)&#125;</span>&gt;</span>bind修改this指向<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;</span><br><span class="language-xml">        console.log(this);//App对象</span><br><span class="language-xml">      &#125;&#125;&gt;匿名指向<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn2&#125;</span>&gt;</span>方法写成匿名函数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>给到事件绑定的一定得是一个方法，不要直接调用方法，调用方法只会在页面初次渲染指向方法。</li><li>事件绑定其他操作<ol><li>传递参数</li><li>获取事件对象<ol><li>并不是原生事件对象，而是合成的事件对象</li></ol></li><li>阻止默认行为，冒泡等</li></ol></li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  fn3=<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b);<br>  &#125;<br>  fn4=<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//事件对象</span><br>  &#125;<br>  fn5=<span class="hljs-function">(<span class="hljs-params">a,b,c</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">//事件对象</span><br>    <span class="hljs-comment">// 阻止冒泡,和原生js是一致的</span><br>    c.<span class="hljs-title function_">stopPropagation</span>();<br>    c.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;App&#x27;</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 传递参数 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn3.bind(this,1,2)&#125;</span>&gt;</span>传递参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 获取事件对象;不传参数默认接收的第一个，传参数则为最后一个 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn4&#125;</span>&gt;</span>不传参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fn5.bind(this,1,2)&#125;</span>&gt;</span>传参数<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><h4 id="组件的响应式数据"><a href="#组件的响应式数据" class="headerlink" title="组件的响应式数据"></a>组件的响应式数据</h4><ol><li>类组件响应式数据的定义<ol><li>响应式数据定义在类的state属性中 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// constructor(props)&#123;</span><br>  <span class="hljs-comment">//   super(props)</span><br>  <span class="hljs-comment">//   this.state = &#123;</span><br>      <br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">//</span><br>  state = &#123;<br>    a:<span class="hljs-number">0</span><br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;div className=&#x27;<span class="hljs-type">App</span>&#x27;&gt;<br>      &#123;<span class="hljs-keyword">this</span>.state.a&#125;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>react响应式体系的原理<ol><li>react不能像vue一样直接修改触发更新</li><li>react修改能改值，但无法触发更新，因为react没有像vue一样监听get和set，而是在调用setState的时候调用react的更新操作 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pf">class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    a:<span class="hljs-number">0</span><br>  &#125;<br>  addA=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      a:++this.<span class="hljs-keyword">state</span>.a<br>    &#125;)<br>  &#125;<br>  addB=()=&gt;&#123;<br>    this.<span class="hljs-keyword">state</span>.a+=<span class="hljs-number">1</span>;<br>    this.<span class="hljs-built_in">set</span>State(&#123;&#125;)<br>  &#125;<br>  addC=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State((<span class="hljs-keyword">state</span>)=&gt;&#123;<br>      return &#123;<br>        a: ++<span class="hljs-keyword">state</span>.a<br>      &#125;<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return <span class="hljs-variable">&lt;div className=&#x27;App&#x27;&gt;</span><br>      &#123;this.<span class="hljs-keyword">state</span>.a&#125;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addA&#125;&gt;</span>a加一第一种写法&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addB&#125;&gt;</span>a加一第二种写法&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;this.addC&#125;&gt;</span>a加一第三种写法&lt;/button&gt;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>setState流程<ol><li>调用setState</li><li>给入一个对象</li><li>给入的对象和state对象进行浅合并</li><li>合并后调用更新方法进行更新</li><li>关键点：<ol><li><strong>通过浅合并来修改数据object.assign(),由此修改对象数据要注意展开原state,否则原对象属性会丢失</strong> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pf">class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    a:<span class="hljs-number">0</span>,<br>    c:&#123;<br>      c1:<span class="hljs-number">1</span>,<br>      c2:<span class="hljs-number">2</span>,<br>      c9:<span class="hljs-number">9</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">set</span>C=()=&gt;&#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      a:<span class="hljs-number">1</span>,<br>      c:&#123;<br>        ...this.<span class="hljs-keyword">state</span>.c,<br>        c1:<span class="hljs-number">2</span><br>      &#125;<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return <span class="hljs-variable">&lt;div className=&#x27;App&#x27;&gt;</span><br>      <span class="hljs-variable">&lt;div&gt;</span><br>        &#123;this.<span class="hljs-keyword">state</span>.a&#125; <br>        <span class="hljs-variable">&lt;br/&gt;</span><br>        &#123;this.<span class="hljs-keyword">state</span>.c.c1&#125; <br>        <span class="hljs-variable">&lt;button onClick=&#123;this.setC&#125;&gt;</span><span class="hljs-built_in">set</span>C&lt;/button&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>调用setState方法会触发更新，修改state并不会触发更新</li></ol></li></ol></li><li>setState方法的修改是异步的<ol><li>所以如果我们要获取修改后的值，需要在setState的第二个参数里获取 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">state</span> = &#123;<br>  a:<span class="hljs-number">0</span>,<br>  c:&#123;<br>    c1:<span class="hljs-number">1</span>,<br>    c2:<span class="hljs-number">2</span>,<br>    c9:<span class="hljs-number">9</span><br>  &#125;<br>&#125;<br><span class="hljs-built_in">set</span>C=()=&gt;&#123;<br>  this.<span class="hljs-built_in">set</span>State(&#123;<br>    a:<span class="hljs-number">1</span>,<br>    c:&#123;<br>      ...this.<span class="hljs-keyword">state</span>.c,<br>      c1:<span class="hljs-number">2</span><br>    &#125;<br>  &#125;,()=&gt;&#123;<br>    // 在这里才能获取到更新后的值<br>    console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.a);//<span class="hljs-number">1</span><br>  &#125;)<br>  console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.a);//<span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>setState的一些特性<ol><li>setState方法多次修改，会合并为一次，统一更新</li><li>setState返回会触发更新，不管你是否有修改，这造成一个问题：重复修改为相同的值也会让组件更新<ol><li>解决方法：<ol><li><code>class App extends React.PureComponent </code>,PureComponent是优化后的Component，解决了一些性能问题，其中包括上述问题的优化</li><li>PureComponent会根据state是否改变来决定是否更新，而对于对象数组这样的引用类型判断他是否改变的原理是看他的内存地址，而不是内容，所以在PureComponent下修改对象和数组，需要赋予一个新对象，一般先拷贝一份在进行操作  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">let _arr = [...this.<span class="hljs-keyword">state</span>.arr];<br>_arr.push(<span class="hljs-number">4</span>);<br>this.<span class="hljs-built_in">set</span>State(&#123;<br>    arr: _arr<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>一定不要在render里直接setState，会造成死循环。</li></ol></li></ol></li></ol></li><li><h4 id="条件渲染和列表循环"><a href="#条件渲染和列表循环" class="headerlink" title="条件渲染和列表循环"></a>条件渲染和列表循环</h4><ol><li>react没有vue一样的指令，一切操作本质都是通过运算生成不同的内容，渲染得到不同的页面</li><li>条件渲染的本质：react渲染undefined，null，空字符串，false不会渲染成任何内容 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pf">    class App extends React.Component &#123;<br>  <span class="hljs-keyword">state</span> = &#123;<br>    show: true,<br>  &#125;;<br>  f1() &#123;<br>    if (this.<span class="hljs-keyword">state</span>.show) &#123;<br>      return <span class="hljs-variable">&lt;div&gt;</span><span class="hljs-number">1</span>&lt;/div&gt;;<br>    &#125; else &#123;<br>      return <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div className=&quot;App&quot;&gt;</span><br>        <span class="hljs-variable">&lt;div&gt;</span>条件渲染&lt;/div&gt;<br>        &#123;this.<span class="hljs-keyword">state</span>.show ? <span class="hljs-variable">&lt;div&gt;</span><span class="hljs-number">123</span>&lt;/div&gt; : <span class="hljs-string">&quot;&quot;</span>&#125;<br>        &#123;this.f1()&#125;<br>        <span class="hljs-variable">&lt;button</span><br><span class="hljs-variable">          onClick=&#123;() =&gt;</span> &#123;<br>            this.<span class="hljs-built_in">set</span>State(&#123;<br>              show: !this.<span class="hljs-keyword">state</span>.show,<br>            &#125;);<br>          &#125;&#125;<br>        &gt;<br>          切换显隐<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>列表循环的本质<ol><li>渲染一个数组会把数组里的每一项单独取出渲染</li><li>那么编写一个里面存放的都是html结构的数组，就会渲染成列表</li></ol></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>      <span class="hljs-attr">originArr</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    &#125;;<br>  <br>    <span class="hljs-title function_">getArr</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> newAry = [];<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">originArr</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        newAry.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br>      &#125;);<br>      <span class="hljs-keyword">return</span> newAry;<br>    &#125;<br>  <br>    addData = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> newArr = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">originArr</span>];<br>      newArr.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">originArr</span>: newArr,<br>      &#125;);<br>    &#125;;<br>  <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;/* [1,2,3]转化为[<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>] */&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>列表渲染<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          &#123;this.state.originArr&#125;</span><br><span class="language-xml">          &#123;/* &#123;this.getArr()&#125; */&#125;</span><br><span class="language-xml">          &#123;/* map会直接返回数组 */&#125;</span><br><span class="language-xml">          &#123;this.state.originArr.map((item) =&gt; &#123;</span><br><span class="language-xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addData&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      );<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><h4 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h4><ol><li>react表单操作和原生js操作一致<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> &#123;<br>  state = &#123;<br>    inputValue: <span class="hljs-string">&quot;&quot;</span>,<br>    checkedArr: [<span class="hljs-string">&quot;c1&quot;</span>],<br>  &#125;;<br><br>  checkChangeOption = (e) =&gt; &#123;<br>    let _arr = [...<span class="hljs-keyword">this</span>.state.checkedArr];<br>    <span class="hljs-keyword">if</span> (e.target.checked) &#123;<br>      _arr.push(e.target.value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      _arr.splice(_arr.indexOf(e.target.value), <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.setState(<br>      &#123;<br>        checkedArr: _arr,<br>      &#125;,<br>      () =&gt; &#123;<br>        console.log(<span class="hljs-keyword">this</span>.state.checkedArr, <span class="hljs-string">&quot;this.state.checkedArr&quot;</span>);<br>      &#125;<br>    );<br>  &#125;;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>        &lt;div&gt;&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;&lt;/div&gt;<br>        &#123;<span class="hljs-comment">/* input输入框 */</span>&#125;<br>        &lt;input<br>          value=&#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;<br>          onInput=&#123;(e) =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.setState(&#123;<br>              inputValue: e.target.value,<br>            &#125;);<br>            console.log(e.target.value);<br>          &#125;&#125;<br>        /&gt;<br>        &lt;br /&gt;<br>        &#123;<span class="hljs-comment">/* checkbox 设置value获取check状态 */</span>&#125;<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c1&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c1&quot;</span><br>        /&gt;<br>        选项一<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c2&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c2&quot;</span><br>        /&gt;<br>        选项二<br>        &lt;input<br>          checked=&#123;<span class="hljs-keyword">this</span>.state.checkedArr.indexOf(<span class="hljs-string">&quot;c3&quot;</span>) !== -<span class="hljs-number">1</span>&#125;<br>          onChange=&#123;<span class="hljs-keyword">this</span>.checkChangeOption&#125;<br>          type=<span class="hljs-string">&quot;checkbox&quot;</span><br>          name=<span class="hljs-string">&quot;choose&quot;</span><br>          value=<span class="hljs-string">&quot;c3&quot;</span><br>        /&gt;<br>        选项三<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h4 id="Props和组件间传值，插槽"><a href="#Props和组件间传值，插槽" class="headerlink" title="Props和组件间传值，插槽"></a>Props和组件间传值，插槽</h4><ol><li>props是react中的核心</li><li>在react中，一切写在组件上的属性和子节点都被规划为了props。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一、跨域</title>
    <link href="/2024/01/02/WebKuayu/"/>
    <url>/2024/01/02/WebKuayu/</url>
    
    <content type="html"><![CDATA[<!-- [借鉴文章](https://juejin.cn/post/7285576848237412387) --><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol><li>什么是跨域<ol><li>导致<strong>跨域</strong>问题产生的根本原因是来自浏览器的<strong>同源策略</strong></li><li>同源策略是浏览器的重要安全策略，用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互，其中origin指Web文档的来源，Web内容的来源取决于访问的URL的<strong>方案（协议），主机（域名）和端口定义</strong></li><li>在浏览器同源策略限制下，向不同源（不同协议、不同域名或者不同端口）发送XHR请求时，浏览器认为该请求不受信任，可能存在安全隐患，禁止该请求，并作出不正常的响应。</li></ol></li><li>跨域解决方案<ol><li><h4 id="一、关闭浏览器的同源策略"><a href="#一、关闭浏览器的同源策略" class="headerlink" title="一、关闭浏览器的同源策略"></a>一、关闭浏览器的同源策略</h4><ol><li>IE浏览器：进入ie的网际网路选项设置，然后选择安全性，再选择自订等级，然后下拉，找到「存取跨网络的资料来源」，选择启用即可</li><li>chrome浏览器：首先需要关闭所有打开的浏览器窗口，在命令行窗口输入chrome –disable-web-security</li><li>FireFox浏览器：在地址栏输入about:config，然后下拉找到security.fileuri.strict_origin_policy，然后设置为false即可</li><li>这样的做法确实从根本上解决了跨域问题，但禁用同源策略会导致安全风险，所有并不推荐这样做</li></ol></li><li><h4 id="二、JSONP"><a href="#二、JSONP" class="headerlink" title="二、JSONP"></a>二、JSONP</h4><ol><li>在项目开发中常常会引入外链的图片、样式文件、插件等资源，但这些请求没有跨域，因为这些属于http请求并不是会引发跨域问题的Xhr请求</li><li><strong>script标签没有跨域限制，src改成需要跨域请求的url，就能实现跨域获取资源，且不触发浏览器的同源策略，这就是JSONP的原理</strong>。</li><li>问题：<ol><li><strong>CSRF攻击</strong> 当前端发起一个伪造的恶意JSONP请求时，服务端的敏感信息，如用户的个人信息，密码等存在泄露的风险，需要通过验证JSONP的调用来源（Referer），服务端判断 Referer 是否是白名单，或者部署随机 Token 来防御攻击</li><li><strong>XSS漏洞</strong> <ol><li>不严谨的content-type类型会导致的 XSS 漏洞，如果没有严格定义好 Content-Type，例如 Content-Type: application&#x2F;json，或者对请求url的query参数没有进行过滤，导致请求参数是一段恶意JavaScript代码，并被服务端接收执行并返回，那么前端就会执行这段恶意代码 </li><li>通过严格定义 Content-Type: application&#x2F;json，然后严格过滤 callback 后的参数并且限制长度（进行字符转义，例如&lt;换成&amp;lt，&gt;换成&amp;gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行</li></ol></li><li><strong>仅支持GET请求方式</strong> JSOP 仅支持GET方式的请求，对于POST等其他请求方式并不能使用JSONP</li></ol></li></ol></li><li><h4 id="三、CORS"><a href="#三、CORS" class="headerlink" title="三、CORS"></a>三、CORS</h4><ol><li>Cross-Origin Resource sharing（跨域资源共享），是一种基于HTTP头的机制，该机制允许服务器标示除了它自己以外其他origin（域名，协议和端口），既浏览器在跨域的情景下仍然能从目标服务器请求并获取资源可以说CORS才是跨域问题的正统解决方案</li><li>前端任何对服务端发起的可能产生副作用的XHR类型的请求方法都会都会触发CORS中的预检机制，CORS因此将请求划分为了预检请求和简单请求两种类型<ol><li>简单请求<ol><li>CORS简单请求的策略是在请求时在请求头增加一个Origin字段，服务器收到请求后，根据该字段判断是否允许该请求访问，如果允许，在响应头信息中添加Access-Contro-Allow&#x3D;Origin字段</li><li>简单请求需要满足以下规定:<ol><li>请求方法必须是 GET POST HEAD 中的一种</li><li>头部字段必须满足CORS的安全规范</li><li>请求头的Content-Type字段值为以下三种之一<ol><li>text&#x2F;plain</li><li>application&#x2F;x-www-form-urlencoded </li><li>multipart&#x2F;form-data</li></ol></li></ol></li></ol></li><li>预检请求<ol><li>对于预检请求CORS中通过预检机制(preflight request) 检查服务器是否允许浏览器发送真实请求，浏览器会先发送一个预检请求(option请求)，请求中会携带真实请求的请求信息：<ol><li>origin：请求的来源</li><li>Access-Control-Request-Method： 通知服务器在真正的请求中会采用哪种HTTP方法（GET,POST,DELETE…）</li><li>Access-Control-Request-Headers：通知服务器在真正的请求中会采用哪些请求头</li></ol></li><li>服务端在收到预检请求后，会根据以上的请求信息，判断是否预检通过，这体现在服务端对预检请求返回的响应头里</li></ol></li></ol></li></ol></li></ol></li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">//允许全部域名跨域，可以指定特点域名，逗号分隔</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//允许携带cookie</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;X-Requested-With&quot;</span>); <span class="hljs-comment">//允许传输的请求头</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>); <span class="hljs-comment">//允许发送的xhr模式</span><br><br>res.<span class="hljs-keyword">header</span>(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>,t); <span class="hljs-comment">//预检结果的缓存时间，即t时间内的该请求都按照本次的响应结果执行              </span><br></code></pre></td></tr></table></figure><p>当浏览器从预检请求的响应头中查找到以上的内容时，就会跳过同源策略，并允许真正的请求发送到服务端</p><ol><li><h4 id="四、服务器代理（ProxyServer）"><a href="#四、服务器代理（ProxyServer）" class="headerlink" title="四、服务器代理（ProxyServer）"></a>四、服务器代理（ProxyServer）</h4><ol><li>同源策略主要是限制浏览器和服务器之间的请求，服务器与服务器之间并不存在跨域问题</li><li>前端将请求发送给同源或者设置好跨域的代理服务器，代理服务器收到代理请求后，将真正的请求转发到目标服务器，并接受其响应结果，再把接收到的结果响应给前端</li></ol></li></ol><p><img src="/img/js/17043461858819.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript-基础类型</title>
    <link href="/2023/12/01/TypeScriptBaseType/"/>
    <url>/2023/12/01/TypeScriptBaseType/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.tslang.cn/docs/home.html">TypeScript官方中文文档地址</a></p><h4 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h4><ol><li><code>npm install -g typescript</code></li><li>使用.ts扩展名创建TypeScript文件 例<code>greeter.ts</code></li><li>编译代码 <code>tsc greeter.ts</code> 输出结果为一个 <code>greeter.js</code>文件</li></ol><!--### 基础类型--><h4 id="1、布尔值（boolean）"><a href="#1、布尔值（boolean）" class="headerlink" title="1、布尔值（boolean）"></a>1、布尔值（boolean）</h4><ol><li><code>let isBoolean: boolean = false;</code></li></ol><h4 id="2、数字（number）"><a href="#2、数字（number）" class="headerlink" title="2、数字（number）"></a>2、数字（number）</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> decLiteral: number = <span class="hljs-number">6</span>;<br><span class="hljs-built_in">let</span> hexLiteral: number = <span class="hljs-number">0xf00d</span>;<br><span class="hljs-built_in">let</span> binaryLiteral: number = <span class="hljs-number">0b1010</span>;<br><span class="hljs-built_in">let</span> octalLiteral: number = <span class="hljs-number">0o744</span>;<br></code></pre></td></tr></table></figure><h4 id="3、字符串（string）"><a href="#3、字符串（string）" class="headerlink" title="3、字符串（string）"></a>3、字符串（string）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 双引号（ &quot;）或单引号（&#x27;）表示字符串</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;bob&quot;</span>;<br>name = <span class="hljs-string">&quot;smith&quot;</span>;<br><br><span class="hljs-comment">//使用模版字符串，它可以定义多行文本和内嵌表达式。 </span><br><span class="hljs-comment">//这种字符串是被反引号包围（ `），并且以$&#123; expr &#125;这种形式嵌入表达式</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Gene`</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">37</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>.I&#x27;ll be <span class="hljs-subst">$&#123;age + <span class="hljs-number">1</span>&#125;</span> years old next month.`</span>;<br><br><span class="hljs-comment">//这与下面定义sentence的方式效果相同：</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> =<br>  <span class="hljs-string">&quot;Hello, my name is &quot;</span> +<br>  name +<br>  <span class="hljs-string">&quot;.\n\n&quot;</span> +<br>  <span class="hljs-string">&quot;I&#x27;ll be &quot;</span> +<br>  (age + <span class="hljs-number">1</span>) +<br>  <span class="hljs-string">&quot; years old next month.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="4、数组（-）"><a href="#4、数组（-）" class="headerlink" title="4、数组（[]）"></a>4、数组（[]）</h4><p>有两种方式可以定义数组</p><ol><li>在元素类型后面接上 []:<code>let list: number[] = [1, 2, 3];</code></li><li>使用数组泛型，Array&lt;元素类型&gt;:<code>let list: Array&lt;number&gt; = [1, 2, 3];</code></li></ol><h4 id="5、元组（-string-number-）"><a href="#5、元组（-string-number-）" class="headerlink" title="5、元组（[string, number]）"></a>5、元组（[string, number]）</h4><ol><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// Declare a tuple type</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-comment">// Initialize it</span><br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// Initialize it incorrectly</span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>当访问一个已知索引的元素，会得到正确的类型：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">1</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span><br></code></pre></td></tr></table></figure>当访问一个越界的元素，会使用联合类型替代：<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">x[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;world&#x27;</span>; // OK, 字符串可以赋值给<span class="hljs-built_in">(string</span> |<span class="hljs-built_in"> number</span>)类型<br><br>console.log(x[<span class="hljs-number">5</span>].toString()); // OK, <span class="hljs-string">&#x27;string&#x27;</span> 和 <span class="hljs-string">&#x27;number&#x27;</span> 都有 toString<br><br>x[<span class="hljs-number">6</span>] =<span class="hljs-built_in"> true</span>; // Error, 布尔不是<span class="hljs-built_in">(string</span> |<span class="hljs-built_in"> number</span>)类型<br></code></pre></td></tr></table></figure></li></ol><h4 id="6、枚举（enum）"><a href="#6、枚举（enum）" class="headerlink" title="6、枚举（enum）"></a>6、枚举（enum）</h4><p>enum类型是对JavaScript标准数据类型的一个补充<br>默认情况下，从0开始为元素编号.</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">enum</span> <span class="hljs-keyword">colorEnum</span> &#123;<br>  red <span class="hljs-operator">=</span> <span class="hljs-number">3</span>,<br>  yellow <span class="hljs-operator">=</span> <span class="hljs-number">6</span>,<br>  blue <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br>&#125;<br><span class="hljs-keyword">let</span> color<span class="hljs-operator">:</span> colorEnum <span class="hljs-operator">=</span> colorEnum.blue;<br><span class="hljs-keyword">let</span> color2<span class="hljs-operator">:</span> <span class="hljs-type">string</span> <span class="hljs-operator">=</span> colorEnum[<span class="hljs-number">6</span>]; <br>console.log(color,color2,colorEnum);<span class="hljs-comment">// 9 yellow</span><br></code></pre></td></tr></table></figure><h4 id="7、any（any）"><a href="#7、any（any）" class="headerlink" title="7、any（any）"></a>7、any（any）</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> list: <span class="hljs-type">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;free&quot;</span>];<br><span class="hljs-keyword">let</span> notSure: <span class="hljs-type">any</span> = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h4 id="8、void（void）"><a href="#8、void（void）" class="headerlink" title="8、void（void）"></a>8、void（void）</h4><ol><li>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-title function_">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：<code>let unusable: void = undefined;</code></li></ol><h4 id="9、undefined和null"><a href="#9、undefined和null" class="headerlink" title="9、undefined和null"></a>9、undefined和null</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Not much else we can assign to these variables!</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p><h4 id="10、never"><a href="#10、never" class="headerlink" title="10、never"></a>10、never</h4><ol><li>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</li><li>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span><span class="hljs-params">(message: string)</span>: never &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> error(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span>: never &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="11、Object"><a href="#11、Object" class="headerlink" title="11、Object"></a>11、Object</h4><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">o: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span>;<br><br><span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-number">0</span> &#125;); <span class="hljs-comment">// OK</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// OK</span><br><br><span class="hljs-title function_">create</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p><a href="https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-declare.md">declare关键字详解</a></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>另一个为as语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>typeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typeScript</tag>
      
      <tag>ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑配置</title>
    <link href="/2023/11/28/ComputerConfiguration/"/>
    <url>/2023/11/28/ComputerConfiguration/</url>
    
    <content type="html"><![CDATA[<ol><li>主要部件：<ol><li>CPU</li><li>主板</li><li>内存</li><li>显卡</li><li>固态</li><li>机械</li><li>散热</li><li>电源</li><li>机箱</li></ol></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ol><li>cpu是电脑的大脑，负责几乎所有的数据处理和运算</li><li>主要品牌商<ol><li>AMD</li><li>intel</li></ol></li></ol><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><ol><li>主板是电脑的工作平台，连通并安装着各个硬件，集成了许多的设备，并为许多安装在主板上的设备提供最基础的供电</li><li>AMD的CPU需要搭配AMD的主板才能使用</li><li>intel的CPU需要搭配intel的主板才能使用</li></ol><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ol><li>电脑的草稿纸，负责临时存放当前运行和计算的数据</li></ol><h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><ol><li>电脑的图形处理中心，负责渲染并输出给显示器</li></ol><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ol><li>存放着各种文件 系统和游戏等数据</li><li>主流硬盘：<ol><li>机械硬盘 <ol><li>3.5寸和2.5寸两种规格</li><li>速度极慢但是较为廉价</li></ol></li><li>2.5寸固态硬盘<ol><li>速度较快</li></ol></li><li>PCIe固态硬盘<ol><li>速度最快</li></ol></li><li>M.2固态硬盘<ol><li>速度同PCIe</li></ol></li></ol></li></ol><h3 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h3><ol><li>负责处理芯片产生的热量</li><li>CPU与显卡在工作之余会发热，大部分显卡会自带风冷散热器，CPU需额外准备散热器</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React官方文档初解</title>
    <link href="/2023/11/23/React/"/>
    <url>/2023/11/23/React/</url>
    
    <content type="html"><![CDATA[<p><a href="https://react.docschina.org/">官方中文文档</a></p><h3 id="1、不安装体验"><a href="#1、不安装体验" class="headerlink" title="1、不安装体验"></a>1、不安装体验</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- This setup is not suitable for production. --&gt;</span><br><span class="hljs-comment">&lt;!-- Only use it in development! --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ga.jspm.io/npm:es-module-shims@1.7.0/dist/es-module-shims.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">  <span class="hljs-string">&quot;imports&quot;</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;react&quot;</span>: <span class="hljs-string">&quot;https://esm.sh/react?dev&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-string">&quot;react-dom/client&quot;</span>: <span class="hljs-string">&quot;https://esm.sh/react-dom/client?dev&quot;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">StrictMode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Greeting</span>(<span class="hljs-params">&#123; name &#125;</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;world&quot;</span> /&gt;</span></span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));</span><br><span class="language-javascript">root.<span class="hljs-title function_">render</span>(</span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span></span></span><br><span class="language-javascript">);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">font-family</span>: sans-serif;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、编辑器设置"><a href="#2、编辑器设置" class="headerlink" title="2、编辑器设置"></a>2、编辑器设置</h3><ol><li>主流编辑器<ol><li><strong>VS Code</strong>(下面配置基于此编辑器)<ol><li>现如今最流行的编辑器之一。它拥有庞大的扩展市场，同时可以与 GitHub 等流行服务完美集成。</li></ol></li><li>WebStorm<ol><li>专为 JavaScript 设计的集成开发环境。</li></ol></li><li>Sublime Text<ol><li>支持 JSX 和 TypeScript，内置语法高亮和代码自动补全功能。</li></ol></li><li>Vim<ol><li>高度可配置的文本编辑器，可以非常高效地创建和更改任何类型的文本。它作为 “vi” 包含在大多数 UNIX 系统和 Apple OS X 中。</li></ol></li></ol></li><li><h4 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h4><ol><li><h5 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h5></li><li>官方文档中建议：<strong>请确保你已经为你的项目启用了 <code>eslint-plugin-react-hooks</code> 规则</strong>。这在 React 项目中是必备的，同时能帮助你及早的捕获较为严重的 bug。我们推荐的 <code>eslint-config-react-app</code> preset 中已经集成了该规则。</li></ol></li><li><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><ol><li><h5 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h5><ol><li>安装步骤<ol><li>启动vscode</li><li>使用快速打开（使用快捷键 Ctrl&#x2F;Cmd + P）</li><li>粘贴 <code>ext install esbenp.prettier-vscode</code></li><li>按回车键</li></ol></li></ol></li><li><h5 id="保存并自动格式化"><a href="#保存并自动格式化" class="headerlink" title="保存并自动格式化"></a>保存并自动格式化</h5><ol><li>在 VS Code, 按快捷键 <code>Ctrl/Cmd + Shift + P</code>.</li><li>输入 “settings”</li><li>按回车键</li><li>在搜索栏, 输入 “format on save”</li><li>确保勾选 “format on save” 选项！</li></ol></li></ol></li></ol><h3 id="3、react开发者工具"><a href="#3、react开发者工具" class="headerlink" title="3、react开发者工具"></a>3、react开发者工具</h3><ol><li>浏览器扩展<ol><li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">chrome扩展</a></li><li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/react-devtools/">firefox</a></li><li><a href="https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil">edge</a></li><li>现在，如果你访问一个用 React 构建 的网站，你将看到 Components 和 Profiler 面板。<ol><li><img src="/img/article/17007932745871.jpg"></li></ol></li></ol></li></ol><h3 id="4、初始组件体验"><a href="#4、初始组件体验" class="headerlink" title="4、初始组件体验"></a>4、<a id="useZJ">初始组件体验</a></h3><ol><li>React 应用是由被称为 组件 的独立 UI 片段构建而成。React 组件本质上是可以任意添加标签的 JavaScript 函数。组件可以小到一个按钮，也可以大到是整个页面。这是一个 Gallery 组件，用于渲染三个 Profile 组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">StrictMode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Amazing scientists<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li><li><h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4><ol><li>React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="第一步：导出组件"><a href="#第一步：导出组件" class="headerlink" title="第一步：导出组件"></a>第一步：导出组件</h5><ol><li>export default 前缀是一种 JavaScript 标准语法（非 React 的特性）。它允许你标签一个文件中的主要函数以便你以后可以从其他文件引入它。</li></ol></li><li><h5 id="第二步：定义函数"><a href="#第二步：定义函数" class="headerlink" title="第二步：定义函数"></a>第二步：定义函数</h5><ol><li>使用 function Profile() { } 定义名为 Profile 的 JavaScript 函数。</li><li>React 组件是常规的 JavaScript 函数，但 <strong>组件的名称必须以大写字母开头</strong>，否则它们将无法运行！</li></ol></li><li><h5 id="第三步：添加标签"><a href="#第三步：添加标签" class="headerlink" title="第三步：添加标签"></a>第三步：添加标签</h5><ol><li>这个组件返回一个带有 src 和 alt 属性的 <img /> 标签。<img /> 写得像 HTML，但实际上是 JavaScript！这种语法被称为 <strong>JSX</strong>，它允许你在 JavaScript 中嵌入使用标签。</li><li>返回语句可以全写在一行上，如下面组件中所示：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">return &lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span> alt<span class="hljs-operator">=</span><span class="hljs-string">&quot;Katherine Johnson&quot;</span> /&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>但是，如果你的标签和 return 关键字不在同一行，则<strong>必须把它包裹在一对括号中</strong>，如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br></code></pre></td></tr></table></figure><ol><li><strong>没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！</strong></li></ol></li></ol></li><li><h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><ol><li>定义了 Profile 组件，你可以在其他组件中使用它。例如，你可以导出一个内部使用了多个 Profile 组件的 Gallery 组件：<a href="#useZJ">LINK</a> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/MK3eW3As.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Katherine Johnson&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>了不起的科学家<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意：<ol><li><section> 是小写的，所以 React 知道我们指的是 HTML 标签。</li><li><Profile /> 以大写 P 开头，所以 React 知道我们想要使用名为 Profile 的组件。</li></ol></li><li>嵌套和组织组件 <ol><li><p>组件是常规的 JavaScript 函数，所以你可以将多个组件保存在同一份文件中。当组件相对较小或彼此紧密相关时，这是一种省事的处理方式。如果这个文件变得臃肿，你也可以随时将 Profile 移动到单独的文件中</p></li><li><p>因为 Profile 组件在 Gallery 组件中渲染——甚至好几次！——我们可以认为 Gallery 是一个 父组件，将每个 Profile 渲染为一个“孩子”。这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。</p></li><li><p><strong>组件可以渲染其他组件，但是 请不要嵌套他们的定义</strong>：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 🔴 永远不要在组件中定义组件</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 上面这段代码 非常慢，并且会导致 bug 产生。因此，你应该在顶层定义每个组件：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 在顶层声明组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 当子组件需要使用父组件的数据时，你需要 通过 props 的形式进行传递，而不是嵌套定义。</p></li></ol></li></ol></li></ol></li></ol><h3 id="5、组件的导入与导出"><a href="#5、组件的导入与导出" class="headerlink" title="5、组件的导入与导出"></a>5、组件的导入与导出</h3><ol><li><h4 id="根组件文件"><a href="#根组件文件" class="headerlink" title="根组件文件"></a>根组件文件</h4></li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">app.js<br> <span class="hljs-keyword">function</span> <span class="hljs-title">···</span><br></code></pre></td></tr></table></figure><p>在此示例中，所有组件目前都定义在 根组件 App.js 文件中。具体还需根据项目配置决定，有些根组件可能会声明在其他文件中。如果你使用的框架基于文件进行路由，如 Next.js，那你每个页面的根组件都会不一样</p><ol><li><h4 id="导出和导入一个组件"><a href="#导出和导入一个组件" class="headerlink" title="导出和导入一个组件"></a>导出和导入一个组件</h4><ol><li>创建 一个新的 JS 文件来存放该组件。</li><li>导出 该文件中的函数组件（可以使用 默认导出 或 具名导出） <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[filename]<span class="hljs-title class_">Gallery</span>.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/QIrZWGIs.jpg&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Alan L. Hart&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>了不起的科学家们<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在需要使用该组件的文件中 导入（可以根据相应的导出方式使用 默认导入 或 具名导入）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[filename]<span class="hljs-title class_">App</span>.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Gallery</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Gallery.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Gallery</span> /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="默认-具名-导出导入"><a href="#默认-具名-导出导入" class="headerlink" title="默认&#x2F;具名 导出导入"></a>默认&#x2F;具名 导出导入</h5></li></ol><table><thead><tr><th>语法</th><th>导出语句</th><th>导入语句</th></tr></thead><tbody><tr><td>默认</td><td><code>export default function Button() &#123;&#125;</code></td><td><code>import Button from &#39;./Button.js&#39;;</code></td></tr><tr><td>具名</td><td><code>export function Button() &#123;&#125;</code></td><td><code>import &#123; Button &#125; from &#39;./Button.js&#39;;</code></td></tr></tbody></table></li></ol><h3 id="6、JSX"><a href="#6、JSX" class="headerlink" title="6、JSX"></a>6、JSX</h3><ol><li>JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。</li><li>JSX规则<ol><li><h5 id="只能返回一个根元素"><a href="#只能返回一个根元素" class="headerlink" title="只能返回一个根元素"></a>只能返回一个根元素</h5></li><li><h5 id="标签必须闭合"><a href="#标签必须闭合" class="headerlink" title="标签必须闭合"></a>标签必须闭合</h5><ol><li><img> 这样的自闭合标签必须书写成 <img /> </li><li><li>oranges 这样只有开始标签的元素必须带有闭合标签，需要改为 <li>oranges</li>。</li></ol></li><li><h5 id="驼峰式命名法"><a href="#驼峰式命名法" class="headerlink" title="驼峰式命名法"></a>驼峰式命名法</h5><ol><li>变量名称不能包含 - 符号或者像 class 这样的保留字。</li><li>使用名称className而不是class作为属性名，是因为”class” 在 JavaScript 中是个保留字。</li><li>由于历史原因，aria-* 和 data-* 属性是以带 - 符号的 HTML 格式书写的。</li></ol></li><li>高级提示：使用 JSX 转化器 </li><li><h5 id="大括号使用"><a href="#大括号使用" class="headerlink" title="大括号使用"></a>大括号使用</h5><ol><li>JSX 允许你在 JavaScript 中编写类似 HTML 的标签，从而使渲染的逻辑和内容可以写在一起。有时候，你可能想要在标签中添加一些 JavaScript 逻辑或者引用动态的属性。这种情况下，你可以在 JSX 的大括号内来编写 JavaScript。</li><li>用 { 和 } 替代 “ 和 “ 以使用 JavaScript 变量 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> avatar = <span class="hljs-string">&#x27;https://i.imgur.com/7vQD0fPs.jpg&#x27;</span>;<br>  <span class="hljs-keyword">const</span> description = <span class="hljs-string">&#x27;Gregorio Y. Zara&#x27;</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;avatar&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;description&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用大括号<ol><li><h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Gregorio Y. Zara&#x27;</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;&#x27;s To Do List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">person=</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name:</span> <span class="hljs-string">&quot;Hedy Lamarr&quot;</span>, inventions: <span class="hljs-number">5</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure></li><li><h6 id="css"><a href="#css" class="headerlink" title="css"></a>css</h6> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">  <span class="hljs-name">backgroundColor:</span> <span class="hljs-string">&#x27;black&#x27;</span>,</span><br><span class="hljs-template-variable">  color: <span class="hljs-string">&#x27;pink&#x27;</span></span><br><span class="hljs-template-variable">&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&gt;</span></span><br></code></pre></td></tr></table></figure> 1.<strong>内联 style 属性 使用驼峰命名法编写</strong>。例如，HTML <code>&lt;ul style=&quot;background-color: black&quot;&gt;</code> 在你的组件里应该写成 <code>&lt;ul style=&#123;&#123; backgroundColor: 'black' &#125;&#125;&gt;</code>。</li><li><h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">DateTimeFormat</span>(<br>    <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br>    &#123; <span class="hljs-attr">weekday</span>: <span class="hljs-string">&#x27;long&#x27;</span> &#125;<br>  ).<span class="hljs-title function_">format</span>(date);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>To Do List for &#123;formatDate(today)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><h3 id="7、将-Props-传递给组件"><a href="#7、将-Props-传递给组件" class="headerlink" title="7、将 Props 传递给组件"></a>7、将 Props 传递给组件</h3><ol><li>React 组件使用 props 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它。Props 可能会让你想起 HTML 属性，但你可以通过它们传递任何 JavaScript 值，包括对象、数组和函数。</li><li>向组件传递 props<ol><li><h4 id="将-props-传递给子组件"><a href="#将-props-传递给子组件" class="headerlink" title="将 props 传递给子组件"></a>将 props 传递给子组件</h4></li></ol> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">export default function Profile() &#123;</span><br><span class="language-xml">  return (</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">person</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name:</span> <span class="hljs-string">&#x27;Lin Lanying&#x27;</span>, imageId: <span class="hljs-string">&#x27;1bX5QH6&#x27;</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;100&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br><span class="language-xml">  );</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h4 id="在子组件中读取-props"><a href="#在子组件中读取-props" class="headerlink" title="在子组件中读取 props"></a>在子组件中读取 props</h4><ol><li>在声明 props 时， 不要忘记 ( 和 ) 之间的一对花括号 { 和 } ; 这种语法被称为 “解构”，等价于于从函数参数中读取属性： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">&#123; person, size &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>等价于<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> person = props.<span class="hljs-property">person</span>;<br>  <span class="hljs-keyword">let</span> size = props.<span class="hljs-property">size</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h4 id="给-prop-指定一个默认值"><a href="#给-prop-指定一个默认值" class="headerlink" title="给 prop 指定一个默认值"></a>给 prop 指定一个默认值</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">&#123; person, size = <span class="hljs-number">100</span> &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="使用-JSX-展开语法传递-props"><a href="#使用-JSX-展开语法传递-props" class="headerlink" title="使用 JSX 展开语法传递 props"></a>使用 JSX 展开语法传递 props</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params">&#123; person, size, isSepia, thickBorder &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;person&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;size&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isSepia</span>=<span class="hljs-string">&#123;isSepia&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">thickBorder</span>=<span class="hljs-string">&#123;thickBorder&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br>简化：<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="将-JSX-作为子组件传递"><a href="#将-JSX-作为子组件传递" class="headerlink" title="将 JSX 作为子组件传递"></a>将 JSX 作为子组件传递</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Avatar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Avatar.js&#x27;</span>;<br>    <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Card</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;100&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;&#123;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name:</span> &#x27;<span class="hljs-attr">Katsuko</span> <span class="hljs-attr">Saruhashi</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">imageId:</span> &#x27;<span class="hljs-attr">YfeOqp2</span>&#x27;</span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><h4 id="Props-如何随时间变化"><a href="#Props-如何随时间变化" class="headerlink" title="Props 如何随时间变化"></a>Props 如何随时间变化</h4><ol><li><a href="">State: 一个组件的内存;hook</a></li></ol></li></ol></li></ol><h3 id="8、条件渲染"><a href="#8、条件渲染" class="headerlink" title="8、条件渲染"></a>8、条件渲染</h3><ol><li>在 React 中，你可以通过使用 JavaScript 的 if 语句、&amp;&amp; 和 ? : 运算符来选择性地渲染 JSX。</li><li><h4 id="if-条件返回-JSX"><a href="#if-条件返回-JSX" class="headerlink" title="(if)条件返回 JSX"></a>(if)条件返回 JSX</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">&#123; name, isPacked &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125; ✔<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PackingList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Sally Ride 的行李清单<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;true&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;宇航服&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;true&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;带金箔的头盔&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">isPacked</span>=<span class="hljs-string">&#123;false&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Tam 的照片&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">&#123; name, isPacked &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三目运算符（-）"><a href="#三目运算符（-）" class="headerlink" title="三目运算符（? :）"></a>三目运算符（? :）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;isPacked ? (</span><br><span class="language-xquery">        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-xquery">          </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> + <span class="hljs-string">&#x27; ✔&#x27;</span>&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span></span><br>      ) : (<br>       <span class="hljs-built_in"> name</span><br>      )&#125;<br>    &lt;/li&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="与运算符（-）"><a href="#与运算符（-）" class="headerlink" title="与运算符（&amp;&amp;）"></a>与运算符（&amp;&amp;）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml"> </span><span class="language-xquery">&#123;isPacked &amp;&amp; <span class="hljs-string">&#x27;✔&#x27;</span>&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>切勿将数字放在 &amp;&amp; 左侧</strong><ol><li>JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，<strong>如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染</strong>。</li><li>例如，一个常见的错误是 <code>messageCount &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。其原本是想当 messageCount 为 0 的时候不进行渲染，但实际上却渲染了 0。</li><li>为了更正，可以将左侧的值改成布尔类型：<code>messageCount &gt; 0 &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。</li></ol></li></ol><h4 id="选择性地将-JSX-赋值给变量"><a href="#选择性地将-JSX-赋值给变量" class="headerlink" title="选择性地将 JSX 赋值给变量"></a>选择性地将 JSX 赋值给变量</h4><ol><li>当这些快捷方式妨碍写普通代码时，可以考虑使用 if 语句和变量。因为你可以使用 let 进行重复赋值，所以一开始你可以将你想展示的（这里指的是物品的名字）作为默认值赋予给该变量。<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">let</span> itemContent =<span class="hljs-built_in"> name</span>;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    itemContent =<span class="hljs-built_in"> name</span> + <span class="hljs-string">&quot; ✔&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;itemContent&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> Item(&#123;<span class="hljs-built_in"> name</span>, isPacked &#125;) &#123;<br>  <span class="hljs-keyword">let</span> itemContent =<span class="hljs-built_in"> name</span>;<br>  <span class="hljs-keyword">if</span> (isPacked) &#123;<br>    itemContent = (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> + <span class="hljs-string">&quot; ✔&quot;</span>&#125;</span><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span></span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xquery">&#123;itemContent&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="9、渲染列表"><a href="#9、渲染列表" class="headerlink" title="9、渲染列表"></a>9、渲染列表</h3><ol><li>React 中使用 <strong>filter()</strong> 筛选需要渲染的组件和使用 <strong>map()</strong> 把数组转换成组件数组。</li><li>demo<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; people &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getImageUrl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> listItems = people.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;person.id&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;getImageUrl(person)&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;person.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;person.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">          &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;</span><br><span class="language-xml">          因&#123;person.accomplishment&#125;而闻名世界</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><ol><li>直接放在 map() 方法里的 JSX 元素一般都需要指定 key 值！</li><li>如何设定 key 值 <ol><li>来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。</li><li>本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。</li></ol></li><li>key 需要满足的条件<ol><li>key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。</li><li>key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。</li></ol></li><li>React 中为什么需要 key？<ol><li>设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……</li><li>React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。</li></ol></li></ol></li></ol><h3 id="10、保持组件纯粹-纯函数）"><a href="#10、保持组件纯粹-纯函数）" class="headerlink" title="10、保持组件纯粹(纯函数）"></a>10、保持组件纯粹(纯函数）</h3><ol><li><h4 id="纯函数：组件作为公式"><a href="#纯函数：组件作为公式" class="headerlink" title="纯函数：组件作为公式"></a>纯函数：组件作为公式</h4></li><li><p>纯函数特征</p><ol><li>只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。</li><li>输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">举个你非常熟悉的纯函数示例：数学中的公式。<br><br>考虑如下数学公式：y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-keyword">x</span>。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> 则 y <span class="hljs-operator">=</span> <span class="hljs-number">4</span>。永远如此。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> 则 y <span class="hljs-operator">=</span> <span class="hljs-number">6</span>。永远如此。<br><br>若 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>，那么 y 并不会因为时间或股市的影响，而有时等于 <span class="hljs-number">9</span> 、 –<span class="hljs-number">1</span> 或 <span class="hljs-number">2.5</span>。<br><br>若 y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-keyword">x</span> 且 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> 那么 y 永远 等于 <span class="hljs-number">6</span>.<br><br>我们使用 JavaScript 的函数实现，看起来将会是这样：<br><br>function <span class="hljs-keyword">double</span>(number) &#123;<br>  return <span class="hljs-number">2</span> * number<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>React 便围绕着这个概念进行设计。<strong>React 假设你编写的所有组件都是纯函数</strong>。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。</li></ol></li><li><h4 id="副作用-不符合-预期的后果"><a href="#副作用-不符合-预期的后果" class="headerlink" title="副作用:(不符合)预期的后果"></a>副作用:(不符合)预期的后果</h4><ol><li>React 的渲染过程必须自始至终是纯粹的。组件应该只 返回 它们的 JSX，而不 改变 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！</li><li>错误示例:该组件正在读写其外部声明的 guest 变量。这意味着 <strong>多次调用这个组件会产生不同的 JSX</strong>！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> guest = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Bad: changing a preexisting variable!</span><br>  guest = guest + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaSet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br>修复：<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params">&#123; guest &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaSet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;1&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;2&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;3&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="局部mutation：组件的小秘密"><a href="#局部mutation：组件的小秘密" class="headerlink" title="局部mutation：组件的小秘密"></a>局部mutation：组件的小秘密</h4><ol><li>上述示例的问题出在渲染过程中，组件改变了 预先存在的 变量的值。为了让它听起来更可怕一点，我们将这种现象称为 <strong>突变（mutation）</strong> 。纯函数不会改变函数作用域外的变量、或在函数调用前创建的对象——这会使函数变得不纯粹！</li><li>但是，<strong>你完全可以在渲染时更改你 刚刚 创建的变量和对象</strong>。在本示例中，你创建一个 [] 数组，将其分配给一个 cups 变量，然后 push 一打 cup 进去：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params">&#123; guest &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Tea cup for guest #&#123;guest&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TeaGathering</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> cups = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>    cups.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Cup</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> <span class="hljs-attr">guest</span>=<span class="hljs-string">&#123;i&#125;</span> /&gt;</span></span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> cups;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>解析：<ol><li>如果 cups 变量或 [] 数组是在 TeaGathering 函数之外创建的，这将是一个很大的问题！因为如果那样的话，当你调用数组的 push 方法时，就会更改 <strong>预先存在的</strong> 对象。</li><li>但是，这里不会有影响，因为每次渲染时，你都是在 TeaGathering 函数内部创建的它们。TeaGathering 之外的代码并不会知道发生了什么。这就被称为 <strong>“局部 mutation”</strong> — 如同藏在组件里的小秘密。</li></ol></li></ol><h4 id="哪些地方可能引发副作用"><a href="#哪些地方可能引发副作用" class="headerlink" title="哪些地方可能引发副作用"></a>哪些地方可能引发副作用</h4><p>函数式编程在很大程度上依赖于纯函数，但 某些事物 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。</p><p>在 React 中，<strong>副作用通常属于 事件处理程序</strong>。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。</p><p>如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 <strong><code>useEffect</code></strong> 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，<strong>这种方法应该是你最后的手段</strong>。</p><h3 id="11、将-UI-视为树"><a href="#11、将-UI-视为树" class="headerlink" title="11、将 UI 视为树"></a>11、将 UI 视为树</h3><ol><li>树是表示实体之间关系的常见方式，它们经常用于建模 UI。</li><li>渲染树表示单次渲染中 React 组件之间的嵌套关系。</li><li>使用条件渲染，渲染树可能会在不同的渲染过程中发生变化。使用不同的属性值，组件可能会渲染不同的子组件。</li><li>渲染树有助于识别顶级组件和叶子组件。顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染。识别它们有助于理解和调试渲染性能问题。</li><li>依赖树表示 React 应用程序中的模块依赖关系。</li><li>构建工具使用依赖树来捆绑必要的代码以部署应用程序。</li><li>依赖树有助于调试大型捆绑包带来的渲染速度过慢的问题，以及发现哪些捆绑代码可以被优化。</li></ol><h3 id="12、响应事件"><a href="#12、响应事件" class="headerlink" title="12、响应事件"></a>12、响应事件</h3><ol><li>React 允许你向 JSX 中添加事件处理程序。事件处理程序是你自己的函数，它将在用户交互时被触发，如点击、悬停、焦点在表单输入框上等等。</li><li><code>&lt;button&gt;</code> 等内置组件只支持内置浏览器事件，如 <code>onClick</code>。但是，你也可以创建你自己的组件，并给它们的事件处理程序 <code>props</code> 指定你喜欢的任何特定于应用的名称。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onPlayMovie</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> alert(&#x27;Playing!&#x27;)&#125;</span><br><span class="language-xml">      onUploadImage=&#123;() =&gt; alert(&#x27;Uploading!&#x27;)&#125;</span><br><span class="language-xml">    /&gt;</span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toolbar</span>(<span class="hljs-params">&#123; onPlayMovie, onUploadImage &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onPlayMovie&#125;</span>&gt;</span></span><br><span class="language-xml">        Play Movie</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onUploadImage&#125;</span>&gt;</span></span><br><span class="language-xml">        Upload Image</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">&#123; onClick, children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="13、State-组件的记忆"><a href="#13、State-组件的记忆" class="headerlink" title="13、State: 组件的记忆"></a>13、State: 组件的记忆</h3><p>组件通常需要根据交互改变屏幕上的内容。在表单中键入更新输入栏，在轮播图上点击“下一个”改变显示的图片，点击“购买”将产品放入购物车。组件需要“记住”一些东西：当前的输入值、当前的图片、购物车。在 React 中，这种特定于组件的记忆被称为状态。</p><p>你可以用 useState Hook 为组件添加状态。Hook 是能让你的组件使用 React 功能的特殊函数（状态是这些功能之一）。useState Hook 让你声明一个状态变量。它接收初始状态并返回一对值：当前状态，以及一个让你更新状态的设置函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; sculptureList &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gallery</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [index, setIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [showMore, setShowMore] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> hasNext = index &lt; sculptureList.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNextClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (hasNext) &#123;<br>      <span class="hljs-title function_">setIndex</span>(index + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setIndex</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMoreClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setShowMore</span>(!showMore);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> sculpture = sculptureList[index];<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleNextClick&#125;</span>&gt;</span></span><br><span class="language-xml">        Next</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>&#123;sculpture.name&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">        by &#123;sculpture.artist&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        (&#123;index + 1&#125; of &#123;sculptureList.length&#125;)</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleMoreClick&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;showMore ? &#x27;Hide&#x27; : &#x27;Show&#x27;&#125; details</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;showMore &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;sculpture.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;sculpture.url&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;sculpture.alt&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14、渲染和提交"><a href="#14、渲染和提交" class="headerlink" title="14、渲染和提交"></a>14、渲染和提交</h3><p>在你的组件显示在屏幕上之前，它们必须由 React 进行渲染。理解这个过程中的步骤有助于你思考你的代码如何执行并解释其行为。</p><ol><li><strong>触发</strong>渲染（将食客的订单送到厨房）</li><li><strong>渲染</strong>组件（在厨房准备订单）</li><li><strong>提交</strong>到 DOM（将订单送到桌前）</li></ol><h3 id="15、作为快照的状态"><a href="#15、作为快照的状态" class="headerlink" title="15、作为快照的状态"></a>15、作为快照的状态</h3><p>与普通 JavaScript 变量不同，React 状态的行为更像一个快照。设置它并不改变你已有的状态变量，而是触发一次重新渲染。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);  <span class="hljs-comment">// 0</span><br>setCount(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 请求用 1 重新渲染</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);  <span class="hljs-comment">// 仍然是 0！</span><br></code></pre></td></tr></table></figure><h3 id="16、把一系列-state-更新加入队列"><a href="#16、把一系列-state-更新加入队列" class="headerlink" title="16、把一系列 state 更新加入队列"></a>16、把一系列 state 更新加入队列</h3><ol><li>如下有问题的组件，点击“+3”只能增加一次分数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [score, setScore] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setScore</span>(score + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> increment()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">      &#125;&#125;&gt;+3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Score: &#123;score&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>作为快照的状态 解释了为什么会出现这种情况。设置状态会请求一个新的重新渲染，但不会在已运行的代码中更改它。所以在你调用 setScore(score + 1) 后，score 仍然是 0。<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br>setScore(<span class="hljs-keyword">score</span> + 1); <span class="hljs-comment">// setScore(0 + 1);</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">score</span>);  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>你可以通过在设置状态时传递一个 更新器函数 来解决这个问题。注意用 setScore(s &#x3D;&gt; s + 1) 替换 setScore(score + 1) 是如何修复“+3”按钮的。如果你需要排队进行多次状态更新，那么这非常方便。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [score, setScore] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setScore</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> increment()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">        increment();</span><br><span class="language-xml">      &#125;&#125;&gt;+3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Score: &#123;score&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="17、更新状态中的对象"><a href="#17、更新状态中的对象" class="headerlink" title="17、更新状态中的对象"></a>17、更新状态中的对象</h3><p>状态可以持有任何类型的 JavaScript 值，包括对象。但你不应该直接改变你在 React 状态中持有的对象和数组。相反，当你想更新一个对象和数组时，你需要创建一个新的对象（或复制现有的对象），然后用这个副本来更新状态。</p><p>通常情况下，你会使用 … 展开语法来复制你想改变的对象和数组。例如，更新一个嵌套对象可以是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [person, setPerson] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Niki de Saint Phalle&#x27;</span>,<br>    <span class="hljs-attr">artwork</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Blue Nana&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Hamburg&#x27;</span>,<br>      <span class="hljs-attr">image</span>: <span class="hljs-string">&#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;</span>,<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">name</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTitleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">title</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCityChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">city</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleImageChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">image</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Name:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Title:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.title&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleTitleChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        City:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.city&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleCityChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Image:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;person.artwork.image&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleImageChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>&#123;person.artwork.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">        &#123;&#x27; by &#x27;&#125;</span><br><span class="language-xml">        &#123;person.name&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        (located in &#123;person.artwork.city&#125;)</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;person.artwork.image&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;person.artwork.title&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在代码中复制对象感觉乏味，可以使用 Immer 之类的库来减少重复代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;immer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.7.3&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;use-immer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.5.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts start&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts test --env=jsdom&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="18、更新状态中的数组"><a href="#18、更新状态中的数组" class="headerlink" title="18、更新状态中的数组"></a>18、更新状态中的数组</h3><p>数组是另一种可以存在状态中的可变 JavaScript 对象，应将其视为只读。就像对象一样，当你想更新存在状态中的数组时，你需要创建一个新数组（或者复制现有数组），然后用新数组来更新状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">let</span> nextId = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> initialList = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Big Bellies&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Lunar Landscape&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Terracotta Army&#x27;</span>, <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span> &#125;,<br>];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BucketList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>(<br>    initialList<br>  );<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleToggle</span>(<span class="hljs-params">artworkId, nextSeen</span>) &#123;<br>    <span class="hljs-title function_">setList</span>(list.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">artwork</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (artwork.<span class="hljs-property">id</span> === artworkId) &#123;<br>        <span class="hljs-keyword">return</span> &#123; ...artwork, <span class="hljs-attr">seen</span>: nextSeen &#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> artwork;<br>      &#125;<br>    &#125;));<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Art Bucket List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>My list of art to see:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ItemList</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">artworks</span>=<span class="hljs-string">&#123;list&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onToggle</span>=<span class="hljs-string">&#123;handleToggle&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ItemList</span>(<span class="hljs-params">&#123; artworks, onToggle &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;artworks.map(artwork =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;artwork.id&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;artwork.seen&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">                onToggle(</span><br><span class="language-xml">                  artwork.id,</span><br><span class="language-xml">                  e.target.checked</span><br><span class="language-xml">                );</span><br><span class="language-xml">              &#125;&#125;</span><br><span class="language-xml">            /&gt;</span><br><span class="language-xml">            &#123;artwork.title&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19、使用状态响应输入"><a href="#19、使用状态响应输入" class="headerlink" title="19、使用状态响应输入"></a>19、使用状态响应输入</h3><p>使用 React，你不用直接从代码层面修改 UI。例如，不用编写诸如“禁用按钮”、“启用按钮”、“显示成功消息”等命令。相反，你只需要描述组件在不同状态（“初始状态”、“输入状态”、“成功状态”）下希望展现的 UI，然后根据用户输入触发状态更改。这和设计师对 UI 的理解很相似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [answer, setAnswer] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [status, setStatus] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;typing&#x27;</span>);<br><br>  <span class="hljs-keyword">if</span> (status === <span class="hljs-string">&#x27;success&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>答对了！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;submitting&#x27;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">submitForm</span>(answer);<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;typing&#x27;</span>);<br>      <span class="hljs-title function_">setError</span>(err);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTextareaChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setAnswer</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>城市测验<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        哪个城市有把空气变成饮用水的广告牌？</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;answer&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleTextareaChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;status</span> === <span class="hljs-string">&#x27;submitting&#x27;</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">answer.length</span> === <span class="hljs-string">0</span> ||</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">status</span> === <span class="hljs-string">&#x27;submitting&#x27;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&gt;</span></span><br><span class="language-xml">          提交</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        &#123;error !== null &amp;&amp;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Error&quot;</span>&gt;</span></span><br><span class="language-xml">            &#123;error.message&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">submitForm</span>(<span class="hljs-params">answer</span>) &#123;<br>  <span class="hljs-comment">// 模拟接口请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> shouldError = answer.<span class="hljs-title function_">toLowerCase</span>() !== <span class="hljs-string">&#x27;lima&#x27;</span><br>      <span class="hljs-keyword">if</span> (shouldError) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;猜的不错，但答案不对。再试试看吧！&#x27;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>();<br>      &#125;<br>    &#125;, <span class="hljs-number">1500</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20、选择状态结构"><a href="#20、选择状态结构" class="headerlink" title="20、选择状态结构"></a>20、选择状态结构</h3><p>状态不应包含冗余或重复的信息。如果包含一些多余的状态，我们会很容易忘记去更新它，从而导致问题产生！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> fullName = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFirstNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setFirstName</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleLastNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setLastName</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>让我们帮你登记<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        名：&#123;&#x27; &#x27;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;firstName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleFirstNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        姓：&#123;&#x27; &#x27;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;lastName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleLastNameChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        你的票将发给：<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;fullName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21、在组件间共享状态"><a href="#21、在组件间共享状态" class="headerlink" title="21、在组件间共享状态"></a>21、在组件间共享状态</h3><ol><li>有时候你希望两个组件的状态始终同步更改。要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过 props 将状态传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Accordion</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [activeIndex, setActiveIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Almaty, Kazakhstan<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Panel</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;关于&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;activeIndex</span> === <span class="hljs-string">0&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onShow</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setActiveIndex(0)&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        阿拉木图人口约200万，是哈萨克斯坦最大的城市。在1929年至1997年之间，它是该国首都。</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Panel</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Panel</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;词源&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;activeIndex</span> === <span class="hljs-string">1&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onShow</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setActiveIndex(1)&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        这个名字源于哈萨克语 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;kk-KZ&quot;</span>&gt;</span>алма<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>，是“苹果”的意思，通常被翻译成“满是苹果”。事实上，阿拉木图周围的地区被认为是苹果的祖籍，<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;la&quot;</span>&gt;</span>Malus sieversii<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 被认为是目前本土苹果的祖先。</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Panel</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Panel</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  title,</span><br><span class="hljs-params">  children,</span><br><span class="hljs-params">  isActive,</span><br><span class="hljs-params">  onShow</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;panel&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      &#123;isActive ? (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onShow&#125;</span>&gt;</span></span><br><span class="language-xml">          显示</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="22、保留和重置状态"><a href="#22、保留和重置状态" class="headerlink" title="22、保留和重置状态"></a>22、保留和重置状态</h3><ol><li>你重新渲染一个组件时， React 需要决定组件树中的哪些部分要保留和更新，以及丢弃或重新创建。在大多数情况下， React 的自动处理机制已经做得足够好了。默认情况下，React 会保留树中与先前渲染的组件树“匹配”的部分。</li><li>React 允许你覆盖默认行为，可通过向组件传递一个唯一 key（如 <Chat key={email}/> 来 强制 重置其状态。这会告诉 React ，如果收件人不同，应将其作为一个 不同的 Chat 组件，需要使用新数据和 UI（比如输入框）来重新创建它。现在，在接收者之间切换时就会重置输入框——即使渲染的是同一个组件。</li></ol><h3 id="23、提取状态逻辑到-reducer-中"><a href="#23、提取状态逻辑到-reducer-中" class="headerlink" title="23、提取状态逻辑到 reducer 中"></a>23、提取状态逻辑到 reducer 中</h3><ol><li>对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。在文件的底部，reducer 函数指定状态应该如何更新以响应每个 action！<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AddTask</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AddTask.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">TaskList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./TaskList.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TaskApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [tasks, dispatch] = <span class="hljs-title function_">useReducer</span>(<br>    tasksReducer,<br>    initialTasks<br>  );<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAddTask</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;added&#x27;</span>,<br>      <span class="hljs-attr">id</span>: nextId++,<br>      <span class="hljs-attr">text</span>: text,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChangeTask</span>(<span class="hljs-params">task</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;changed&#x27;</span>,<br>      <span class="hljs-attr">task</span>: task<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDeleteTask</span>(<span class="hljs-params">taskId</span>) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;deleted&#x27;</span>,<br>      <span class="hljs-attr">id</span>: taskId<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>布拉格行程<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AddTask</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onAddTask</span>=<span class="hljs-string">&#123;handleAddTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TaskList</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">tasks</span>=<span class="hljs-string">&#123;tasks&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChangeTask</span>=<span class="hljs-string">&#123;handleChangeTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onDeleteTask</span>=<span class="hljs-string">&#123;handleDeleteTask&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tasksReducer</span>(<span class="hljs-params">tasks, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;added&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> [...tasks, &#123;<br>        <span class="hljs-attr">id</span>: action.<span class="hljs-property">id</span>,<br>        <span class="hljs-attr">text</span>: action.<span class="hljs-property">text</span>,<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>      &#125;];<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;changed&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> tasks.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-property">id</span> === action.<span class="hljs-property">task</span>.<span class="hljs-property">id</span>) &#123;<br>          <span class="hljs-keyword">return</span> action.<span class="hljs-property">task</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> t;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;deleted&#x27;</span>: &#123;<br>      <span class="hljs-keyword">return</span> tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> !== action.<span class="hljs-property">id</span>);<br>    &#125;<br>    <span class="hljs-attr">default</span>: &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;未知操作：&#x27;</span> + action.<span class="hljs-property">type</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> nextId = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> initialTasks = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;参观卡夫卡博物馆&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;看木偶戏&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;列侬墙图片&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>];<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="24、使用-Context-进行深层数据传递"><a href="#24、使用-Context-进行深层数据传递" class="headerlink" title="24、使用 Context 进行深层数据传递"></a>24、使用 Context 进行深层数据传递</h3><ol><li>通常，你会通过 props 将信息从父组件传递给子组件。但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。<!--2. 这里的 Heading 组件通过“询问”最近的 Section 来确定其标题级别。每个 Section 的级别是通过给父 Section 添加的级别来确定的。每个 Section 都向它下层的所有组件提供信息，不需要逐层传递 props，而是通过 Context 来实现。--></li></ol><h3 id="25、使用-Reducer-和-Context-进行状态扩展"><a href="#25、使用-Reducer-和-Context-进行状态扩展" class="headerlink" title="25、使用 Reducer 和 Context 进行状态扩展"></a>25、使用 Reducer 和 Context 进行状态扩展</h3><ol><li>Reducer 帮助你合并组件的状态更新逻辑。Context 帮助你将信息深入传递给其他组件。你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。</li><li>基于这种想法，使用 reducer 来管理一个具有复杂状态的父组件。组件树中任何深度的其他组件都可以通过 context 读取其状态。还可以 dispatch 一些 action 来更新状态。</li></ol><h3 id="26、使用-ref-引用值"><a href="#26、使用-ref-引用值" class="headerlink" title="26、使用 ref 引用值"></a>26、使用 ref 引用值</h3><ol><li>当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref：<code>const ref = useRef(0);</code></li><li>与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 <code>ref.current</code> 属性访问该 ref 的当前值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    ref.<span class="hljs-property">current</span> = ref.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你点击了 &#x27;</span> + ref.<span class="hljs-property">current</span> + <span class="hljs-string">&#x27; 次!&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      点我！</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>ref 就像组件的一个不被 React 追踪的秘密口袋。例如，可以使用 ref 来存储 timeout ID、DOM 元素 和其他不影响组件渲染输出的对象。</li></ol><h3 id="27、使用-ref-操作-DOM"><a href="#27、使用-ref-操作-DOM" class="headerlink" title="27、使用 ref 操作 DOM"></a>27、使用 ref 操作 DOM</h3><ol><li>由于 React 会自动更新 DOM 以匹配渲染输出，因此组件通常不需要操作 DOM。但是，有时可能需要访问由 React 管理的 DOM 元素——例如聚焦节点、滚动到此节点，以及测量它的尺寸和位置。React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现。例如，点击按钮将使用 ref 聚焦输入框：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        聚焦输入框</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="28、使用-Effect-实现同步"><a href="#28、使用-Effect-实现同步" class="headerlink" title="28、使用 Effect 实现同步"></a>28、使用 Effect 实现同步</h3><ol><li>有些组件需要与外部系统同步。例如，可能需要根据 React 状态控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。与处理特定事件的事件处理程序不同，Effect 在渲染后运行一些代码。使用它将组件与 React 之外的系统同步。</li><li>多按几次播放&#x2F;暂停，观察视频播放器如何与 isPlaying 属性值保持同步：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState, useRef, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params">&#123; src, isPlaying &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPlaying) &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>    &#125;<br>  &#125;, [isPlaying]);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">playsInline</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isPlaying, setIsPlaying] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setIsPlaying(!isPlaying)&#125;&gt;</span><br><span class="language-xml">        &#123;isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">VideoPlayer</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isPlaying</span>=<span class="hljs-string">&#123;isPlaying&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><!--许多 Effect 也会自行“清理”。例如，与聊天服务器建立连接的 Effect 应该返回一个 cleanup 函数，告诉 React 如何断开组件与该服务器的连接：--></li></ol><h3 id="29、你可能不需要-Effect"><a href="#29、你可能不需要-Effect" class="headerlink" title="29、你可能不需要 Effect"></a>29、你可能不需要 Effect</h3><ol><li>Effect 是 React 范式中的一个逃脱方案。它们可以“逃出” React 并使组件和一些外部系统同步。如果没有涉及到外部系统（例如，需要根据一些 props 或 state 的变化来更新一个组件的 state），不应该使用 Effect。移除不必要的 Effect 可以让代码更容易理解，运行得更快，并且更少出错。</li><li>有两种常见的不必使用 Effect 的情况：<ol><li>不必为了渲染而使用 Effect 来转换数据。</li><li>不必使用 Effect 来处理用户事件。</li></ol></li><li>例如，不需要 Effect 来根据其他状态调整某些状态：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;泰勒&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;斯威夫特&#x27;</span>);<br><br>  <span class="hljs-comment">// 🔴 避免：多余的 state 和不必要的 Effect</span><br>  <span class="hljs-keyword">const</span> [fullName, setFullName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setFullName</span>(firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName);<br>  &#125;, [firstName, lastName]);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>相反，在渲染时进行尽可能多地计算：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">const</span> [firstName, setFirstName] = useState(<span class="hljs-string">&#x27;泰勒&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [lastName, setLastName] = useState(<span class="hljs-string">&#x27;斯威夫特&#x27;</span>);<br>  <span class="hljs-comment">// ✅ 非常好：在渲染期间进行计算</span><br>  <span class="hljs-keyword">const</span> fullName = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="30、响应式-Effect-的生命周期"><a href="#30、响应式-Effect-的生命周期" class="headerlink" title="30、响应式 Effect 的生命周期"></a>30、响应式 Effect 的生命周期</h3><ol><li>Effect 的生命周期不同于组件。组件可以挂载、更新或卸载。Effect 只能做两件事：开始同步某些东西，然后停止同步它。如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。</li></ol><h3 id="使用自定义-Hook-复用逻辑"><a href="#使用自定义-Hook-复用逻辑" class="headerlink" title="使用自定义 Hook 复用逻辑"></a>使用自定义 Hook 复用逻辑</h3><ol><li>React 有一些内置 Hook，例如 useState，useContext 和 useEffect。有时需要用途更特殊的 Hook：例如获取数据，记录用户是否在线或者连接聊天室。为了实现效果，可以根据应用需求创建自己的 Hook。</li><li>你可以创建自定义 Hooks，将它们组合在一起，在它们之间传递数据，并在组件之间重用它们。随着应用不断变大，你将减少手动编写的 Effect，因为你将能够重用已经编写的自定义 Hooks。React 社区也维护了许多优秀的自定义 Hooks。</li></ol>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac常用命令</title>
    <link href="/2023/11/22/macCommandUsed/"/>
    <url>/2023/11/22/macCommandUsed/</url>
    
    <content type="html"><![CDATA[<h3 id="1、修改文件权限"><a href="#1、修改文件权限" class="headerlink" title="1、修改文件权限"></a>1、修改文件权限</h3><p><code>sudo chmod -R 777 文件名称</code></p><h3 id="2、修改hosts"><a href="#2、修改hosts" class="headerlink" title="2、修改hosts"></a>2、修改hosts</h3><p><code>sudo vim /private/etc/hosts</code><br><code>sudo vi /etc/hosts</code></p><ol><li>sudo vi &#x2F;etc&#x2F;hosts</li><li>提示输入个人电脑密码</li><li>此时输入E，点击enter</li><li>看到hosts，此时输入i，看到命令行下面显示insert，输入自己需要修改的host</li><li>点击esc退出编辑</li><li>按住shift 和 :，输入wq保存退出</li></ol><h3 id="3、显示“隐藏文件”"><a href="#3、显示“隐藏文件”" class="headerlink" title="3、显示“隐藏文件”"></a>3、显示“隐藏文件”</h3><ol><li>局部：<br>操作快捷键 <code>command+shift+.</code></li><li>全局：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br> Mac关闭“显示隐藏文件”命令：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></li></ol><h3 id="4、查看8080端口占用情况"><a href="#4、查看8080端口占用情况" class="headerlink" title="4、查看8080端口占用情况"></a>4、查看8080端口占用情况</h3><p><code>sudo lsof -i tcp:8080 </code></p><h3 id="5、80端口转向8080"><a href="#5、80端口转向8080" class="headerlink" title="5、80端口转向8080"></a>5、80端口转向8080</h3><p><strong>（以下34配置在mac重启后需重新加载）</strong></p><ol><li><code>sudo vim /etc/pf.conf</code></li><li>在<code>rdr-anchor “com.apple/* </code>后面加上如下这一行（代表将发到80端口的数据转发到8080上,8080可以更改成自己的端口）<br><code>rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</code></li><li>重新加载配置<br><code>sudo pfctl -f /etc/pf.conf</code></li><li>启动<br><code>sudo pfctl -e</code></li></ol><h3 id="6、查看nginx运行状态"><a href="#6、查看nginx运行状态" class="headerlink" title="6、查看nginx运行状态"></a>6、查看nginx运行状态</h3><p><code>ps -ef | grep nginx</code></p><h3 id="7、查看java占用-清理占用"><a href="#7、查看java占用-清理占用" class="headerlink" title="7、查看java占用-清理占用"></a>7、查看java占用-清理占用</h3><p><code>ps -ef|grep java</code><br><code>kill -9 1234</code></p><h3 id="8、打开强制退出程序窗口"><a href="#8、打开强制退出程序窗口" class="headerlink" title="8、打开强制退出程序窗口"></a>8、打开强制退出程序窗口</h3><p><code>Command+Option+Esc</code></p>]]></content>
    
    
    <categories>
      
      <category>mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsArray</title>
    <link href="/2023/11/20/JsArray/"/>
    <url>/2023/11/20/JsArray/</url>
    
    <content type="html"><![CDATA[<h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><table><thead><tr><th>函数</th><th>锚点</th></tr></thead><tbody><tr><td><code>var arr = new Array()</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = new Array(10)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array(7)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array.of(7)</code></td><td><a href="#create">LINK</a></td></tr></tbody></table><h2 id="2、增加"><a href="#2、增加" class="headerlink" title="2、增加"></a>2、增加</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>concat()</code></td><td>合并</td><td><a href="#concat">LINK</a></td></tr><tr><td><code>unshift()</code></td><td>向开头添加</td><td><a href="#unshift">LINK</a></td></tr><tr><td><code>push()</code></td><td>向末尾添加</td><td><a href="#push">LINK</a></td></tr><tr><td><code>splice()</code></td><td>可选参数用于添加</td><td><a href="#splice">LINK</a></td></tr></tbody></table><h2 id="3、分割"><a href="#3、分割" class="headerlink" title="3、分割"></a>3、分割</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>slice()</code></td><td>切割</td><td><a href="#slice">LINK</a></td></tr></tbody></table><h2 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>splice()</code></td><td></td><td><a href="#splice">LINK</a></td></tr><tr><td><code>pop()</code></td><td></td><td><a href="#pop">LINK</a></td></tr><tr><td><code>shift()</code></td><td></td><td><a href="#shift">LINK</a></td></tr></tbody></table><h2 id="5、修改"><a href="#5、修改" class="headerlink" title="5、修改"></a>5、修改</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>constructor</code></td><td></td><td><a href="#constructor">LINK</a></td></tr><tr><td><code>prototype</code></td><td></td><td><a href="#prototype">LINK</a></td></tr><tr><td><code>length</code></td><td></td><td><a href="#length">LINK</a></td></tr><tr><td><code>valueOf()</code></td><td></td><td><a href="#valueOf">LINK</a></td></tr><tr><td><code>toString()</code></td><td></td><td><a href="#toString">LINK</a></td></tr></tbody></table><h2 id="6、查询"><a href="#6、查询" class="headerlink" title="6、查询"></a>6、查询</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>indexOf()</code></td><td></td><td><a href="#indexOf">LINK</a></td></tr><tr><td><code>lastIndexOf()</code></td><td></td><td><a href="#lastIndexOf">LINK</a></td></tr></tbody></table><h2 id="7、循环"><a href="#7、循环" class="headerlink" title="7、循环"></a>7、循环</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>forEach()</code></td><td></td><td><a href="#forEach">LINK</a></td></tr><tr><td><code>map()</code></td><td></td><td><a href="#map">LINK</a></td></tr><tr><td><code>filter()</code></td><td></td><td><a href="#filter">LINK</a></td></tr><tr><td><code>every()</code></td><td></td><td><a href="#every">LINK</a></td></tr><tr><td><code>some()</code></td><td></td><td><a href="#some">LINK</a></td></tr><tr><td><code>reduce()</code></td><td></td><td><a href="#reduce">LINK</a></td></tr><tr><td><code>reduceRight()</code></td><td></td><td><a href="#reduceRight">LINK</a></td></tr></tbody></table><h2 id="8、排序"><a href="#8、排序" class="headerlink" title="8、排序"></a>8、排序</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>sort()</code></td><td></td><td><a href="#sort">LINK</a></td></tr></tbody></table><ol><li><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a><a id="create">创建数组</a></h3><ol><li><h4 id="var-arr-new-Array"><a href="#var-arr-new-Array" class="headerlink" title="var arr &#x3D; new Array()"></a>var arr &#x3D; new Array()</h4><ol><li>创建一个空数组</li></ol></li><li><h4 id="var-arr-new-Array-10"><a href="#var-arr-new-Array-10" class="headerlink" title="var arr &#x3D; new Array(10)"></a>var arr &#x3D; new Array(10)</h4><ol><li>创建一个包含10项的数组</li></ol></li><li><h4 id="var-arr-Array-7"><a href="#var-arr-Array-7" class="headerlink" title="var arr &#x3D; Array(7)"></a>var arr &#x3D; Array(7)</h4><ol><li>创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）</li></ol></li><li><h4 id="var-arr-Array-of-7"><a href="#var-arr-Array-of-7" class="headerlink" title="var arr &#x3D; Array.of(7)"></a>var arr &#x3D; Array.of(7)</h4><ol><li>创建一个包含1个字符串7的数组</li></ol></li></ol></li><li><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ol><li>语法： <code>array.length</code></li><li>作用： 设置或返回数组中元素的数目</li></ol></li><li><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><ol><li><ol><li>向对象添加属性和方法</li></ol></li></ol></li><li><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><ol><li>返回对创建此对象的数组函数的引用</li></ol></li><li><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><ol><li>语法：<code>array.valueOf()</code></li><li>解析：返回 Array 对象的原始值。该原始值由 Array 对象派生的所有对象继承。valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。</li><li>是否改变原数组：N</li></ol></li><li><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ol><li>语法：<code>arrayObject.concat(arrayX,arrayX,......,arrayX)</code></li><li>解析：连接两个或多个数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ol><li>语法：<code>arrayObject.join(separator) /*separator-分隔符*/</code></li><li>解析：把数组中的所有元素放入一个字符串</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ol><li>语法：<code>arrayObject.reverse()</code></li><li>解析：颠倒数组中元素的顺序</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ol><li><p>语法：<code>arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。</code></p></li><li><p>解析：sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。</p></li><li><p>是否改变原数组: Y</p></li><li><p>不传参数，将不会按照数值大小排序，按照字符编码的顺序进行排序；</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;General&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-string">&#x27;John&#x27;</span>,<span class="hljs-string">&#x27;Army&#x27;</span>];<br><span class="hljs-keyword">var</span> resArr = arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr);<span class="hljs-comment">//输出   [&quot;Army&quot;, &quot;Bob&quot;, &quot;General&quot;, &quot;John&quot;,&quot;Tom&quot;]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br><span class="hljs-keyword">var</span> resArr2 = arr2.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr2);<span class="hljs-comment">//输出   [10, 111, 1899, 30, 35, 45, 50]</span><br></code></pre></td></tr></table></figure></li><li><p>传入参数，实现升序，降序；</p> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">  <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr3.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr3);<span class="hljs-comment">//输出  [10, 30, 35, 45, 50, 111, 1899]</span><br><br><span class="hljs-keyword">var</span> arr4 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr4.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> b - a;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr4);<span class="hljs-comment">//输出 [1899, 111, 50, 45, 35, 30, 10]</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的某个属性值排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml">  <span class="hljs-keyword">var</span> arr5 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10&#125;,&#123;id</span>:<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6&#125;,&#123;id</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2&#125;,&#123;id</span>:<span class="hljs-number">3</span>&#125;];<br>arr5.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr5);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2&#125;</span><br><span class="hljs-comment">//&#123;id: 3&#125;</span><br><span class="hljs-comment">//&#123;id: 5&#125;</span><br><span class="hljs-comment">//&#123;id: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的多个属性值排序，多条件排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs qml">      <span class="hljs-keyword">var</span> arr6 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">5,age</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6,age</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">9,age</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2,age</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">9</span>&#125;];<br>arr6.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.id === b.id)&#123;<span class="hljs-comment">//如果id相同，按照age的降序</span><br><span class="hljs-keyword">return</span> b.age - a.age<br>&#125;<span class="hljs-title">else</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr6);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2, age: 8&#125;</span><br><span class="hljs-comment">//&#123;id: 5, age: 4&#125;</span><br><span class="hljs-comment">//&#123;id: 6, age: 10&#125;</span><br><span class="hljs-comment">//&#123;id: 9, age: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 2&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ol><li>语法：<code>arrayObject.pop()</code></li><li>解析：删除并返回数组的最后一个元素。删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ol><li>语法：<code>arrayObject.shift()</code></li><li>解析：把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ol><li>语法：<code>arrayObject.unshift(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的开头添加一个或更多元素，并返回新的长度</li><li>返回值：arrayObject 的新长度。</li><li>是否改变原数组:</li></ol></li><li><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ol><li>语法：<code>arrayObject.push(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的末尾添加一个或多个元素，并返回新的长度。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ol><li>语法：<code>arrayObject.slice(start,end)   /*-1 指最后一个元素*/</code></li><li>解析：从已有的数组中返回选定的元素。返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</li><li>是否改变原数组: N</li></ol></li><li><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ol><li>语法：<code>arrayObject.splice(index,howmany,item1,.....,itemX)/* ary.splice(下标，删除数量，可选参数用于添加新项目)</code></li><li>解析：向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ol><li>语法：<code>array.indexOf(item,start)/* indexOf(查找的元素，可选参数规定开始检索得位置取值范围 [0-stringObject.length -1 ] )</code></li><li>解析：返回数组中某个指定的元素位置 从头到尾地检索数组</li><li>返回值：元素在数组中的位置，如果没有搜索到则返回-1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ol><li>语法：<code>stringObject.lastIndexOf(searchvalue,fromindex)</code></li><li>解析：返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索</li><li>返回值：如果要检索的字符串值没有出现，则该方法返回 -1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ol><li>语法：<code>array.toString()</code></li><li>解析：直接转为字符串，并返回</li><li>是否改变原数组:</li></ol></li><li><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ol><li>语法：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(currentValue, <span class="hljs-keyword">index</span>, arr), thisValue)<br>currentValue 当前元素<br><span class="hljs-keyword">index</span> 当前元素的索引值<br>arr 当前元素所属的数组对象<br>thisValue 可选。传递给函数的值一般用 &quot;this&quot; 值。<br>如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值<br></code></pre></td></tr></table></figure></li><li>解析：调用数组的每个元素，并将元素传递给回调函数。对于空数组是不会执行回调函数的。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ol><li>语法：<code>array.map(function(currentValue,index,arr), thisValue)同上</code></li><li>解析：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。按照原始数组元素顺序依次处理元素。不会对空数组进行检测。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ol><li>语法：<code>array.filter(function(currentValue,index,arr), thisValue)</code></li><li>解析：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。不会对空数组进行检测</li><li>返回值：没有符合条件的元素则返回空数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ol><li>语法：<code>array.every(function(currentValue,index,arr), thisValue)</code></li><li>解析：用于检测数组所有元素是否都符合指定条件。如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ol><li>语法：<code>array.some(function(currentValue,index,arr),thisValue)</code></li><li>解析：用于检测数组中的元素是否满足指定条件；会依次执行数组的每个元素；如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回false；不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ol><li>语法：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue) /initialValue 可选，传递给函数的初始值</code></li><li>解析：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。可以作为一个高阶函数，用于函数的 compose。对于空数组是不会执行回调函数。</li><li>是否改变原数组:</li></ol></li><li><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ol><li>语法：<code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>解析：功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加</li><li>是否改变原数组:</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsArray</title>
    <link href="/2023/11/20/JsArrayCopy/"/>
    <url>/2023/11/20/JsArrayCopy/</url>
    
    <content type="html"><![CDATA[<h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><table><thead><tr><th>函数</th><th>锚点</th></tr></thead><tbody><tr><td><code>var arr = new Array()</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = new Array(10)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array(7)</code></td><td><a href="#create">LINK</a></td></tr><tr><td><code>var arr = Array.of(7)</code></td><td><a href="#create">LINK</a></td></tr></tbody></table><h2 id="2、增加"><a href="#2、增加" class="headerlink" title="2、增加"></a>2、增加</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>concat()</code></td><td>合并</td><td><a href="#concat">LINK</a></td></tr><tr><td><code>unshift()</code></td><td>向开头添加</td><td><a href="#unshift">LINK</a></td></tr><tr><td><code>push()</code></td><td>向末尾添加</td><td><a href="#push">LINK</a></td></tr><tr><td><code>splice()</code></td><td>可选参数用于添加</td><td><a href="#splice">LINK</a></td></tr></tbody></table><h2 id="3、分割"><a href="#3、分割" class="headerlink" title="3、分割"></a>3、分割</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>slice()</code></td><td>切割</td><td><a href="#slice">LINK</a></td></tr></tbody></table><h2 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>splice()</code></td><td></td><td><a href="#splice">LINK</a></td></tr><tr><td><code>pop()</code></td><td></td><td><a href="#pop">LINK</a></td></tr><tr><td><code>shift()</code></td><td></td><td><a href="#shift">LINK</a></td></tr></tbody></table><h2 id="5、修改"><a href="#5、修改" class="headerlink" title="5、修改"></a>5、修改</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>constructor</code></td><td></td><td><a href="#constructor">LINK</a></td></tr><tr><td><code>prototype</code></td><td></td><td><a href="#prototype">LINK</a></td></tr><tr><td><code>length</code></td><td></td><td><a href="#length">LINK</a></td></tr><tr><td><code>valueOf()</code></td><td></td><td><a href="#valueOf">LINK</a></td></tr><tr><td><code>toString()</code></td><td></td><td><a href="#toString">LINK</a></td></tr></tbody></table><h2 id="6、查询"><a href="#6、查询" class="headerlink" title="6、查询"></a>6、查询</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>indexOf()</code></td><td></td><td><a href="#indexOf">LINK</a></td></tr><tr><td><code>lastIndexOf()</code></td><td></td><td><a href="#lastIndexOf">LINK</a></td></tr></tbody></table><h2 id="7、循环"><a href="#7、循环" class="headerlink" title="7、循环"></a>7、循环</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>forEach()</code></td><td></td><td><a href="#forEach">LINK</a></td></tr><tr><td><code>map()</code></td><td></td><td><a href="#map">LINK</a></td></tr><tr><td><code>filter()</code></td><td></td><td><a href="#filter">LINK</a></td></tr><tr><td><code>every()</code></td><td></td><td><a href="#every">LINK</a></td></tr><tr><td><code>some()</code></td><td></td><td><a href="#some">LINK</a></td></tr><tr><td><code>reduce()</code></td><td></td><td><a href="#reduce">LINK</a></td></tr><tr><td><code>reduceRight()</code></td><td></td><td><a href="#reduceRight">LINK</a></td></tr></tbody></table><h2 id="8、排序"><a href="#8、排序" class="headerlink" title="8、排序"></a>8、排序</h2><table><thead><tr><th>函数</th><th>简述</th><th>锚点</th></tr></thead><tbody><tr><td><code>sort()</code></td><td></td><td><a href="#sort">LINK</a></td></tr></tbody></table><ol><li><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a><a id="create">创建数组</a></h3><ol><li><h4 id="var-arr-new-Array"><a href="#var-arr-new-Array" class="headerlink" title="var arr &#x3D; new Array()"></a>var arr &#x3D; new Array()</h4><ol><li>创建一个空数组</li></ol></li><li><h4 id="var-arr-new-Array-10"><a href="#var-arr-new-Array-10" class="headerlink" title="var arr &#x3D; new Array(10)"></a>var arr &#x3D; new Array(10)</h4><ol><li>创建一个包含10项的数组</li></ol></li><li><h4 id="var-arr-Array-7"><a href="#var-arr-Array-7" class="headerlink" title="var arr &#x3D; Array(7)"></a>var arr &#x3D; Array(7)</h4><ol><li>创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）</li></ol></li><li><h4 id="var-arr-Array-of-7"><a href="#var-arr-Array-of-7" class="headerlink" title="var arr &#x3D; Array.of(7)"></a>var arr &#x3D; Array.of(7)</h4><ol><li>创建一个包含1个字符串7的数组</li></ol></li></ol></li><li><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ol><li>语法： <code>array.length</code></li><li>作用： 设置或返回数组中元素的数目</li></ol></li><li><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><ol><li><ol><li>向对象添加属性和方法</li></ol></li></ol></li><li><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><ol><li>返回对创建此对象的数组函数的引用</li></ol></li><li><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><ol><li>语法：<code>array.valueOf()</code></li><li>解析：返回 Array 对象的原始值。该原始值由 Array 对象派生的所有对象继承。valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。</li><li>是否改变原数组：N</li></ol></li><li><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ol><li>语法：<code>arrayObject.concat(arrayX,arrayX,......,arrayX)</code></li><li>解析：连接两个或多个数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ol><li>语法：<code>arrayObject.join(separator) /*separator-分隔符*/</code></li><li>解析：把数组中的所有元素放入一个字符串</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ol><li>语法：<code>arrayObject.reverse()</code></li><li>解析：颠倒数组中元素的顺序</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ol><li><p>语法：<code>arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。</code></p></li><li><p>解析：sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。</p></li><li><p>是否改变原数组: Y</p></li><li><p>不传参数，将不会按照数值大小排序，按照字符编码的顺序进行排序；</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;General&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-string">&#x27;John&#x27;</span>,<span class="hljs-string">&#x27;Army&#x27;</span>];<br><span class="hljs-keyword">var</span> resArr = arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr);<span class="hljs-comment">//输出   [&quot;Army&quot;, &quot;Bob&quot;, &quot;General&quot;, &quot;John&quot;,&quot;Tom&quot;]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br><span class="hljs-keyword">var</span> resArr2 = arr2.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr2);<span class="hljs-comment">//输出   [10, 111, 1899, 30, 35, 45, 50]</span><br></code></pre></td></tr></table></figure></li><li><p>传入参数，实现升序，降序；</p> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">  <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr3.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr3);<span class="hljs-comment">//输出  [10, 30, 35, 45, 50, 111, 1899]</span><br><br><span class="hljs-keyword">var</span> arr4 = [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">111</span>,<span class="hljs-number">35</span>,<span class="hljs-number">1899</span>,<span class="hljs-number">50</span>,<span class="hljs-number">45</span>];<br>arr4.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-keyword">return</span> b - a;<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr4);<span class="hljs-comment">//输出 [1899, 111, 50, 45, 35, 30, 10]</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的某个属性值排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml">  <span class="hljs-keyword">var</span> arr5 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10&#125;,&#123;id</span>:<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6&#125;,&#123;id</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2&#125;,&#123;id</span>:<span class="hljs-number">3</span>&#125;];<br>arr5.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr5);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2&#125;</span><br><span class="hljs-comment">//&#123;id: 3&#125;</span><br><span class="hljs-comment">//&#123;id: 5&#125;</span><br><span class="hljs-comment">//&#123;id: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>根据数组中的对象的多个属性值排序，多条件排序；</p> <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs qml">      <span class="hljs-keyword">var</span> arr6 = [&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">5,age</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">6,age</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">9,age</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2,age</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-attribute">id:</span><span class="hljs-string">10,age</span>:<span class="hljs-number">9</span>&#125;];<br>arr6.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.id === b.id)&#123;<span class="hljs-comment">//如果id相同，按照age的降序</span><br><span class="hljs-keyword">return</span> b.age - a.age<br>&#125;<span class="hljs-title">else</span>&#123;<br><span class="hljs-keyword">return</span> a.id - b.id<br>&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr6);<br><span class="hljs-comment">//输出新的排序</span><br><span class="hljs-comment">//&#123;id: 2, age: 8&#125;</span><br><span class="hljs-comment">//&#123;id: 5, age: 4&#125;</span><br><span class="hljs-comment">//&#123;id: 6, age: 10&#125;</span><br><span class="hljs-comment">//&#123;id: 9, age: 6&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 9&#125;</span><br><span class="hljs-comment">//&#123;id: 10, age: 2&#125;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ol><li>语法：<code>arrayObject.pop()</code></li><li>解析：删除并返回数组的最后一个元素。删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ol><li>语法：<code>arrayObject.shift()</code></li><li>解析：把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ol><li>语法：<code>arrayObject.unshift(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的开头添加一个或更多元素，并返回新的长度</li><li>返回值：arrayObject 的新长度。</li><li>是否改变原数组:</li></ol></li><li><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ol><li>语法：<code>arrayObject.push(newelement1,newelement2,....,newelementX)</code></li><li>解析：向数组的末尾添加一个或多个元素，并返回新的长度。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ol><li>语法：<code>arrayObject.slice(start,end)   /*-1 指最后一个元素*/</code></li><li>解析：从已有的数组中返回选定的元素。返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</li><li>是否改变原数组: N</li></ol></li><li><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ol><li>语法：<code>arrayObject.splice(index,howmany,item1,.....,itemX)/* ary.splice(下标，删除数量，可选参数用于添加新项目)</code></li><li>解析：向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。</li><li>是否改变原数组: Y</li></ol></li><li><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ol><li>语法：<code>array.indexOf(item,start)/* indexOf(查找的元素，可选参数规定开始检索得位置取值范围 [0-stringObject.length -1 ] )</code></li><li>解析：返回数组中某个指定的元素位置 从头到尾地检索数组</li><li>返回值：元素在数组中的位置，如果没有搜索到则返回-1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ol><li>语法：<code>stringObject.lastIndexOf(searchvalue,fromindex)</code></li><li>解析：返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索</li><li>返回值：如果要检索的字符串值没有出现，则该方法返回 -1</li><li>是否改变原数组: N</li></ol></li><li><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ol><li>语法：<code>array.toString()</code></li><li>解析：直接转为字符串，并返回</li><li>是否改变原数组:</li></ol></li><li><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ol><li>语法：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(currentValue, <span class="hljs-keyword">index</span>, arr), thisValue)<br>currentValue 当前元素<br><span class="hljs-keyword">index</span> 当前元素的索引值<br>arr 当前元素所属的数组对象<br>thisValue 可选。传递给函数的值一般用 &quot;this&quot; 值。<br>如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值<br></code></pre></td></tr></table></figure></li><li>解析：调用数组的每个元素，并将元素传递给回调函数。对于空数组是不会执行回调函数的。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ol><li>语法：<code>array.map(function(currentValue,index,arr), thisValue)同上</code></li><li>解析：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。按照原始数组元素顺序依次处理元素。不会对空数组进行检测。</li><li>是否改变原数组: N</li></ol></li><li><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ol><li>语法：<code>array.filter(function(currentValue,index,arr), thisValue)</code></li><li>解析：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。不会对空数组进行检测</li><li>返回值：没有符合条件的元素则返回空数组</li><li>是否改变原数组: N</li></ol></li><li><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ol><li>语法：<code>array.every(function(currentValue,index,arr), thisValue)</code></li><li>解析：用于检测数组所有元素是否都符合指定条件。如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ol><li>语法：<code>array.some(function(currentValue,index,arr),thisValue)</code></li><li>解析：用于检测数组中的元素是否满足指定条件；会依次执行数组的每个元素；如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回false；不会对空数组进行检测</li><li>是否改变原数组: N</li></ol></li><li><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ol><li>语法：<code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue) /initialValue 可选，传递给函数的初始值</code></li><li>解析：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。可以作为一个高阶函数，用于函数的 compose。对于空数组是不会执行回调函数。</li><li>是否改变原数组:</li></ol></li><li><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ol><li>语法：<code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>解析：功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加</li><li>是否改变原数组:</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用CSS</title>
    <link href="/2023/11/20/CSSofCommonlyUsed/"/>
    <url>/2023/11/20/CSSofCommonlyUsed/</url>
    
    <content type="html"><![CDATA[<h3 id="文字超出隐藏并显示省略号"><a href="#文字超出隐藏并显示省略号" class="headerlink" title="文字超出隐藏并显示省略号"></a>文字超出隐藏并显示省略号</h3><ol><li>单行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br><span class="hljs-attribute">white-space</span>: nowrap;      <span class="hljs-comment">/*超出的空白区域不换行*/</span><br><span class="hljs-attribute">overflow</span>: hidden;         <span class="hljs-comment">/*超出隐藏*/</span><br><span class="hljs-attribute">text-overflow</span>: ellipsis;  <span class="hljs-comment">/*文本超出显示省略号*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>两行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">display</span>: -webkit-box;             <span class="hljs-comment">/*将对象转为弹性盒模型展示*/</span><br>    -webkit-box-orient: vertical;     <span class="hljs-comment">/*设置弹性盒模型子元素的排列方式*/</span><br>    -webkit-line-clamp: <span class="hljs-number">2</span>;            <span class="hljs-comment">/*限制文本行数*/</span><br>    <span class="hljs-attribute">overflow</span>: hidden;                 <span class="hljs-comment">/*超出隐藏*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>多行实现文本溢出显示省略号：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4em</span>;        <span class="hljs-comment">/*行高和height成倍数，这里以三行文本超出隐藏举例*/</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">4.2em</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">::after</span>&#123;         <span class="hljs-comment">/*若要兼容IE8需用:after*/</span><br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;...&quot;</span>;          <span class="hljs-comment">/*替换内容比较灵活*/</span><br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">right</span>:<span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">3px</span>;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;         <span class="hljs-comment">/*颜色和文字背景保持一致*/</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#fff</span>;  <span class="hljs-comment">/*边缘处理*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="滚动条样式设置"><a href="#滚动条样式设置" class="headerlink" title="滚动条样式设置"></a>滚动条样式设置</h3><ol><li>属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">::-webkit-scrollbar    //滚动条整体部分<br>::-webkit-scrollbar-button   //滚动条两端的按钮<br>::-webkit-scrollbar-track   // 外层轨道<br>::-webkit-scrollbar-track-piece    //内层轨道，滚动条中间部分（除去）<br>::-webkit-scrollbar-thumb //滚动条里面可以拖动的那个<br>::-webkit-scrollbar-corner   //边角<br>::-webkit-resizer   ///定义右下角拖动块的样式<br></code></pre></td></tr></table></figure></li><li>示例<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">//  定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸<br>&amp;::-webkit-scrollbar &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0.16rem</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0.16rem</span>;<br>    // <span class="hljs-attribute">background-color</span>: green;<br>&#125;<br><br>// 定义滚动条轨道 内阴影+圆角<br>&amp;::-webkit-scrollbar-track &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#011822</span>;<br>&#125;<br><br>// 定义滑块  内阴影+圆角<br>&amp;::-webkit-scrollbar-thumb &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0.16rem</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.08rem</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#023548</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="文字向两侧对齐"><a href="#文字向两侧对齐" class="headerlink" title="文字向两侧对齐"></a>文字向两侧对齐</h3><p><code>text-align: justify;</code></p><table><thead><tr><th>text-align</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td></td><td>start</td><td>如果内容方向是左至右，则等于 left，反之则为 right。</td></tr><tr><td></td><td>end</td><td>如果内容方向是左至右，则等于 right，反之则为 left。</td></tr><tr><td></td><td>left</td><td>行内内容向左侧边对齐。</td></tr><tr><td></td><td>right</td><td>行内内容向右侧边对齐。</td></tr><tr><td></td><td>center</td><td>行内内容居中。</td></tr><tr><td></td><td>justify</td><td>文字向两侧对齐，对最后一行无效。</td></tr><tr><td></td><td>justify-all</td><td>和 justify 一致，但是强制使最后一行两端对齐。</td></tr><tr><td></td><td>match-parent</td><td>和 inherit 类似，区别在于 start 和 end 的值根据父元素的 direction 确定，并被替换为恰当的 left 或 right 值。</td></tr></tbody></table><!--|   | <string> | 应用在单元格时，指定单元格内容相对于哪个字符对齐。|-->]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>css3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错/难题本</title>
    <link href="/2023/11/20/errorRecord/"/>
    <url>/2023/11/20/errorRecord/</url>
    
    <content type="html"><![CDATA[<h3 id="字体文件较大解决方案"><a href="#字体文件较大解决方案" class="headerlink" title="字体文件较大解决方案"></a>字体文件较大解决方案</h3><p>字体过大的话，会导致页面加载的时候，文字显示不出来，不过可以试试CSS的这个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-display</span>: swap;<br></code></pre></td></tr></table></figure><p>放的方式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">// OPPOSans<br><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&#x27;OPPOSans&#x27;</span>;<br>    <span class="hljs-attribute">font-style</span>: normal;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;<br>    <span class="hljs-attribute">font-display</span>: swap;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">local</span>(<span class="hljs-string">&#x27;OPPOSans&#x27;</span>),<br>            <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://************/fonts/OPPOSans-L.woff&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>            <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://************/fonts/OPPOSans-L.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;ttf&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置字体顺序的地方需要把新字体放在第一位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;OPPOSans&#x27;</span>,Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的加载方式是，页面加载中的时候，用默认字体进行显示，等字体加载完成后，页面字体会自动更新，并且不会阻塞页面渲染和操作，所以第二位的字体尽量找比较接近的系统字体做替代显示</p><h3 id="微信分享无图无文字情况"><a href="#微信分享无图无文字情况" class="headerlink" title="微信分享无图无文字情况"></a>微信分享无图无文字情况</h3><ol><li>已遇到情况最终问题解决方案：微信白名单ip限制 需手动配置</li></ol><h3 id="html-body设置宽高100-间距0仍有底部留白"><a href="#html-body设置宽高100-间距0仍有底部留白" class="headerlink" title="html,body设置宽高100%间距0仍有底部留白"></a>html,body设置宽高100%间距0仍有底部留白</h3><ol><li>answer：img设置display:block;font-size:0;</li></ol><h3 id="git提交之后提交记录没有绿点处理"><a href="#git提交之后提交记录没有绿点处理" class="headerlink" title="git提交之后提交记录没有绿点处理"></a>git提交之后提交记录没有绿点处理</h3><ol><li>记录原因：本地git账号和邮箱与git上不一致导致</li><li>解决：设置一致 <ol><li>查询：<ol><li><code>git config user.name</code></li><li><code>git config user.email</code></li></ol></li><li>设置：<ol><li><code>git config --global user.name yourname</code></li><li><code>git config --global user.email youremail</code></li></ol></li></ol></li></ol><h3 id="certificate-has-expired"><a href="#certificate-has-expired" class="headerlink" title="certificate has expired"></a>certificate has expired</h3><ol><li>解决执行npm(或pnpm)时报：证书过期 certificate has expired问题<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、取消ssl验证：<br> <br>npm config set strict-ssl <span class="hljs-literal">false</span><br> <br>这个方法一般就可以解决了。<br> <br><span class="hljs-number">2</span>、更换npm镜像源：<br> <br>npm config set registry http:<span class="hljs-comment">//registry.cnpmjs.org</span><br>npm config set registry http:<span class="hljs-comment">//registry.npm.taobao.org</span><br> <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>错题本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错题</tag>
      
      <tag>日常记录</tag>
      
      <tag>bug</tag>
      
      <tag>难题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>photoshopStart</title>
    <link href="/2023/11/17/photoshopStart/"/>
    <url>/2023/11/17/photoshopStart/</url>
    
    <content type="html"><![CDATA[<h3 id="认识界面"><a href="#认识界面" class="headerlink" title="认识界面"></a>认识界面</h3><ol><li><h4 id="油漆桶（更改背景色）"><a href="#油漆桶（更改背景色）" class="headerlink" title="油漆桶（更改背景色）"></a>油漆桶（更改背景色）</h4><ol><li><p>上面的代表前景色 下面的是背景色 左上角可重置颜色 右上角可颜色互换</p><ol><li><img src="/img/ps/17002063180368.jpg"></li><li>点击背景色弹出拾色器窗口，可以从中选择</li></ol></li><li><p>选好颜色后shift+左键渲染工作面</p><ol><li><img src="/img/ps/17002045896302.jpg"></li></ol></li><li><p>也可右键点击展开选择预设置颜色</p><ol><li><img src="/img/ps/17002046915979.jpg"></li></ol></li></ol></li><li><h4 id="复位基本功能（一键重置）"><a href="#复位基本功能（一键重置）" class="headerlink" title="复位基本功能（一键重置）"></a>复位基本功能（一键重置）</h4><ol><li>各种操作区域操作乱序 在 <strong>窗口-&gt;工作区-&gt;复位基本功能</strong> 重置</li></ol></li></ol><h3 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h3><ol><li>菜单栏-文件-新建 右边修改初始配置参数<ol><li><img src="/img/ps/17002057788246.jpg"></li></ol></li></ol><h3 id="图像大小"><a href="#图像大小" class="headerlink" title="图像大小"></a>图像大小</h3><ol><li>再次修改文档参数 图像-图像大小<ol><li>快捷键：win：<code>ctrl+alt+i</code> mac:<code>cmd+option+i</code></li><li><img src="/img/ps/17002071119831.jpg"></li></ol></li></ol><h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><ol><li>直接保存（改变源文件）</li><li>另存为</li></ol><h3 id="性能配置-开工前的准备工作"><a href="#性能配置-开工前的准备工作" class="headerlink" title="性能配置-开工前的准备工作"></a>性能配置-开工前的准备工作</h3><ol><li>首选项 <ol><li>快捷键win<code>ctrl+k</code> mac<code>cmd+k</code></li><li>暂存盘<ol><li><img src="/img/ps/17002077698935.jpg"></li></ol></li><li>历史记录<ol><li>可回到做错前的次数 菜单窗口-历史记录</li><li><img src="/img/ps/17002116764872.jpg"></li></ol></li><li>自动保存设置<ol><li><img src="/img/ps/17002118672543.jpg"></li></ol></li><li>快捷键设置<ol><li>菜单编辑-键盘快捷键</li></ol></li></ol></li></ol><h3 id="图层知识"><a href="#图层知识" class="headerlink" title="图层知识"></a>图层知识</h3><ol><li>位置<ol><li>菜单图层</li><li>面板栏的图层面板（窗口-图层）</li></ol></li><li>创建普通图层<ol><li>点击添加按钮（新建图层双击标题区域即可修改名称，增删改查也在此窗口操作）<ol><li><img src="/img/ps/17002125816426.jpg"></li></ol></li><li>option+上面按钮即可唤出<ol><li><img src="/img/ps/17002126818904.jpg"></li></ol></li></ol></li></ol><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><ol><li>查看画面的方式<ol><li>左边抓手工具（按住空格键不松）</li><li>缩放工具（放大镜图标）</li><li>旋转工具（在抓手工具内）</li></ol></li></ol><!--### 移动工具-->]]></content>
    
    
    <categories>
      
      <category>photoShop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown基础语法</title>
    <link href="/2023/11/16/markdownGrammar/"/>
    <url>/2023/11/16/markdownGrammar/</url>
    
    <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/">Markdown 官方教程</a></p><!--* <a href="#preface">图片语法</a>--><ol><li><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><ol><li>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。例如，添加三个 <code>#</code> 表示创建一个三级标题 (<code>&lt;h3&gt;</code>)<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"># h1<br>######  h6<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="2、段落"><a href="#2、段落" class="headerlink" title="2、段落"></a>2、段落</h3><ol><li><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ol><li>段落的换行是使用两个以上空格加上回车。也可以在段落后面使用一个空行来表示重新开始一个段落。</li></ol></li><li><h4 id="加粗倾斜"><a href="#加粗倾斜" class="headerlink" title="加粗倾斜"></a>加粗倾斜</h4></li></ol> <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><p> <em>斜体文本</em><br> <em>斜体文本</em><br> <strong>粗体文本</strong><br> <strong>粗体文本</strong><br> <em><strong>粗斜体文本</strong></em><br> <em><strong>粗斜体文本</strong></em></p><ol start="3"><li><h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4></li></ol> <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">***</span><br><span class="hljs-comment">* * *</span><br><span class="hljs-comment">*****</span><br>- - -<br>----------<br></code></pre></td></tr></table></figure><hr><hr><hr><hr><hr><ol start="4"><li><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4></li></ol> <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~删除线~~<br></code></pre></td></tr></table></figure><p> <del>删除线</del></p><ol start="5"><li><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4></li></ol> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <u>带下划线文本</u></p></li></ol><!--    6. #### 脚注    生成一个脚注1[^footnote].            [^footnote]: 这里是 **脚注** 的 *内容*.        生成一个脚注2[^foot].            [^foot]:这里是**脚注2**的*内容*.--><ol><li><h3 id="3、换行"><a href="#3、换行" class="headerlink" title="3、换行"></a>3、换行</h3><ol><li>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)</li></ol></li><li><h3 id="4、区块"><a href="#4、区块" class="headerlink" title="4、区块"></a>4、区块</h3><ol><li>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">同层引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">同层引用</span><br></code></pre></td></tr></table></figure><blockquote><p>区块引用<br>同层引用<br>同层引用</p></blockquote></li><li>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">最外层</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></li><li>区块中使用列表 <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块中使用列表</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote></li><li>列表中使用区块 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-quote">&gt; 学习</span><br><span class="hljs-quote">&gt; 学而时习之</span><br><span class="hljs-bullet">*</span> 第二项<br></code></pre></td></tr></table></figure></li></ol><ul><li>第一项<blockquote><p>学习<br>学而时习之</p></blockquote></li><li>第二项</li></ul></li><li><h3 id="5、列表"><a href="#5、列表" class="headerlink" title="5、列表"></a>5、列表</h3><ol><li><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></li><li><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li></ol></li><li><h3 id="6、代码"><a href="#6、代码" class="headerlink" title="6、代码"></a>6、代码</h3><ol><li>要将单词或短语表示为代码，请将其包裹在<strong>反引号 (&#96;&#96;)</strong> 中。<ol><li><code>code part</code></li></ol></li><li>转义反引号 <ol><li>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在 <strong>双反引号(&#96;&#96;)</strong> 中。<ol><li><code>Use `code` in your Markdown file.</code></li></ol></li></ol></li><li>代码块<ol><li><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符(<strong>Tab键</strong>)。 也可以用 <code>```</code> 包裹一段代码，并指定一种语言（也可以不指定）</p></li><li><p><strong>(<code>```内容```</code>)</strong><br> <img src="/img/js/17004620062132.jpg"></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>在使用该语法时开头之前必须要有一行空行，若要标记语言则在开头语法加一个空格然后声明语言类型(具体如图所示)，既然开头有要求自然结束也有要求的。结束时切忌不要在结束标签后加空格，否则该标签未关闭。<strong>关闭则直接回车换两行即可</strong>。</p></li></ol></li></ol></li><li><h3 id="7、分割线"><a href="#7、分割线" class="headerlink" title="7、分割线"></a>7、分割线</h3><ol><li>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。<ol><li><hr><ol><li><code>***</code></li></ol></li><li><hr><ol><li><code>---</code></li></ol></li><li><hr><ol><li><code>___</code></li></ol></li></ol></li></ol></li><li><h3 id="8、链接"><a href="#8、链接" class="headerlink" title="8、链接"></a>8、链接</h3><ol><li><strong>链接文本</strong>放在中括号内，链接地址放在后面的括号中，链接title可选。<ol><li><code> [Markdown语法](https://markdown.com.cn)。</code><br> <a href="https://markdown.com.cn/">Markdown语法</a>。</li></ol></li><li>链接title是当<strong>鼠标悬停在链接上时会出现的文字</strong>，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。<br> 1. <code>[Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。</code><br> <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</li></ol></li><li><h3 id="9、图片"><a href="#9、图片" class="headerlink" title="9、图片"></a>9、<a id="preface">图片</a></h3><ol><li>要<strong>添加图像</strong>，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![这是图片](https:<span class="hljs-regexp">//m</span>arkdown.com.cn<span class="hljs-regexp">/assets/img</span>/philly-magic-garden.<span class="hljs-number">9</span>c0b4415.jpg <span class="hljs-string">&quot;Magic Gardens&quot;</span>) <br></code></pre></td></tr></table></figure> <img src="https://markdown.com.cn/assets/img/philly-magic-garden.9c0b4415.jpg" alt="这是图片" title="Magic Gardens"></li><li>给<strong>图片增加链接</strong>，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[![沙漠中的岩石图片]<span class="hljs-params">(https://tse3-mm.cn.bing.net/th/id/OIP-C.ECTYUcRzB9FMRqYOYvZnSQHaEK?<span class="hljs-attr">w</span>=308&amp;<span class="hljs-attr">h</span>=180&amp;<span class="hljs-attr">c</span>=7&amp;<span class="hljs-attr">r</span>=0&amp;<span class="hljs-attr">o</span>=5&amp;<span class="hljs-attr">dpr</span>=2&amp;<span class="hljs-attr">pid</span>=1.7 &quot;Shiprock&quot;)</span>]<span class="hljs-params">(https://markdown.com.cn)</span><br></code></pre></td></tr></table></figure> <a href="https://markdown.com.cn/"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.ECTYUcRzB9FMRqYOYvZnSQHaEK?w=308&h=180&c=7&r=0&o=5&dpr=2&pid=1.7" alt="沙漠中的岩石图片" title="Shiprock"></a></li></ol></li><li><h3 id="10、表格"><a href="#10、表格" class="headerlink" title="10、表格"></a>10、表格</h3></li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐示例</th><th align="right">右对齐示例</th><th align="center">居中对齐示例</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><pre><code class="hljs">用html代码处理    &lt;tr&gt;    &lt;th&gt;属性&lt;/th&gt;    &lt;th&gt;属性值&lt;/th&gt;    &lt;th&gt;描述&lt;/th&gt;  &lt;/tr &gt;&lt;tr &gt;    &lt;td rowspan=&quot;9&quot;&gt;type&lt;/td&gt;    &lt;td&gt;text&lt;/td&gt;    &lt;td&gt;单行文本输入框&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;password&lt;/td&gt;    &lt;td&gt;密码输入框&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;radio&lt;/td&gt;    &lt;td&gt;单选按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;CheckBox&lt;/td&gt;    &lt;td&gt;复选按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;button&lt;/td&gt;    &lt;td&gt;普通按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;submit&lt;/td&gt;    &lt;td&gt;提交按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;reset&lt;/td&gt;    &lt;td&gt;重置按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;image&lt;/td&gt;    &lt;td&gt;图像形式的提交按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;file&lt;/td&gt;    &lt;td&gt;文件域&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;name&lt;/td&gt;    &lt;td&gt;用户自定义&lt;/td&gt;    &lt;td&gt;控件名称&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;value&lt;/td&gt;    &lt;td &gt;用户自定义&lt;/td&gt;    &lt;td &gt;默认文本值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;size&lt;/td&gt;    &lt;td &gt;正整数&lt;/td&gt;    &lt;td &gt;控件在页面中的显示宽度&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;checked&lt;/td&gt;    &lt;td &gt;checked&lt;/td&gt;    &lt;td &gt;定义选择控件默认被选中项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td &gt;maxlength&lt;/td&gt;    &lt;td &gt;正整数&lt;/td&gt;    &lt;td &gt;控件允许输入的最多字符&lt;/td&gt;&lt;/tr&gt;</code></pre></table><table>    <tr>        <th>属性</th>        <th>属性值</th>        <th>描述</th>      </tr >    <tr >        <td rowspan="9">type</td>        <td>text</td>        <td>单行文本输入框</td>    </tr>    <tr>        <td>password</td>        <td>密码输入框</td>    </tr>    <tr>        <td>radio</td>        <td>单选按钮</td>    </tr>    <tr>        <td>CheckBox</td>        <td>复选按钮</td>    </tr>    <tr><td>button</td>        <td>普通按钮</td>    </tr>    <tr>        <td>submit</td>        <td>提交按钮</td>    </tr>    <tr>        <td>reset</td>        <td>重置按钮</td>    </tr>    <tr>        <td>image</td>        <td>图像形式的提交按钮</td>    </tr>    <tr>        <td >file</td>        <td>文件域</td>    </tr>    <tr>        <td >name</td>        <td>用户自定义</td>        <td>控件名称</td>    </tr>    <tr>        <td >value</td>        <td >用户自定义</td>        <td >默认文本值</td>    </tr>    <tr>        <td >size</td>        <td >正整数</td>        <td >控件在页面中的显示宽度</td>    </tr>    <tr>        <td >checked</td>        <td >checked</td>        <td >定义选择控件默认被选中项</td>    </tr>    <tr>        <td >maxlength</td>        <td >正整数</td>        <td >控件允许输入的最多字符</td>    </tr></table><h3 id="11、锚点"><a href="#11、锚点" class="headerlink" title="11、锚点"></a>11、锚点</h3><ol><li>使用a标签 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">第一步：添加链接<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#preface&quot;</span>&gt;</span>前言<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>第二步：添加锚点<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preface&quot;</span>&gt;</span>前言<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用md语法 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一步：添加链接[测试2](<span class="hljs-comment">#test2)</span><br>第二步：添加锚点&lt;a <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;测试2&lt;/a&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="12、更改字体大小、颜色、更改字体"><a href="#12、更改字体大小、颜色、更改字体" class="headerlink" title="12、更改字体大小、颜色、更改字体"></a>12、更改字体大小、颜色、更改字体</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;font <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;逐浪立楷&quot;</span> <span class="hljs-attribute">color</span>=green <span class="hljs-attribute">size</span>=10&gt;我是逐浪立楷，绿色，尺寸为5&lt;/font&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>markDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>md</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的安装及git部署</title>
    <link href="/2023/11/15/hexoStall/"/>
    <url>/2023/11/15/hexoStall/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h3><ol><li>node</li><li>git</li></ol><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ol><li>新建一个文件夹用来存放 Hexo 的程序文件</li><li><code>npm install -g hexo-cli</code><ol><li>mac需要管理员权限（sudo）</li></ol></li><li>初始化&amp;本地预览<ol><li><code>hexo init</code> #初始化</li><li><code>npm install</code> #安装组件</li><li><code>hexo g</code> #生成页面</li><li><code>hexo s</code> #启动预览</li></ol></li></ol><h3 id="部署至github"><a href="#部署至github" class="headerlink" title="部署至github"></a>部署至github</h3><ol><li><p>创建github page 仓库</p><ol><li>Repository name 中输入 用户名 <strong>.github.io</strong></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li><li>-创建后默认自动启用 HTTPS，博客地址为：https:&#x2F;&#x2F;用户名.github.io</li></ol></li><li><p>安装hexo-deployer-git</p><ol><li><code>npm install hexo-deployer-git --save</code></li></ol></li><li><p>修改 _config.yml 文件末尾的 Deployment 部分</p> <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:用户名/用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> master <br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>用户名一致，都为git账户名称</strong></p></li><li><p><strong>branch为上传分支，git新建项目时默认为main需切换分支或改为main</strong></p><ol><li><img src="/img/hexo/17001017178769.jpg"></li></ol></li><li><p><strong>确认git发布分支是否为当前上传分支，不是则切换</strong></p><ol><li><img src="/img/hexo/17001017531171.jpg"></li></ol></li></ol></li><li><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages,访问 GitHub 域名 https:&#x2F;&#x2F;用户名.github.io</p></li></ol><h3 id="hexo基础"><a href="#hexo基础" class="headerlink" title="hexo基础"></a>hexo基础</h3><ol><li>hexo基础命令<ol><li><code>hexo init [folder]</code> <ol><li>#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</li></ol></li><li><strong><code>hexo new [layout] &lt;title&gt;</code></strong><ol><li>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</li><li><code>hexo new &quot;post title with &quot;whitespace&quot;</code></li></ol></li><li><code>hexo generate</code><ol><li>生成静态文件。</li><li>简写 <strong><code>hexo g</code></strong></li></ol></li><li><code>hexo publish [layout] &lt;filename&gt;</code> <ol><li>#发表草稿</li></ol></li><li><code>hexo server</code><ol><li>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></li><li><code>-p, --port</code>重设端口</li><li><code>-s, --static</code>只使用静态文件</li><li><code>-l, --log</code>启动日记记录，使用覆盖记录格式</li><li>简写 <strong><code>hexo s</code></strong></li></ol></li><li><code>hexo deploy</code>  <ol><li>部署网站。简写 <strong><code>hexo d</code></strong></li><li><strong><code>hexo g -d</code></strong> 部署之前预先生成静态文件</li></ol></li><li><strong><code>hexo clean</code></strong> <ol><li>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</li></ol></li><li>hexo 更换网站小图标 <ol><li>配置文件中 <strong><code>favicon: /img/index/bk.png </code></strong></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
